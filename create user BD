
Instalar Oracle ODBC en Windows
 https://manjaro.site/how-to-install-oracle-odbc-driver-on-windows-10/

( _¯:_¯:_¯:_¯[_¯ _¯]_¯:_¯:_¯:_¯ ) (List of Most Recent SQL Server Backups ) ELAPSED BACKUP RESPALDO ( _¯:_¯:_¯:_¯[_¯ _¯]_¯:_¯:_¯:_¯ )


DECLARE @dbname sysname
SET @dbname = NULL --set this to be whatever dbname you want
SELECT 
  bup.user_name AS [User],
  bup.database_name AS [Database],
  bup.server_name AS [Server],
  bup.backup_start_date AS [Backup Started],
  bup.backup_finish_date AS [Backup Finished]
  ,CAST((CAST(DATEDIFF(s, bup.backup_start_date, bup.backup_finish_date) AS int))/3600 AS varchar) + ' hours, ' 
  + CAST((CAST(DATEDIFF(s, bup.backup_start_date, bup.backup_finish_date) AS int))/60 AS varchar)+ ' minutes, '
  + CAST((CAST(DATEDIFF(s, bup.backup_start_date, bup.backup_finish_date) AS int))%60 AS varchar)+ ' seconds'
  AS [Total Time]
FROM msdb.dbo.backupset bup
WHERE bup.backup_set_id IN
  (SELECT MAX(backup_set_id) 
   FROM msdb.dbo.backupset
   WHERE database_name = ISNULL(@dbname, database_name) --if no dbname, then return all
   AND type = 'D' --only interested in the time of last full backup
   GROUP BY database_name) 
/* COMMENT THE NEXT LINE IF YOU WANT ALL BACKUP HISTORY */
AND bup.database_name IN (SELECT name FROM master.dbo.sysdatabases)
ORDER BY bup.database_name


--Consulta Sesiones Activas
set pages 9999;
set linesize 1000;
select sid,SERIAL#, username, machine ,program,module, round (last_call_et/60,2) minutos, action, sql_id,event,PROCESS
from v$session a
where status='ACTIVE'
and username is not null
order by last_call_et desc;

--Consulta para sacar la sentencia dependiendo del SQL_ID
select SQL_TEXT from V$SQLAREA where SQL_ID='&sqlid';

putty resize
shopt -s checkwinsize

-- Oracle Cantidad de sesiones con el SQL TEXT
select count(8), a.sql_id, b.sql_text
from v$session a, V$SQLAREA  b
where username is not null
and a.SQL_ID = b.SQL_ID
group by a.sql_id, b.sql_text

create user SLL80822 identified by "Panama12!"
grant SELECT_UNICORN_TABLES to SLL80822
ALTER USER SLL80822 default tablespace USERS;
ALTER USER SLL80822 QUOTA 100M ON USERS;
ALTER USER SLL80822 account unlock;  -- Para desbloquear usuario
alter user avv700089  account unlock;
ALTER USER taa07191 IDENTIFIED BY bHGf1_NSaJ account unlock PASSWORD EXPIRE;

alter user system identified by "h1ck#bad"


alter user nagios identified by "nagios"
                      
grant advisor to hr;
grant administer sql tuning set to hr;
ALTER USER dgg80769  account unlock identified by "Bienvenido_01";
----------------
CREATE USER NTT700087
  IDENTIFIED BY VALUES 'Panama2013'
  DEFAULT TABLESPACE USERS
  TEMPORARY TABLESPACE TEMP
  PROFILE PROFILE_DESA
  ACCOUNT UNLOCK;
  GRANT CONNECT TO NTT700087;
  GRANT SELECT_UNICORN_TABLES TO NTT700087;
  ALTER USER NTT700087 QUOTA 100M ON USERS;
  GRANT SELECT ON UNICORN.V_CC0026_REPORTE TO NTT700087;
  
  ALTER PROFILE DEFAULT LIMIT PASSWORD_LIFE_TIME UNLIMITED;
  
  ---------------------------------------
  
  CREATE USER GGG91060 
  IDENTIFIED BY "=VnRk3ijoG"
  DEFAULT TABLESPACE USERS
  TEMPORARY TABLESPACE TEMP
  PROFILE PROFILE_PROD
  ACCOUNT UNLOCK;


GRANT SELECT_UNICORN_TABLES TO GGG91060 ;
ALTER USER GGG91060  DEFAULT ROLE ALL;
GRANT CREATE TABLE TO GGG91060 ;
GRANT UNLIMITED TABLESPACE TO GGG91060 ;
ALTER USER GGG91060  QUOTA UNLIMITED ON USERS;
  ---------------------------------------
  
                                                   
select PARTITION_NAME, SUM((BYTES/1024)/1024) 
from dba_segments 
where tablespace_name = 'PROV_CWPSST760_SLE' 
GROUP BY PARTITION_NAME 
ORDER BY 2 DESC

ALTER USER DGG80769 IDENTIFIED BY Panama2014 PASSWORD EXPIRE;

--username=nagiosopcss --password="wsgQ3chM" --database

•• Consulta Oracle SQL sobre la vista que muestra el estado de la base de datos

select * from v$instance

•• Consulta Oracle SQL que muestra si la base de datos está abierta

select status from v$instance

•• Consulta Oracle SQL sobre la vista que muestra los parámetros generales de Oracle

select * from v$system_parameter

•• Consulta Oracle SQL para conocer la Versión de Oracle

select value from v$system_parameter where name = 'compatible'

•• Consulta Oracle SQL para conocer la Ubicación y nombre del fichero spfile

select value from v$system_parameter where name = 'spfile'

•• Consulta Oracle SQL para conocer la Ubicación y número de ficheros de control

select value from v$system_parameter where name = 'control_files'

•• Consulta Oracle SQL para conocer el Nombre de la base de datos

select value from v$system_parameter where name = 'db_name'

•• Consulta Oracle SQL sobre la vista que muestra las conexiones actuales a Oracle 
   Para visualizarla es necesario entrar con privilegios de administrador

select osuser, username, machine, program
from v$session
order by osuser

•• Consulta Oracle SQL que muestra el número de conexiones actuales a Oracle 
   agrupado por aplicación que realiza la conexión

select program Aplicacion, count(program) Numero_Sesiones
from v$session
group by program
order by Numero_Sesiones desc

•• Consulta Oracle SQL que muestra los usuarios de Oracle conectados y el número de sesiones por usuario

select username Usuario_Oracle, count(username) Numero_Sesiones
from v$session
group by username
order by Numero_Sesiones desc

•• Consulta Oracle SQL que muestra propietarios de objetos y número de objetos por propietario

select owner, count(owner) Numero
from dba_objects
group by owner

•• Consulta Oracle SQL sobre el Diccionario de datos 
   (incluye todas las vistas y tablas de la Base de Datos)

select * from dictionary

•• Consulta Oracle SQL que muestra los datos de una tabla especificada
   (en este caso todas las tablas que lleven la cadena "XXX")

select * from ALL_ALL_TABLES where upper(table_name) like '%XXX%'

•• Para saber el propietario de una tabla: 
select owner from dba_tables where table_name='<nombre tabla>'
 
•• Para saber quien tiene permiso y de que tipo sobre la tabla 
select grantee,privilege from dba_tab_privs where table_name in ('<nombre_tabla>','ANY'); 


•• Consulta Oracle SQL que muestra las descripciones de los campos de una tabla especificada 
   (en este caso todas las tablas que lleven la cadena "XXX")

select * from ALL_COL_COMMENTS where upper(table_name) like '%XXX%'

  
 •• Consulta Oracle SQL para conocer las tablas propiedad del usuario actual
select * from user_tables

•• Consulta Oracle SQL para conocer todos los objetos propiedad del usuario conectado a Oracle

select * from user_catalog


•• Consulta Oracle SQL para conocer todos los datafiles dentro de un Tablespace -- Ejemplo UNDOTBS

set line 120
col file# for 9999
col name for a80
col staus for a10
select file#, name, status from v$datafile where TS# in (select TS# from v$tablespace where NAME = 'TOOLS')
                                                                                                              

•• Consulta Oracle SQL para el DBA de Oracle que muestra los tablespaces, 
   el espacio utilizado, el espacio libre y los ficheros de datos de los mismos
   
Select t.tablespace_name "Tablespace", t.status "Estado",
ROUND(MAX(d.bytes)/1024/1024,2) "MB Tamano",
ROUND((MAX(d.bytes)/1024/1024) -
(SUM(decode(f.bytes, NULL,0, f.bytes))/1024/1024),2) "MB Usados",
ROUND(SUM(decode(f.bytes, NULL,0, f.bytes))/1024/1024,2) "MB Libres",
t.pct_increase "% incremento",
SUBSTR(d.file_name,1,80) "Fichero de datos"
FROM DBA_FREE_SPACE f, DBA_DATA_FILES d, DBA_TABLESPACES t
WHERE t.tablespace_name = d.tablespace_name AND
f.tablespace_name(+) = d.tablespace_name
AND f.file_id(+) = d.file_id GROUP BY t.tablespace_name,
d.file_name, t.pct_increase, t.status ORDER BY 1,3 DESC;


** consultar el tamaño de los datafiles  luego de colocar la ruta  o ubicacion
*
Select t.tablespace_name "Tablespace", t.status "Estado",
ROUND(MAX(d.bytes)/1024/1024,2) "MB Tamano",
ROUND((MAX(d.bytes)/1024/1024) -
(SUM(decode(f.bytes, NULL,0, f.bytes))/1024/1024),2) "MB Usados",
ROUND(SUM(decode(f.bytes, NULL,0, f.bytes))/1024/1024,2) "MB Libres",
t.pct_increase "% incremento",
SUBSTR(d.file_name,1,80) "Fichero de datos"
FROM DBA_FREE_SPACE f, DBA_DATA_FILES d, DBA_TABLESPACES t
WHERE t.tablespace_name = d.tablespace_name 
AND f.tablespace_name(+) = d.tablespace_name
AND f.file_id(+) = d.file_id
AND SUBSTR(d.file_name,1,80) like '/etl/%' 
GROUP BY t.tablespace_name,d.file_name, t.pct_increase, t.status 
ORDER BY 1,7 ASC;

•• tamaño de todos los Tablespaces
select b.tablespace_name, tbs_size SizeMb, a.free_space FreeMb
from 
(select tablespace_name, round(sum(bytes)/1024/1024 ,2) as free_space 
from dba_free_space group by tablespace_name) a, 
(select tablespace_name, sum(bytes)/1024/1024 as tbs_size 
from dba_data_files group by tablespace_name
UNION
select tablespace_name, sum(bytes)/1024/1024 tbs_size
from dba_temp_files
group by tablespace_name ) b
where a.tablespace_name(+)=b.tablespace_name;


--1.	Listado de Tablespaces, cantidad de datafiles y tamaño total.  Ordenado por Tamaño total.
select substr(tablespace_name,1,40) as Tablespace_Name,
count(substr(file_name,1,40)) as cantidad_File_Name,
round(sum(bytes/1024/1024),2) as Size_Mb
from dba_data_files
group by substr(tablespace_name,1,40) 
order by Size_Mb desc;


--2.	Listado de Datafiles, Tablespace al que pertenece y el tamaño.  Ordenado por Tablespace.
select (substr(file_name,1,40)) as File_Name,
substr(tablespace_name,1,10) as Tablespace_Name,
round(sum(bytes/1024/1024),2) as Size_Mb
from dba_data_files
group by (substr(file_name,1,40)),substr(tablespace_name,1,10) 
order by 2 ;

•• tamaño de un tablespace
SELECT
  df.tablespace_name "Tablespace",
  df.bytes / (1024*1024*1024) "Size(GB)",
  SUM(fs.bytes) / (1024*1024*1024) "Free(GB)",
  NVL(ROUND(SUM(fs.bytes) * 100 / df.bytes),1) "%Free",
  ROUND((df.bytes         - SUM(fs.bytes)) * 100 / df.bytes) "%Used"
FROM dba_free_space fs,
  (SELECT tablespace_name,
    SUM(bytes) bytes
  FROM dba_data_files
  WHERE tablespace_name  like 'TBS_BASE%'
  GROUP BY tablespace_name
  ) df
WHERE fs.tablespace_name (+) = df.tablespace_name 
GROUP BY df.tablespace_name, df.bytes
order by 3 desc

•• Objetos dentro de un Tablespace
SELECT owner as "PROPIETARIO", segment_name as "NOMBRE", partition_name as "PARTICION", segment_type as "TIPO" , bytes/1024/1024/1024 as "Tamaño GB"  
FROM dba_segments WHERE TABLESPACE_NAME='TBS_BASE' ORDER BY bytes DESC;

tamaño de todos los objetos de un usuario.
select owner, segment_type, sum( bytes/1024/1024/1024 )
FROM dba_segments 
WHERE TABLESPACE_NAME in ('ICT_CENTRAL_DATA','ICT_CENTRAL_INDEX','ICT_DEFAULT_DATA') 
and owner= 'ICTPRDCEN' 
group by owner, segment_type
ORDER BY bytes DESC;


•• Tamaño tablas de un usuario 
SELECT SEGMENT_NAME, SEGMENT_TYPE, SUM(BYTES)/1024/1024/1024, SUM(bytes) /1073741824
FROM DBA_SEGMENTS
WHERE OWNER='LTERTIO76'
and SEGMENT_NAME like '%_BKP'
GROUP BY SEGMENT_NAME, SEGMENT_TYPE
ORDER BY 3 desc, 2,1;

--saber el tamaño de una partición
SELECT owner as "PROPIETARIO", segment_name as "NOMBRE", partition_name as "PARTICION", segment_type as "TIPO" , bytes/1024/1024/1024 as "Tamaño GB"  
FROM dba_segments 
WHERE TABLESPACE_NAME='TBS_BASE' 
and owner = 'OCDM_SYS'   --reemplazar
and segment_name='DWB_RAW_WRLS_CALL_EVT'--reemplazar
and partition_name ='P_RAW_WRLS_20181231'  --reemplazar
ORDER BY bytes DESC;



•• Database edition installed:
select banner from v$version where BANNER like '%Edition%';

•• Oracle Partitioning Used:
select decode(count(*), 0, 'No', 'Yes') Partitioning
from ( select 1 
       from dba_part_tables
       where owner not in ('SYSMAN', 'SH', 'SYS', 'SYSTEM')
         and rownum = 1 );

•• Oracle Spatial Used:
select decode(count(*), 0, 'No', 'Yes') Spatial
from ( select 1
       from all_sdo_geom_metadata 
       where rownum = 1 );
       
•• Oracle RAC Used:
select decode(count(*), 0, 'No', 'Yes') RAC
from ( select 1 
       from v$active_instances 
       where rownum = 1 );
       
••  Active Data Guard Used:
select 'Using Active Data Guard' ADG
from v$managed_standby m, v$database d
where m.process like 'MRP%';       


••  Features used/not used: (from 10g)
Set feedback off
Set linesize 122
Col name             format a45     heading "Feature"
Col version          format a10     heading "Version"
Col detected_usages  format 999,990 heading "Detected|usages"
Col currently_used   format a06     heading "Curr.|used?"
Col first_usage_date format a10     heading "First use"
Col last_usage_date  format a10     heading "Last use"
Col nop noprint
Break on nop skip 1 on name
Select decode(detected_usages,0,2,1) nop,
       name, version, detected_usages, currently_used,
       to_char(first_usage_date,'DD/MM/YYYY') first_usage_date, 
       to_char(last_usage_date,'DD/MM/YYYY') last_usage_date
from dba_feature_usage_statistics
order by nop, 1, 2
/
•• Consulta Oracle SQL para conocer los productos Oracle instalados y la versión

select * from product_component_version

•• Consulta Oracle SQL para conocer los roles asignados a los usuarios
SELECT GRANTEE, GRANTED_ROLE 
FROM dba_ROLE_PRIVS
order by grantee;

•• Consulta Oracle SQL para conocer los roles y privilegios por roles

select * from role_sys_privs

•• Consulta Oracle SQL para conocer las reglas de integridad y columna a la que afectan

select constraint_name, column_name from sys.all_cons_columns

•• Consulta Oracle SQL para conocer las tablas de las que es propietario un usuario, en este caso "xxx"

SELECT table_owner, table_name from sys.all_synonyms where table_owner like 'xxx'

•• Consulta Oracle SQL como la anterior, pero de otra forma más efectiva 
   (tablas de las que es propietario un usuario)

SELECT DISTINCT TABLE_NAME FROM ALL_ALL_TABLES WHERE upper(OWNER) LIKE '%REP%'

•• Parámetros de Oracle, valor actual y su descripción

SELECT v.name, v.value value, decode(ISSYS_MODIFIABLE, 'DEFERRED',
'TRUE', 'FALSE') ISSYS_MODIFIABLE, decode(v.isDefault, 'TRUE', 'YES',
'FALSE', 'NO') "DEFAULT", DECODE(ISSES_MODIFIABLE, 'IMMEDIATE',
'YES','FALSE', 'NO', 'DEFERRED', 'NO', 'YES') SES_MODIFIABLE,
DECODE(ISSYS_MODIFIABLE, 'IMMEDIATE', 'YES', 'FALSE', 'NO',
'DEFERRED', 'YES','YES') SYS_MODIFIABLE , v.description
FROM V$PARAMETER v
WHERE name not like 'nls%' ORDER BY 1

•• Consulta Oracle SQL que muestra los usuarios de Oracle y datos suyos 
   (fecha de creación, estado, id, nombre, tablespace temporal,...)

Select * FROM dba_users

•• Consulta Oracle SQL para conocer tablespaces y propietarios de los mismos

select owner, decode(partition_name, null, segment_name,
segment_name || ':' || partition_name) name,
segment_type, tablespace_name,bytes,initial_extent,
next_extent, PCT_INCREASE, extents, max_extents
from dba_segments
Where 1=1 And extents > 1 order by 9 desc, 3

••  Obtener las tablas de un tablespace y su tamaño
select SEGMENT_NAME, BYTES/1024/1024
from dba_segments 
where TABLESPACE_NAME = 'nombre_de_tablespace' AND segment_type='TABLE'
ORDER BY SEGMENT_NAME;

--Ejemplo
select SEGMENT_NAME, sum(BYTES/1024/1024/1024)
from dba_segments
where TABLESPACE_NAME = 'TBS_REFERENCE' 
AND segment_type in ('TABLE', 'TABLE PARTITION')
and segment_name in ('DWB_CNRT_INVC_MO','DWB_INVC_ADJ_MO','DWB_INVC_ITEM','DWB_MWALLET_CWP','DWB_TOPUP_DATA_CWP')
group by SEGMENT_NAME
ORDER BY SEGMENT_NAME;

--Tamaño de una tabla en un TS
SELECT owner, segment_name, segment_type, partition_name, ROUND(bytes/(1024*1024*1024),2) SIZE_GB, tablespace_name 
FROM DBA_SEGMENTS 
WHERE SEGMENT_TYPE IN ('TABLE', 'TABLE PARTITION', 'TABLE SUBPARTITION', 'INDEX', 'INDEX PARTITION', 'INDEX SUBPARTITION', 'TEMPORARY', 'LOBINDEX', 'LOBSEGMENT', 'LOB PARTITION')
AND TABLESPACE_NAME in ('TBS_BASE%','STBS_BASE') 
--AND SEGMENT_NAME LIKE 'P2010201%' 
--AND partition_name LIKE 'P20100201%'
--AND segment_type = 'TABLE'
--AND OWNER = 'TARGET_POC' 
AND ROUND(bytes/(1024*1024),2) > 1000 
ORDER BY bytes DESC;


•• Últimas consultas SQL ejecutadas en Oracle y usuario que las ejecutó

select distinct vs.sql_text, vs.sharable_mem,
vs.persistent_mem, vs.runtime_mem, vs.sorts,
vs.executions, vs.parse_calls, vs.module,
vs.buffer_gets, vs.disk_reads, vs.version_count,
vs.users_opening, vs.loads,
to_char(to_date(vs.first_load_time,
'YYYY-MM-DD/HH24:MI:SS'),'MM/DD HH24:MI:SS') first_load_time,
rawtohex(vs.address) address, vs.hash_value hash_value ,
rows_processed , vs.command_type, vs.parsing_user_id ,
OPTIMIZER_MODE , au.USERNAME parseuser
from v$sqlarea vs , all_users au
where (parsing_user_id != 0) AND
(au.user_id(+)=vs.parsing_user_id)
and (executions >= 1) order by buffer_gets/executions desc

•• Consulta Oracle SQL para conocer todos los tablespaces

select * from V$TABLESPACE•• Consulta Oracle SQL para conocer la memoria Share_Pool libre y usada

select name,to_number(value) bytes
from v$parameter where name ='shared_pool_size'
union all
select name,bytes
from v$sgastat where pool = 'shared pool' and name = 'free memory'

•• Here is a query getting hourly  sga/pga memory usages of an Oracle instance. - flush shared pool


select sn.INSTANCE_NUMBER, sga.allo sga, pga.allo pga,(sga.allo+pga.allo) tot,
trunc(SN.END_INTERVAL_TIME,'mi') time
  from
(select snap_id,INSTANCE_NUMBER,round(sum(bytes)/1024/1024/1024,3) allo 
   from DBA_HIST_SGASTAT 
  group by snap_id,INSTANCE_NUMBER) sga
,(select snap_id,INSTANCE_NUMBER,round(sum(value)/1024/1024/1024,3) allo 
    from DBA_HIST_PGASTAT where name = 'total PGA allocated' 
   group by snap_id,INSTANCE_NUMBER) pga
, dba_hist_snapshot sn 
where sn.snap_id=sga.snap_id
  and sn.INSTANCE_NUMBER=sga.INSTANCE_NUMBER
  and sn.snap_id=pga.snap_id
  and sn.INSTANCE_NUMBER=pga.INSTANCE_NUMBER
order by sn.snap_id desc, sn.INSTANCE_NUMBER
;
 

•• Cursores abiertos por usuario

select b.sid, a.username, b.value Cursores_Abiertos
from v$session a,
v$sesstat b,
v$statname c
where c.name in ('opened cursors current')
and b.statistic# = c.statistic#
and a.sid = b.sid
and a.username is not null
and b.value >0
order by 3

•• Consulta Oracle SQL para conocer los aciertos de la caché (no debería superar el 1 por ciento)

select sum(pins) Ejecuciones, sum(reloads) Fallos_cache,
trunc(sum(reloads)/sum(pins)*100,2) Porcentaje_aciertos
from v$librarycache
where namespace in ('TABLE/PROCEDURE','SQL AREA','BODY','TRIGGER');

•• Sentencias SQL completas ejecutadas con un texto determinado en el SQL

SELECT c.sid, d.piece, c.serial#, c.username, d.sql_text
FROM v$session c, v$sqltext d
WHERE c.sql_hash_value = d.hash_value
and upper(d.sql_text) like '%WHERE CAMPO LIKE%'
ORDER BY c.sid, d.piece

•• Una sentencia SQL concreta (filtrado por sid)

SELECT c.sid, d.piece, c.serial#, c.username, d.sql_text
FROM v$session c, v$sqltext d
WHERE c.sql_hash_value = d.hash_value
and sid = 105
ORDER BY c.sid, d.piece

•• Consulta Oracle SQL para conocer el tamano ocupado por la base de datos

select sum(BYTES)/1024/1024 MB from DBA_EXTENTS

•• Consulta Oracle SQL para conocer el tamano de los ficheros de datos de la base de datos

select sum(bytes)/1024/1024 MB from dba_data_files

•• Consulta Oracle SQL para conocer el tamano ocupado por una tabla concreta sin incluir los índices de la misma

select sum(bytes)/1024/1024 MB from user_segments
where segment_type='TABLE' and segment_name='NOMBRETABLA'

•• Consulta Oracle SQL para conocer el tamano ocupado por una tabla concreta incluyendo los índices de la misma

select sum(bytes)/1024/1024 Table_Allocation_MB from user_segments
where segment_type in ('TABLE','INDEX') and
(segment_name='NOMBRETABLA' or segment_name in
(select index_name from user_indexes where table_name='NOMBRETABLA'))

•• Consulta Oracle SQL para conocer el tamano ocupado por una columna de una tabla

select sum(vsize('NOMBRECOLUMNA'))/1024/1024 MB from NOMBRETABLA

•• Consulta Oracle SQL para conocer el espacio ocupado por usuario

SELECT owner, SUM(BYTES)/1024/1024 MB FROM DBA_EXTENTS
group by owner

•• Consulta Oracle SQL para conocer el espacio ocupado por los diferentes segmentos 
   (tablas, índices, undo, rollback, cluster, ...)

SELECT SEGMENT_TYPE, SUM(BYTES)/1024/1024 MB FROM DBA_EXTENTS
group by SEGMENT_TYPE

•• Consulta Oracle SQL para obtener todas las funciones de Oracle: NVL, ABS, LTRIM, ...

SELECT distinct object_name
FROM all_arguments
WHERE package_name = 'STANDARD'
order by object_name

•• Consulta Oracle SQL para conocer el espacio ocupado por todos los objetos de la base de datos, 
   muestra los objetos que más ocupan primero

SELECT SEGMENT_NAME, SUM(BYTES)/1024/1024 MB FROM DBA_EXTENTS
group by SEGMENT_NAME
order by 2 desc

•• Para comparar dentro de un DECODE con parte de un texto del contenido de un campo, es decir, 
para poder utilizar un like u otras funciones en lugar de la igualdad que toma por defecto el DECODE
 se puede hacer lo siguiente:
 
SELECT DECODE(CAMPO, 
              (select CAMPO from dual where CAMPO like 'A%'), 
              'Campo comienza por A', 
              (select name from dual where name like 'B%'), 
              'Campo comienza por B', 
              'Campo no comienza ni por A ni por B') 
FROM TABLA;

•• Cuando un tablespace se queda sin espacio se puede ampliar creando un nuevo fichero de datos, 
o ampliando uno de los existentes.

select * from dba_tablespaces where tablespace_name = 'ICT_REPORTS_INDEX'

select * from dba_data_files where tablespace_name = 'ICT_REPORTS_INDEX';

- consulta el MAXEXTENTS vs el EXTENT de cada segmento
SELECT SUBSTR(owner||'.'||segment_name,1,50) OBJECT,       EXTENTS, MAX_EXTENTS
FROM DBA_SEGMENTS
WHERE MAX_EXTENTS - EXTENTS between 50 and 10000
ORDER BY EXTENTS desc;
 
Para consultar el espacio ocupado por cada datafile se puede utilizar la consulta de la lista anterior:
 
 Consulta Oracle SQL para el DBA de Oracle que muestra los tablespaces, el espacio utilizado, 
 el espacio libre y los ficheros de datos de los mismos:
 SELECT t.tablespace_name "Tablespace", t.status "Estado",
 ROUND(MAX(d.bytes)/1024/1024,2) "MB Tamano",
 ROUND((MAX(d.bytes)/1024/1024) -
 (SUM(decode(f.bytes, NULL,0, f.bytes))/1024/1024),2) "MB Usados",
 ROUND(SUM(decode(f.bytes, NULL,0, f.bytes))/1024/1024,2) "MB Libres",
 t.pct_increase "% incremento",
 SUBSTR(d.file_name,1,80) "Fichero de datos"
 FROM DBA_FREE_SPACE f, DBA_DATA_FILES d, DBA_TABLESPACES t
 WHERE t.tablespace_name = d.tablespace_name AND
 f.tablespace_name(+) = d.tablespace_name
 AND f.file_id(+) = d.file_id GROUP BY t.tablespace_name,
 d.file_name, t.pct_increase, t.status ORDER BY 1,3 DESC
 
--consulta el tamaño de los datafiles por porcentaje de uso y por nombre, ordenados descendentemente por  %USO
SELECT t.tablespace_name "Tablespace",
 t.status "Estado",
 ROUND(MAX(d.bytes)/1024/1024,2) "MB Tamano",
 ROUND((MAX(d.bytes)/1024/1024) - (SUM(decode(f.bytes, NULL,0, f.bytes))/1024/1024),2) "MB Usados",
 ROUND(SUM(decode(f.bytes, NULL,0, f.bytes))/1024/1024,2) "MB Libres",
 ROUND(((ROUND((MAX(d.bytes)/1024/1024) - (SUM(decode(f.bytes, NULL,0, f.bytes))/1024/1024),2)) / (ROUND(MAX(d.bytes)/1024/1024,2)))*100,2) "% USO",
 SUBSTR(d.file_name,1,80) "Fichero de datos"
 FROM DBA_FREE_SPACE f, DBA_DATA_FILES d, DBA_TABLESPACES t
 WHERE t.tablespace_name = d.tablespace_name 
 AND f.tablespace_name(+) = d.tablespace_name
 AND f.file_id(+) = d.file_id 
 GROUP BY t.tablespace_name,d.file_name,t.status
 ORDER BY 6 DESC; 
 
Una vez que localizamos el datafile que podríamos ampliar ejecutaremos la siguiente sentencia para hacerlo:
 
ALTER DATABASE
 DATAFILE '/db/oradata/datafiles/datafile_n.dbf' AUTOEXTEND
 ON NEXT 1M MAXSIZE 4000M
 
Con esta sentencia, el datafile continuaría ampliándose hasta llegar a un máximo de 4Gb.
 
Si preferimos crear un nuevo datafile porque los que tenemos ya son demasido grandes, 
una sentencia que podríamos utilizar es la siguiente:
 
ALTER TABLESPACE "MiTablespace"
 ADD
 DATAFILE '/db/oradata/datafiles/datafile_m.dbf' SIZE
 100M AUTOEXTEND
 ON NEXT 1M MAXSIZE 1000M
 
Crearíamos un nuevo fichero de datos de 100 Mb, y en modo autoextensible hasta 1000 Mb. 
Por supuesto, el path especificado debe ser el específico de cada base de datos, y se debe utilizar para 
todo el proceso un usuario con privilegios de DBA.
--------------------------------------------------------------------------------------------------------
Para matar una sesión de Oracle hay que utilizar, con un usuario con permisos de DBA, el comando
 
ALTER SYSTEM KILL SESSION 'SID,SERIAL#';
 
Para obtener el SID y el SERIAL# que necesitamos se puede utilizar la consulta:
                             Bb?5mlaw5  Bb?5mlaw5
                             Itunes05
SELECT p.*, s.*
 FROM v$session s, v$process p
 WHERE p.addr(+)=s.paddr
 ORDER BY SID;
 
Esta consulta devolvería los datos de todas las sesiones abiertas, se pueden restringir los resultados a las sesiones que interesen anadiendo condiciones en el where.
 
Si el número de sesiones que hay que eliminar es elevado, se puede utilizar esta misma consulta para crear las sentencias necesarias dinámicamente:
 
SELECT 'alter system kill session '''||s.sid||','||s.serial#||''';'
 FROM v$session s, v$process p
 WHERE p.addr(+)=s.paddr
 AND s.username='USER'; (por ejemplo)
 
Sobretodo cuidado con la condición que se incluye en el where, ya que si no se especificara nada, por ejemplo, se matarían todas las sesiones de la base de datos.

--------------------------------------------------------------------------------------------------------
•• identificador del cliente
  SELECT sys_context('USERENV', 'CLIENT_IDENTIFIER') FROM dual;

•• nombre del esquema donde uno esta conectado
     SELECT sys_context('userenv', 'CURRENT_SCHEMA') FROM dual;

•• ID del esquema donde uno se encuentra conectado
     SELECT sys_context('USERENV', 'CURRENT_SCHEMAID') FROM dual;

•• nombre de la base de datos.
     SELECT sys_context('USERENV', 'DB_NAME') FROM dual;

•• nombre del host
     SELECT sys_context('USERENV', 'HOST') FROM dual;

•• nombre de la instancia
     SELECT sys_context('USERENV', 'INSTANCE_NAME') FROM dual;

••los formatos de moneda, fechas.
    SELECT sys_context('USERENV', 'NLS_CURRENCY') FROM dual;   SELECT sys_context('USERENV', 'NLS_DATE_FORMAT') FROM dual;

•• nombre del territorio. ejemplo : 'AMERICA';
    SELECT sys_context('USERENV', 'NLS_TERRITORY') FROM dual;

•• server host nome
     SELECT sys_context('USERENV', 'SERVER_HOST') FROM dual;

•• ID de la session del usuario
     SELECT sys_context('USERENV', 'SESSION_USERID') FROM dual;

•• SID (session number) util para matar sesiones luego con el numero.
     SELECT sys_context('USERENV', 'SID') FROM dual;



##TODO LO DE ARRIBA AGRUPADO
SELECT
sys_context('USERENV', 'CLIENT_IDENTIFIER') as "CLIENT_IDENTIFIER",
sys_context('USERENV','SESSION_USER') as "USER NAME",
sys_context('USERENV', 'CURRENT_SCHEMA') as "CURRENT SCHEMA",
sys_context('USERENV', 'CURRENT_SCHEMAID')  as "CURRENT_SCHEMAID",
sys_context('USERENV', 'DB_NAME') as "DB NAME",
sys_context('USERENV', 'HOST') as "HOST",
sys_context('USERENV', 'INSTANCE_NAME') as "INSTANCE NAME",
sys_context('USERENV', 'NLS_CURRENCY') as "NLS_CURRENCY",
sys_context('USERENV', 'NLS_DATE_FORMAT') as "NLS_DATE_FORMAT",
sys_context('USERENV', 'NLS_CURRENCY') as  "NLS_CURRENCY",
sys_context('USERENV', 'NLS_TERRITORY')  as  "NLS_TERRITORY",
sys_context('USERENV', 'SERVER_HOST') as  "SERVER_HOST",
sys_context('USERENV', 'SESSION_USERID') as   "SESSION_USERID" 
FROM dual;

•• Character SET
    SELECT * FROM NLS_DATABASE_PARAMETERS

•• LISTA DE PAQUETES UTL (utilidades de oracle, envio de mails mediante SMTP entre otros)

     SELECT * FROM ALL_OBJECTS
     WHERE OBJECT_NAME LIKE '%UTL_%'
         AND OBJECT_TYPE = 'PACKAGE'

•• LISTA DE PAQUETES DBMS (otras utilidades del Data Base Manager System)

     SELECT * FROM ALL_OBJECTS
      WHERE OBJECT_NAME LIKE '%DBMS_%'
          AND OBJECT_TYPE = 'PACKAGE'
 estas dos listas digamos son utiles como para ver las que hay y luego investigar un poco mas como se utilizan en internet.
 
•• Envio de e-mail a multiples usuarios mediante la utilidad UTL_SMTP.
 
Otra cosa que me costo mucho encontrar y en definitiva me lo termino contando un amigo del trabajo es como utilizar el paquete UTL_SMPT para mandar un mail a multiples recipientes. (a varias personas)
 
Mi idea es unicamente explicar este problema, como usarlo se los dejo para que lo investiguen que no es muy dificil.
 
si se tiene los mails en un VARCHAR de la siguiente manera
 
alguien@xxx.com;alguien1@xxx.com;alguien2@xxx.com;alguien3@xxx.com;alguien4@xxx.com
 
una vez hecho los pasos :
    g_mail_conn := utl_smtp.open_connection (p_mailhost,p_mailport);   -- <-- apertura de conexion.
   utl_smtp.helo(g_mail_conn,p_mailhost);
   utl_smtp.mail(g_mail_conn,p_sender);
hay que definir el recipiente con la funcion utl_smtp.rcpt(); tener en cuenta que este recipiente se va a instanciar en nuestro caso 5 veces (una vez por cada e-mail y no todos en uno solo OJO!)
 osea : utl_smtp.rcpt( p_mail_conn , alguien@xxx.com );
          utl_smtp.rcpt( p_mail_conn , alguien@xxx.com1 );
          utl_smtp.rcpt( p_mail_conn , alguien@xxx.com 2);
          utl_smtp.rcpt( p_mail_conn , alguien@xxx.com 3);
          utl_smtp.rcpt( p_mail_conn , alguien@xxx.com4 );
para cortar los mails concatenados en un VARCHAR y cumplir el proposito anterior pueden usar este procesos que me toco hacer que hace lo anteriormente descrito.
 PROCEDURE Pi_Prepare_Recip_Mail ( p_mail_conn IN OUT utl_smtp.connection,
                                                      p_rec_mails IN VARCHAR2)
  IS 
       MAILS      VARCHAR2(1000)  := p_rec_mails;
       SingleMail VARCHAR2(255);
       --
       NO_MORE_MAILS BOOLEAN := FALSE;
       EOM           NUMBER;          -- end of mail.
       BOM           NUMBER := 1;     -- begin of mail.
       COC           NUMBER ;         -- number of characters.
       MAIL_NUMBER   NUMBER := 1;       
 BEGIN        
       LOOP
           EOM := INSTR(MAILS,';',1,MAIL_NUMBER);   
           IF EOM = 0 THEN   
               EOM := LENGTH(MAILS) + 1;
               NO_MORE_MAILS := TRUE;
           END IF;
           COC := (EOM) - BOM;
           SingleMail := SUBSTR(MAILS,BOM,COC);
           utl_smtp.rcpt( p_mail_conn , SingleMail );   -- <-- recipiente de salida.        
           EXIT WHEN NO_MORE_MAILS;
           MAIL_NUMBER := MAIL_NUMBER + 1 ;
           BOM := EOM + 1;
         END LOOP;
 END Pi_Prepare_Recip_Mail;
se instancia este procesos pasandole la conexion de mail y la lista de mails osea:
 
p_rec_mail VARCHAR2(300) := alguien@xxx.com;alguien1@xxx.com;alguien2@xxx.com;alguien3@xxx.com;alguien4@xxx.com;
 
 instancia -->   Pi_Prepare_Recip_Mail( g_mail_conn , p_rec_mail );
 
En si es dificil de entender y mas de explicar, trate de ser lo mas claro posible. Cualquier duda sobre este tema escriban.
 •• cambiar el lenguaje de la fecha.
select to_char(sysdate,'day', 'NLS_DATE_LANGUAGE=Spanish') from dual
select to_char(sysdate,'month', 'NLS_DATE_LANGUAGE=Spanish') from dual

•• correr las estadisticas para una determinada tabla (esto aumenta la velocidad de respuesta de las tablas en 
   aquellos casos donde el volumen de registros es considerablemente grande)
     ANALIZE TABLE <nombre de la tabla> COMPUTE STATISTICS;
     -- realizarlo en un porcentaje (en un 25 %)
     ANALIZE TABLE <nombre de la tabla> COMPUTE STATISTICS SAMPLE 25 percent;
     -- realizarlo solo para una determinada cantidad de registros)
     ANALIZE TABLE <nombre de la tabla> COMPUTE STATISTICS SAMPLE 1000 rows;

•• ponerle comentarios a las tablas y a sus columnas para que el significado de cada campo tenga mayor
   comprencion.
     COMMENT ON TABLE <table_name> IS 'comentario a escribir';
     COMMENT ON COLUMN <table_name>.<column_name> IS 'comentario a escribir aca';
 
•• Verifying Table Statistics  - estadisticas

To verify that the table statistics are available, execute the following statement against DBA_TABLES:

SQL> SELECT TABLE_NAME, NUM_ROWS, BLOCKS, AVG_ROW_LEN,
       TO_CHAR(LAST_ANALYZED, 'MM/DD/YYYY HH24:MI:SS')
     FROM DBA_TABLES
     WHERE TABLE_NAME IN ('SO_LINES_ALL','SO_HEADERS_ALL');

This returns the following typical data:

TABLE_NAME                 NUM_ROWS   BLOCKS   AVH_ROW_LEN   LAST_ANALYZED
------------------------   --------   -------  -----------   -------------
SO_HEADERS_ALL             1632264    207014            449  07/29/1999 00:59:51
SO_LINES_ALL              10493845   1922196            663  07/29/1999 01:16:09
Verifying Index Statistics

To verify that index statistics are available and assist you in determining which are the best indexes to use in your application, execute the following statement against the dictionary DBA_INDEXES table:

SQL> SELECT INDEX_NAME "NAME", NUM_ROWS, DISTINCT_KEYS "DISTINCT",
            LEAF_BLOCKS, CLUSTERING_FACTOR "CF", 
            AVG_LEAF_BLOCKS_PER_KEY "ALFBPKEY"
     FROM DBA_INDEXES
     WHERE TABLE_NAME ="AP_INVOICES_ALL"
     ORDER BY INDEX_NAME;

This returns the following typical data:

NAME                     NUM_ROWS DISTINCT LEAF_BLOCKS       CF   ALFBKEY
---------------------- ---------- -------- -----------  -------   -------
AP_INVOICES_N1             18941     80712      17060    431230         1
AP_INVOICES_N3             14995         2      21403    186450     10701
AP_INVOICES_N4             13196    439859      18669   2889596         1
AP_INVOICES_N5              9734       291      24145   1543140        82
AP_INVOICES_N6             18816   1567987      22708   2579791         1
AP_INVOICES_N9              9216         3      23271    264048      7757
AP_INVOICES_U1             10892   2861077      17074    342793         1
AP_INVOICES_U2             17176   3084212      28910   2499547         1
     
--------------------------------------------------------------------------------------------------------

consulta de espacio disponible, ya habeís listado alguno, pero este me parece sencillo y de utilidad también: 
 SELECT
   SYSDATE AS FECHA_ACT, DEDICADO.TABLESPACE "TABLESPACE",
   ROUND (DEDICADO.ESPACIO, 2) "ESPACIO DEDICADO (GB)",
   ROUND (LIBRE.ESPACIO, 2) "ESPACIO LIBRE (GB)",
   ROUND (DEDICADO.ESPACIO - LIBRE.ESPACIO, 2) "ESPACIO USADO (GB)",
   LPAD (ROUND ((LIBRE.ESPACIO / DEDICADO.ESPACIO) * 100, 2) || '%', 6, ' ') "% ESPACIO LIBRE"
FROM
   (SELECT
       DDF.TABLESPACE_NAME "TABLESPACE",
       SUM (DDF.BYTES) / 1024 / 1024 / 1024 "ESPACIO"
    FROM
       DBA_DATA_FILES DDF
    WHERE
       DDF.TABLESPACE_NAME IN ('tablespace1', ' tablespace2')
    GROUP BY
       DDF.TABLESPACE_NAME) DEDICADO,
   (SELECT
       DFS.TABLESPACE_NAME "TABLESPACE",
       SUM (DFS.BYTES) / 1024 / 1024 / 1024 "ESPACIO"
    FROM
       DBA_FREE_SPACE DFS
    WHERE
       DFS.TABLESPACE_NAME IN ('tablespace1', ' tablespace2')
    GROUP BY
       DFS.TABLESPACE_NAME) LIBRE
WHERE
   DEDICADO.TABLESPACE = LIBRE.TABLESPACE
ORDER BY
   LIBRE.ESPACIO / DEDICADO.ESPACIO ASC
                      
--------------------------------------------------------------------------------------------------------
**TABLESPACE TAMAnO POR DATAFILE
select  a.segment_name,b.tablespace_name,sum( bytes)/1024/1024 
from dba_segments a, dba_tables b
where b.tablespace_name='TS_OTHERS_U1'
--and a.segment_name = 'RT_DHCPRESTRICTADDRESS'
and a.segment_name = b. table_name
group by a.segment_name,b.tablespace_name
order by 3 desc

-------------

How do I know if an object is partitioned or not?

A simple query against the data dictionary will show if a given table or index is partitioned or not:
SELECT * FROM dba_part_tables;
SELECT * FROM dba_part_indexes;

One can list the partitions of a table with:
SELECT * FROM dba_tab_partitions WHERE table_name = '<table_name>';

One can show the partitions of an given index with:
SELECT * FROM dba_ind_partitions WHERE index_name = '<index_name>';     

How does one see the uptime for a database?
Look at the following SQL query:
SELECT to_char(startup_time,'DD-MON-YYYY HH24:MI:SS') "DB Startup Time"
FROM   sys.v_$instance;

Can one resize tablespaces and data files?
Add more files to tablespaces
To add more space to a tablespace, one can simply add another file to it. Example:
ALTER TABLESPACE USERS ADD DATAFILE '/oradata/orcl/users1.dbf' SIZE 100M;


ALTER TABLESPACE UNDOTBS1 ADD DATAFILE '+DGFLASH' SIZE 100G;


Resize datafiles
One can manually increase or decrease the size of a datafile from Oracle 7.2 using the following command:
ALTER DATABASE DATAFILE 'filename2' RESIZE 100M;


************************************************************************************************
*************************************************************************************************
POSTGRES

DLO: 
/opt/pgsql-9.1.3/bin/psql
psql (9.1.3)
Type "help" for help.

postgres=# SELECT datname FROM pg_database
postgres-# WHERE datistemplate = false;
 datname
----------
 postgres
 dlo
(2 rows)
    *
    *

************************************************************************************************
*************************************************************************************************
CREAR PLAN TABLE PARA ORACLIE9I

create table NTT700087.PLAN_TABLE (
        statement_id    varchar2(30),
        timestamp       date,
        remarks         varchar2(80),
        operation       varchar2(30),
        options         varchar2(255),
        object_node     varchar2(128),
        object_owner    varchar2(30),
        object_name     varchar2(30),
        object_instance numeric,
        object_type     varchar2(30),
        optimizer       varchar2(255),
        search_columns  number,
        id              numeric,
        parent_id       numeric,
        position        numeric,
        cost            numeric,
        cardinality     numeric,
        bytes           numeric,
        other_tag       varchar2(255),
        partition_start varchar2(255),
        partition_stop  varchar2(255),
        partition_id    numeric,
        other           long,                
        distribution    varchar2(30),
        cpu_cost        numeric,
        io_cost         numeric,
        temp_space      numeric,
        access_predicates varchar2(4000),
        filter_predicates varchar2(4000));
        
        
        
        *************************************
        *
        *RMAN
        *
        *delete archivelog until logseq=22013;
         
         Ruta de restauraciónexit
                
        */export/home/zonas/z7_os_ubill_2/root/DBData
        
         list backupset of database completed after '06-feb-14';
         
         RMAN> list backupset;
RMAN> list backupset of database;
RMAN> list backupset of database completed before '22-NOV-00';
RMAN> list backupset of archivelog all;
RMAN> list backupset of tablespace users;
RMAN> list backupset of datafile 1;

RMAN> list backup summary;
RMAN> list backup;
RMAN> list backup of controlfile;
RMAN> list backup of tablespace SYSTEM;
RMAN> list backup by file;
RMAN> list backup of archivelog all ;

RMAN> list copy of database;
RMAN> list copy of database archivelog all;

RMAN> allocate channel for maintenance type disk;
RMAN> configure channel device type disk clear ;

RMAN> report need backup days=2 database;
RMAN> report need backup days=10 tablespace TEMP;
RMAN> report need backup days=4 datafile 'D:\ORACLE\ORADATA\OR816\TEMP01.DBF';
RMAN> report schema;
RMAN> report obsolete;

RMAN> crosscheck backup;
RMAN> crosscheck backupset;
RMAN> crosscheck copy;
RMAN> crosscheck archivelog all;
RMAN> crosscheck controlfilecopy '/ora01/oracle/admin/BACKUP/demo/demo_controlfile_bak_03-15-11_19:59:11' ;

RMAN> delete noprompt expired backup ;
RMAN> delete noprompt obsolete;
RMAN> delete archivelog all;
RMAN> delete expired archivelog all;
RMAN> delete archivelog all completed before 'sysdate -1';
RMAN> delete noprompt archivelog until time 'sysdate - 1';
RMAN> delete archivelog all backed up 1 times to device type disk completed before 'sysdate-1';

---------------------------------------------------

Instalación INTRAWAY

[root@cwp-jfr-ipsdb ~]# groupadd -g 200 dba
[root@cwp-jfr-ipsdb ~]# groupadd -g 201 oinstall

useradd -d /home/oracle -m -s /bin/ksh -c "Oracle" oracle 
luego passwd oracle y se le coloca la contrasena.
1ntraWy                       

UNIX Add Existing User To A Primary Group

[root@cwp-jfr-ipsdb home]# usermod -g dba oracle
[root@cwp-jfr-ipsdb home]# usermod -G oinstall oracle


ARC1: Completed archiving  log 3 thread 1 sequence 660167
Fri May  9 12:47:36 2014
ALTER SYSTEM SET shared_pool_size='5750390784' SCOPE=MEMORY;
Fri May  9 12:49:03 2014
ALTER SYSTEM SET shared_pool_size='5750390784' SCOPE=MEMORY;
Fri May  9 12:49:48 2014
ALTER SYSTEM SET large_pool_size='826277888' SCOPE=MEMORY;
Fri May  9 12:49:48 2014
ALTER SYSTEM SET shared_pool_size='5750390784' SCOPE=MEMORY;
Fri
------------------------------------------------------------------------------------------------
Subir RAC

Root:
$cd /u01/app/product/grid/11.2.0/bin
$./crsctl start cluster   ?  (Aquí sube el ASM y los servicios de cluster y listener)
(Verifica status de los servicios de cluster)


Oracle:
$srvctl start database -d iway -o open ? (Sube BD de iway, ambos nodos)

Root:
$./crsctl stat res –t      
--------------------------------------------------------------------------------
NAME           TARGET  STATE        SERVER                   STATE_DETAILS
--------------------------------------------------------------------------------
Local Resources
--------------------------------------------------------------------------------
ora.DATA.dg
               ONLINE  ONLINE       cwp-jfr-ipsdp1
               ONLINE  ONLINE       cwp-jfr-ipsdp2
ora.FRA.dg
               ONLINE  ONLINE       cwp-jfr-ipsdp1
               ONLINE  ONLINE       cwp-jfr-ipsdp2
ora.GRID.dg
               ONLINE  ONLINE       cwp-jfr-ipsdp1
               ONLINE  ONLINE       cwp-jfr-ipsdp2
ora.LISTENER.lsnr
               ONLINE  ONLINE       cwp-jfr-ipsdp1
               ONLINE  ONLINE       cwp-jfr-ipsdp2
ora.asm
               ONLINE  ONLINE       cwp-jfr-ipsdp1           Started
               ONLINE  ONLINE       cwp-jfr-ipsdp2           Started
ora.gsd
               OFFLINE OFFLINE      cwp-jfr-ipsdp1
               OFFLINE OFFLINE      cwp-jfr-ipsdp2
ora.net1.network
               ONLINE  ONLINE       cwp-jfr-ipsdp1
               ONLINE  ONLINE       cwp-jfr-ipsdp2
ora.ons
               ONLINE  ONLINE       cwp-jfr-ipsdp1
               ONLINE  ONLINE       cwp-jfr-ipsdp2
ora.registry.acfs
               ONLINE  ONLINE       cwp-jfr-ipsdp1
               ONLINE  ONLINE       cwp-jfr-ipsdp2
--------------------------------------------------------------------------------
Cluster Resources
--------------------------------------------------------------------------------
ora.LISTENER_SCAN1.lsnr
      1        ONLINE  ONLINE       cwp-jfr-ipsdp1
ora.LISTENER_SCAN2.lsnr
      1        ONLINE  ONLINE       cwp-jfr-ipsdp2
ora.LISTENER_SCAN3.lsnr
      1        ONLINE  ONLINE       cwp-jfr-ipsdp2
ora.cvu
      1        ONLINE  ONLINE       cwp-jfr-ipsdp2
ora.cwp-jfr-ipsdp1.vip
      1        ONLINE  ONLINE       cwp-jfr-ipsdp1
ora.cwp-jfr-ipsdp2.vip
      1        ONLINE  ONLINE       cwp-jfr-ipsdp2
ora.iway.db
      1        ONLINE  ONLINE       cwp-jfr-ipsdp1           Open
      2        ONLINE  ONLINE       cwp-jfr-ipsdp2           Open
ora.oc4j
      1        ONLINE  ONLINE       cwp-jfr-ipsdp2
ora.scan1.vip
      1        ONLINE  ONLINE       cwp-jfr-ipsdp1
ora.scan2.vip
      1        ONLINE  ONLINE       cwp-jfr-ipsdp2
ora.scan3.vip
      1        ONLINE  ONLINE       cwp-jfr-ipsdp2


Para verificar los recursos del RAC:
crsctl stat res –t

Bajar BD intraway
Con el usuario oracle:
srvctl stop database -d iway -o immediate

Bajar ASM
con el usuario grid
srvctl stop ASM –f
------------------------------------------------------------------------------------------------
cambiar de zonas
clrg switch -n cwm-sfr-bdco2:z9tertso TERTIO76DB-rg

Otra manera de cambiar de zonas
clrg switch -z z9tertso -n cwm-sfr-bdco2 TERTIO76DB-rg


quitar el error Error_stop_failed a nivel del Resource Group o el error Stop_failed a nivel de un recurso 
clrs clear -f Stop_failed nombredelResource


Rman
SELECT * 
FROM RC_BACKUP_PIECE 
WHERE db_id='3487923406' 
AND TAG ='BACKUP_MES' 
AND MEDIA = 'DMG206' 
ORDER BY START_TIME DESC
Garrido, Jordy 02:11 p.m.
DMG206
--------------------

ALTER DATABASE DATAFILE '+DATA1/tertio11/datafile/prov_ssttertio76_sle.259.407758835'  RESIZE 300M;

ALTER TABLESPACE PROV_CWPSST760_SLE  RESIZE 300M;

ALTER TABLESPACE ts_jira  ADD DATAFILE 'D:\oracle\product\10.2.0\oradata\jiraadmi\TS_JIRA_01.dbf' size 400M

select file_name,bytes/1024/1024 mb
from dba_data_files
where tablespace_name = 'PROV_CWPSST760_SLE'
order by file_name;

PROV_CWPSST760_SLE
alter tablespace PROV_CWPSST760_SLE add datafile '+DATA1' size 500M autoextend on;

alter tablespace PROV_CWPSST760_EPT add datafile '+DATA1' size 300M autoextend on;

----------------------------------------------------------------------

Import/Export Utility in Oracle 9i
An export is a logical backup of the database. The export utility copies the data and database definitions to a binary operating system file.
Export can only be used against an open database. Because export copies one table at a time, it can only guarantee read consistency for individual tables. 
Read consistency between tables is not guaranteed. For a read consistent export of the entire database, changes to the database must stop during the export. 
This can be enforced by closing the database and then reopening it in RESTRICT mode.
Parameter Listing:
exp help=yes
imp help=yes

Simple Export command:
exp hr/hr file=c:\shahid\shaan.dmp log=c:\shahid\shaan.log tables=shaan rows=yes indexes=no
exp hr/hr file=c:\shahid\shaan.dmp log=c:\shahid\shaan.log tables=(shaan,employees)

exp userid=hr/hr@shaan parfile=c:\shahid\export.txt
before executing create export.txt parafile on the location c:\shahid\export.txt having
BUFFER=10000000
FILE=account.dmp
FULL=n
OWNER=scott                                                             
GRANTS=y
COMPRESS=y

To execute an incremental, cumulative or complete export:
exp username/password  inctype=incremental file=export_file_name
                              =Cumulative
                              =Complete

Export the file into multiple dump file:
exp hrms/hrms@orcl3 file=c:\shahid\hrms01.dmp, c:\shahid\hrms02.dmp,c:\shahid\hrms03.dmp log=c:\shahid\hrms.log filesize=50mb;
Note: In Oracle 10g autogenerate file name with %U postfix
expdp hrms/hrms@orcl3 dumpfile=expdir:hrms%U.dmp log=c:\shahid\hrms.log filesize=50mb;

Query using in Export:
exp HRMS/HRMS@ORCL3 tables=PAY_PAYMENT_MASTER query="""where PAYSLIP_NUMBER=5000""" file=c:\shahid\payslip_21853.dmp log=c:\shahid\payslip_21853.log
Restrictions
•The parameter QUERY cannot be specified for full, user, or tablespace mode exports.?
•The parameter QUERY must be applicable to all specified tables?
•The parameter QUERY cannot be specified in a direct path export (DIRECT=y)?
•The parameter QUERY cannot be specified for tables with inner nested tables.?
•You cannot determine from the contents of the export file whether the data is the ?result of a QUERY export.?

Connection as Sysdba for export:
exp 'sys/oracle@ORCL3 as sysdba' tables=PAY_PAYMENT_MASTER query="""where PAYSLIP_NUMBER=5000""" file=c:\shahid\payslip_21853.dmp log=c:\shahid\payslip_21853.log

Export Session in Full Database Mode:
exp system/oracle@orcl3 FULL=y file=c:\shahid\hrms_full.dmp log=c:\shahid\hrms_full.log GRANTS=y ROWS=y
Note: Entire database is exported with all grants and all data.

Export Session in User Mode:
exp hrms/hrms FILE=c:\shahid\hrms.dmp log=c:\shahid\hrms.log OWNER=hrms GRANTS=y ROWS=y COMPRESS=y?

Note:User mode is appropriate for backup one or more database user data or move objects from one owner to another.
Export Session in Table Mode: Export Table from different schema:
exp system/oracle@orcl3 FILE=c:\shahid\table.dmp log=c:\shahid\table.log TABLES=(hr.employees,hrms.pay_payment_master) GRANTS=y INDEXES=y

Export Table from same Schema:
exp hrms/hrms@orcl3 FILE=c:\shahid\table.dmp log=c:\shahid\table.log TABLES=(pay_employee_personal_info, pay_payment_master) GRANTS=y INDEXES=y

Export Table Using Pattern Maching:
exp system/oracle@orcl3 FILE=c:\shahid\misc.dmp log=c:\shahid\misc.log TABLES=(hrms.%e%)?
exp hrms/hrms@orcl3 FILE=c:\shahid\misc.dmp log=c:\shahid\misc.log TABLES=(emp%)

Exporting a table with a specific partition:
exp hrms/hrms@orcl3 TABLES=pay_payment_master:m rows=y

Exporting a table with composite partition:
exp hrms/hrms@orcl3 TABLES=(emp:m, emp:sp4) ROWS=y
Note: Exports in table mode do not include cluster definitions, so data is unclustered in table mode.

Partitioned a Database Migration
exp dba/password FILE=full FULL=y CONSTRAINTS=n TRIGGERS=n ROWS=n INDEXES=n
imp dba/password FILE=full FULL=y

Partitioned a Database Migration: Scheam Level
exp dba/password OWNER=scheman FILE=scheman
imp dba/password FILE=scheman FROMUSER=scheman TOUSER=scheman IGNORE=y

Use of FROMUSER Command:
imp SYSTEM/password FROMUSER=scott TOUSER=joe TABLES=emp?
imp SYSTEM/password FROMUSER=scott, fred TOUSER=joe, ted
imp SYSTEM/password FILE=dba.dmp FROMUSER=scott TABLES=(dept,emp)?

Import of Tables Exported by Another User:
imp SYSTEM/password FROMUSER=blake TOUSER=scott FILE=blake.dmp - ?TABLES=(unit, manager)?

Parameter File Method:
?imp SYSTEM/password PARFILE=params.dat

The params.dat file contains the following information:?
FILE=blake.dmp
SHOW=n
IGNORE=n
GRANTS=y
ROWS=y
FROMUSER=blake
TOUSER=scott
TABLES=(unit, manager)?

Import of Tables from One User to Another:
imp SYSTEM/password FILE=scott.dmp FROMUSER=scott TOUSER=blake TABLES=(*)?
Import of Using Pattern Matching to Import Various Tables:
imp SYSTEM/password FROMUSER=scott FILE=scott.dmp TABLES=(%d%,b%s)?

How to Schedule Export:
As a minimum the following export schedule should be used if you have any other alternative backup such as RMAN then you can take export as a backup for Weekly/Monthly Full export Schedule.
Once the Full export is taken, the DBA can remove previous backups. This should be implemented using automated procedures.
The expired exports would be deleted as before. This should also be implemented using automated procedures.
All export procedures should be logged so that they can be reviewed. Some data corruption problems, such as un-readable characters in a record, will only be caught by the export process.
Exports of individual tables can be taken prior to major operations such as bulk data loads to provide for individual table recovery.

Keyword used with Export
BUFFER: Buffer is the number of bytes used to fetch data rows. This will determine the number of rows fetched at a time. 
The formula for buffer is buffer size = (rows in array) * (maximum row size). The default is OS dependent. If you specify zero, the Export utility fetches only one row at a time. 
Tables with LONG, LOB, BFILE, REF, ROWID, LOGICAL ROWID, DATE, or type columns are fetched one row at a time.

COMPRESS: Compress will cause e3ort to resize the initial extents for all tables so they will import into one initial extent. The default value is YES.
Note: You can specify the COMPRESS parameter only when you export, not when you import. The Export utility is what generates the data definitions, 
including the storage parameter definitions. If you specify COMPRESS=Y when you export, you can import the data in consolidated form only.
Note: LOB data is not compressed. For LOB data, the original values of initial extent size and next extent size are used.

CONSISTENT: If consistent is set to YES export will make the export consistent to a single point in time. A rollback segment will be retained for the duration of the export.
The default value in NO. Setting this value to YES could cause rollback segments to grow very large if many changes are happening to the database.

CONSTRAINTS: If constraints is set to YES constraints will be exported. The default value is YES.

DIRECT: Setting DIRECT=Y will cause export to read data directly, without using the public buffer cache or the SQL command processing layer. The default value is NO.

FEEDBACK: When feedback is set to a non-zero number export will display a dot every time that many rows are exported. The default value is 0 which gives not feedback.

-------
Update subscripciones Repoting Services

SELECT * FROM dbo.Users WHERE UserName like 'CWP\WLL700556'
SELECT * FROM dbo.Users WHERE UserName like 'AQQ08381'
SELECT * FROM dbo.Users WHERE UserName like 'CWP\CWMOVIL'
SELECT * FROM dbo.Users WHERE UserName like 'CWP\JFF%'

select * from dbo.Subscriptions 
where ownerid = '2A272FA8-30F2-4105-B0D9-1B1027A25406'


DECLARE @OldUserID uniqueidentifier
DECLARE @NewUserID uniqueidentifier
SELECT @OldUserID = UserID FROM dbo.Users WHERE UserName = 'CWP\JFF93013'
SELECT @NewUserID = UserID FROM dbo.Users WHERE UserName = 'CWP\CWMOVIL'
UPDATE dbo.Subscriptions SET OwnerID = @NewUserID WHERE OwnerID = @OldUserID


***************************************************************************************************
*   AUMENTAR SGA_TARGET Y SGA_TARGET_MAX 
*
*alter system set sga_max_size=956m scope=spfile;
System altered.

SQL> startup force
ORACLE instance started.
Total System Global Area 1000189952 bytes
Fixed Size                  1337492 bytes
Variable Size             624953196 bytes
Database Buffers          369098752 bytes
Redo Buffers                4800512 bytes
Database mounted.
Database opened.

SQL> show parameter sga_max_size
NAME                                 TYPE        VALUE
------------------------------------ ----------- --------
sga_max_size                         big integer 956M
 
SQL> alter system set sga_target=900m;

************************************************************************************************************************
-- List unusable indexes for a specified schema. (All schemas if 'ALL' is specified.
--
 
SELECT owner,
       index_name
FROM   dba_indexes
WHERE  owner = DECODE(UPPER('&&Owner'), 'ALL', owner, UPPER('&&Owner'))
AND    status NOT IN ('VALID', 'N/A')
ORDER BY owner, index_name
/

---------------

OBJETOS INVALIDOS

select  object_name 
from   dba_objects 
where   status != 'VALID'
and owner = 'OCDM_STAGE'
and object_type = 'MATERIALIZED VIEW'
order by   owner,   object_type;


----------------

Los más altos consumidores de CPU que podemos observar son son:
queries alto consumo
query alto consumo

bash-3.2$ ps -e -o pcpu,pid,user,tty,args | grep -i oracle|sort -n -k 1 -r|head

5.1 21183 oracle9i ?       oracleunicorn (LOCAL=NO)
3.9 21428 oracle9i ?       oracleunicorn (LOCAL=NO)
3.4 21276 oracle9i ?       oracleunicorn (LOCAL=NO)
1.8  4124 oracle9i ?       oracleunicorn (LOCAL=NO)
0.9 21281 oracle9i ?       oracleunicorn (LOCAL=NO)
0.7 28257 oracle9i ?       ora_ckpt_unicorn
0.5 26486 oracle9i ?       /oracle/agent12c/core/12.1.0.2.0/jdk/bin/sparcv9/java -Xmx128M -XX:MaxPermSize=
0.3 22817 oracle9i ?       oracleunicorn (LOCAL=NO)
0.3 21278 oracle9i ?       oracleunicorn (LOCAL=NO)
0.3  7019 oracle9i ?       oracleunicorn (LOCAL=NO)
bash-3.2$ sqlplus

SQL*Plus: Release 9.2.0.8.0 - Production on Fri Oct 23 18:42:02 2015

Copyright (c) 1982, 2002, Oracle Corporation.  All rights reserved.

Enter user-name:
ERROR:
ORA-01017: invalid username/password; logon denied


Enter user-name: sys / as sysdba
Enter password:

Connected to:
Oracle9i Enterprise Edition Release 9.2.0.8.0 - 64bit Production
With the Partitioning and Oracle Data Mining options
JServer Release 9.2.0.8.0 - Production

SQL> SET LINESIZE 80 HEADING OFF FEEDBACK OFF
SELECT
SQL>   2    RPAD('USERNAME : ' || s.username, 80) ||
  3    RPAD('OSUSER   : ' || s.osuser, 80) ||
  4    RPAD('PROGRAM  : ' || s.program, 80) ||
  5    RPAD('SPID     : ' || p.spid, 80) ||
  6    RPAD('SID      : ' || s.sid, 80) ||
  7    RPAD('SERIAL#  : ' || s.serial#, 80) ||
  8    RPAD('MACHINE  : ' || s.machine, 80) ||
  9    RPAD('TERMINAL : ' || s.terminal, 80) ||
10    RPAD('SQL TEXT : ' || q.sql_text, 80)
11  FROM v$session s
12      ,v$process p
13      ,v$sql     q
14  WHERE s.paddr          = p.addr
15  AND   p.spid           = '&PROCESS_ID'
16  AND   s.sql_address    = q.address
17  AND   s.sql_hash_value = q.hash_value;
Enter value for process_id: 21183
old  15: AND   p.spid           = '&PROCESS_ID'
new  15: AND   p.spid           = '21183'

USERNAME : UNICORN
OSUSER   : admusha
PROGRAM  : DecisionServer@cwm-sfr-upra (TNS V1-V3)
SPID     : 21183
SID      : 72
SERIAL#  : 288
MACHINE  : cwm-sfr-upra
TERMINAL :
SQL TEXT : insert into CR_TMP_ACCOUNTCREDITDATA_3(ACCOUNTNO, CUSTOMERSEGMENT, VI

SQL>





Enter value for process_id: 21428
old  15: AND   p.spid           = '&PROCESS_ID'
new  15: AND   p.spid           = '21428'

USERNAME : UNICORN
OSUSER   : admusha
PROGRAM  : DecisionServer@cwm-sfr-upra (TNS V1-V3)
SPID     : 21428
SID      : 110
SERIAL#  : 201
MACHINE  : cwm-sfr-upra
TERMINAL :
SQL TEXT :   INSERT /*+ APPEND */ INTO CR_TMP_DISCOUNTABLE_USAGE (ACCOUNTNO, TOT

SQL>





Enter value for process_id: 21276
old  15: AND   p.spid           = '&PROCESS_ID'
new  15: AND   p.spid           = '21276'

USERNAME : UNICORN
OSUSER   : admusha
PROGRAM  : DecisionServer@cwm-sfr-upra (TNS V1-V3)
SPID     : 21276
SID      : 558
SERIAL#  : 23412
MACHINE  : cwm-sfr-upra
TERMINAL :
SQL TEXT : insert /*+ append */ into CR_TMP_USAGETHRESHOLD(ACCOUNTNO,USAGETHRESH

SQL>

---------------------
Reporting Services
Saber query dentro de un reporte

SELECT Name,
CAST(CAST(Content AS VARBINARY(MAX)) AS XML) AS ReportXML
FROM ReportServer.dbo.Catalog
where Type = 2
order by Name

--------------------

reportes que fueron ejecutados desde Reporting Services.  
Con esto podemos  investigar la hora de ejecución, el usuario  que lo  tiró , el nombre del reporte y el tiempo tomado.
 
Luego con esta info, se busca en http://cwprep/Reports/  dicho  reporte y  luego el Data Source, para  conocer a qué servidor y qué Base de datos se está conectando.
 
Este query debe ejecutarse a la BD ReportServer en el servidor cwm-sfr-msapp.  Pueden hacerlo con el usuario cwmovil.
 
/* Sólo modificar la fecha YYYYMMDD y el nombre del reporte */
 
select  Path, Name, TimeStart, TimeEnd,Parameters, UserName, Status,TimeDataRetrieval, TimeProcessing, TimeRendering, Format
from ExecutionLog a, Catalog b      
where  ReportID  =   ItemID
and CONVERT(varchar(8), TimeStart, 112) >= '20150901'   /*  fecha a buscar */
and Name like 'CC0074%'    /*  nombre del reporte */
order by TimeStart


----------------------

no pueden ingresar a las carpetas de reportes http://cwprep/Reportes/ validar en primer lugar que todos los reportes dentro de la carpeta cuenten con su correspondiente datasource; ya que por un error en la programación de la página, si a un reporte dentro de la carpeta le falta el datasource no permitirá el acceso a toda la carpeta.

Query para buscar en la base de datos, reportes con estatus de error de DataSource Invalido :

 

USE ReportServer

GO

SELECT

CAT_PARENT.Name AS ParentName,

CAT.Name AS ReportName,

ReportCreatedByUsers.UserName AS ReportCreatedByUserName,

CAT.CreationDate AS ReportCreationDate,

ReportModifiedByUsers.UserName AS ReportModifiedByUserName,

CAT.ModifiedDate AS ReportModifiedDate,

CountExecution.CountStart AS ReportExecuteCount,

EL.InstanceName AS LastExecutedServerName,

EL.UserName AS LastExecutedbyUserName,

EL.TimeStart AS LastExecutedTimeStart,

EL.TimeEnd AS LastExecutedTimeEnd,

EL.Status AS LastExecutedStatus,

EL.ByteCount AS LastExecutedByteCount,

EL.[RowCount] AS LastExecutedRowCount,

SubscriptionOwner.UserName AS SubscriptionOwnerUserName,

SubscriptionModifiedByUsers.UserName AS SubscriptionModifiedByUserName,

SUB.ModifiedDate AS SubscriptionModifiedDate,

SUB.Description AS SubscriptionDescription,

SUB.LastStatus AS SubscriptionLastStatus,

SUB.LastRunTime AS SubscriptionLastRunTime

FROM dbo.Catalog CAT

INNER JOIN dbo.Catalog CAT_PARENT

ON CAT.ParentID = CAT_PARENT.ItemID

INNER JOIN dbo.Users ReportCreatedByUsers

ON CAT.CreatedByID = ReportCreatedByUsers.UserID

INNER JOIN dbo.Users ReportModifiedByUsers

ON CAT.ModifiedByID = ReportModifiedByUsers.UserID

LEFT OUTER JOIN (SELECT

ReportID,

MAX(TimeStart) LastTimeStart

FROM dbo.ExecutionLog

GROUP BY ReportID) AS LatestExecution

ON CAT.ItemID = LatestExecution.ReportID

LEFT OUTER JOIN (SELECT

ReportID,

COUNT(TimeStart) CountStart

FROM dbo.ExecutionLog

GROUP BY ReportID) AS CountExecution

ON CAT.ItemID = CountExecution.ReportID

LEFT OUTER JOIN dbo.ExecutionLog AS EL

ON LatestExecution.ReportID = EL.ReportID

AND LatestExecution.LastTimeStart = EL.TimeStart

LEFT OUTER JOIN dbo.Subscriptions SUB

ON CAT.ItemID = SUB.Report_OID

LEFT OUTER JOIN dbo.Users SubscriptionOwner

ON SUB.OwnerID = SubscriptionOwner.UserID

LEFT OUTER JOIN dbo.Users SubscriptionModifiedByUsers

ON SUB.ModifiedByID = SubscriptionModifiedByUsers.UserID

WHERE

EL.Status in ('rsInvalidDataSourceReference')

ORDER BY CAT.ModifiedDate DESC, CAT_PARENT.Name, CAT.Name

------------

SQL SERVER  Listar los privilegios.

SELECT  
    [UserName] = CASE princ.[type] 
                    WHEN 'S' THEN princ.[name]
                    WHEN 'U' THEN ulogin.[name] COLLATE Latin1_General_CI_AI
                 END,
    [UserType] = CASE princ.[type]
                    WHEN 'S' THEN 'SQL User'
                    WHEN 'U' THEN 'Windows User'
                 END,  
    [DatabaseUserName] = princ.[name],       
    [Role] = null,      
    [PermissionType] = perm.[permission_name],       
    [PermissionState] = perm.[state_desc],       
    [ObjectType] = obj.type_desc,--perm.[class_desc],       
    [ObjectName] = OBJECT_NAME(perm.major_id),
    [ColumnName] = col.[name]
FROM    
    --database user
    sys.database_principals princ  
LEFT JOIN
    --Login accounts
    sys.login_token ulogin on princ.[sid] = ulogin.[sid]
LEFT JOIN        
    --Permissions
    sys.database_permissions perm ON perm.[grantee_principal_id] = princ.[principal_id]
LEFT JOIN
    --Table columns
    sys.columns col ON col.[object_id] = perm.major_id 
                    AND col.[column_id] = perm.[minor_id]
LEFT JOIN
    sys.objects obj ON perm.[major_id] = obj.[object_id]
WHERE 
    princ.[type] in ('S','U')
UNION
--List all access provisioned to a sql user or windows user/group through a database or application role
SELECT  
    [UserName] = CASE memberprinc.[type] 
                    WHEN 'S' THEN memberprinc.[name]
                    WHEN 'U' THEN ulogin.[name] COLLATE Latin1_General_CI_AI
                 END,
    [UserType] = CASE memberprinc.[type]
                    WHEN 'S' THEN 'SQL User'
                    WHEN 'U' THEN 'Windows User'
                 END, 
    [DatabaseUserName] = memberprinc.[name],   
    [Role] = roleprinc.[name],      
    [PermissionType] = perm.[permission_name],       
    [PermissionState] = perm.[state_desc],       
    [ObjectType] = obj.type_desc,--perm.[class_desc],   
    [ObjectName] = OBJECT_NAME(perm.major_id),
    [ColumnName] = col.[name]
FROM    
    --Role/member associations
    sys.database_role_members members
JOIN
    --Roles
    sys.database_principals roleprinc ON roleprinc.[principal_id] = members.[role_principal_id]
JOIN
    --Role members (database users)
    sys.database_principals memberprinc ON memberprinc.[principal_id] = members.[member_principal_id]
LEFT JOIN
    --Login accounts
    sys.login_token ulogin on memberprinc.[sid] = ulogin.[sid]
LEFT JOIN        
    --Permissions
    sys.database_permissions perm ON perm.[grantee_principal_id] = roleprinc.[principal_id]
LEFT JOIN
    --Table columns
    sys.columns col on col.[object_id] = perm.major_id 
                    AND col.[column_id] = perm.[minor_id]
LEFT JOIN
    sys.objects obj ON perm.[major_id] = obj.[object_id]
UNION
--List all access provisioned to the public role, which everyone gets by default
SELECT  
    [UserName] = '{All Users}',
    [UserType] = '{All Users}', 
    [DatabaseUserName] = '{All Users}',       
    [Role] = roleprinc.[name],      
    [PermissionType] = perm.[permission_name],       
    [PermissionState] = perm.[state_desc],       
    [ObjectType] = obj.type_desc,--perm.[class_desc],  
    [ObjectName] = OBJECT_NAME(perm.major_id),
    [ColumnName] = col.[name]
FROM    
    --Roles
    sys.database_principals roleprinc
LEFT JOIN        
    --Role permissions
    sys.database_permissions perm ON perm.[grantee_principal_id] = roleprinc.[principal_id]
LEFT JOIN
    --Table columns
    sys.columns col on col.[object_id] = perm.major_id 
                    AND col.[column_id] = perm.[minor_id]                   
JOIN 
    --All objects   
    sys.objects obj ON obj.[object_id] = perm.[major_id]
WHERE
    --Only roles
    roleprinc.[type] = 'R' AND
    --Only public role
    roleprinc.[name] = 'public' AND
    --Only objects of ours, not the MS objects
    obj.is_ms_shipped = 0
ORDER BY
    princ.[Name],
    OBJECT_NAME(perm.major_id),
    col.[name],
    perm.[permission_name],
    perm.[state_desc],
    obj.type_desc--perm.[class_desc] 
    
    
    
    
    
    
    
    
    
    
SET LINESIZE 80 HEADING OFF FEEDBACK OFF0
SELECT RPAD('USERNAME : ' || s.username, 80) ||
    RPAD('OSUSER   : ' || s.osuser, 80) ||
    RPAD('PROGRAM  : ' || s.program, 80) ||
    RPAD('SPID     : ' || p.spid, 80) ||
    RPAD('SID      : ' || s.sid, 80) ||
    RPAD('SERIAL#  : ' || s.serial#, 80) ||
    RPAD('MACHINE  : ' || s.machine, 80) ||
    RPAD('TERMINAL : ' || s.terminal, 80) ||
   RPAD('SQL TEXT : ' || q.sql_text, 80)
 FROM v$session s
     ,v$process p
     ,v$sql     q
 WHERE s.paddr          = p.addr
 AND   p.spid           = '&PROCESS_ID'
 AND   s.sql_address    = q.address
 AND   s.sql_hash_value = q.hash_value;
 
 
%Porcentaje de avance de una tarea
                                   V89gm+!3
 set linesize 300 
  select sid,to_char(start_time,'DD-MON-YYYY HH24:MI:SS') Inicio,to_char(sysdate,'DD-MON-YYYY HH24:MI:SS') Hora, totalwork,sofar,(sofar/totalwork) * 100 pct_done,
   time_remaining as TIEMPO_RESTANTE_SEGs, round((time_remaining /60 /60),2) as HORAS 
   from v$session_longops  where totalwork > sofar order by 1;

select sid, target, to_char(start_time,'hh24:mi') start_time, elapsed_seconds/60 elapsed, round(time_remaining/60,2) "min_remaining",
message from v$session_longops where time_remaining > 0;
 


  set linesize 300
  select sid,start_time, totalwork,sofar,(sofar/totalwork) * 100 pct_done,  time_remaining 
  from v$session_longops 
  where totalwork > sofar order by 1;                   
 

--SOFAR SQL

SELECT  session_id,start_time,status,command, percent_complete,   estimated_completion_time, estimated_completion_time /60/1000 as estimate_completion_minutes,
     --(select convert(varchar(5),getdate(),8)),
       DATEADD(n,(estimated_completion_time /60/1000),GETDATE()) as estimated_completion_time
FROM    sys.dm_exec_requests where command = 'BACKUP DATABASE' OR command = 'RESTORE DATABASE' OR command = 'BACKUP LOG' or command like 'DBCC%'  or command like 'AWAITING COMMAND%'

select sid, target, to_char(start_time,'hh24:mi') start_time, elapsed_seconds/60 elapsed, round(time_remaining/60,2) "min_remaining",
message from v$session_longops where time_remaining > 0;

SELECT name, log_reuse_wait_desc FROM sys.DATABASES 

set linesize 300
set pagesize 300 
select sid, (select to_char(sysdate,'DD-MON-YYYY HH24:MI:SS') from dual)as "EJECUCION" ,to_char(start_time,'DD-MON-YYYY HH24:MI:SS') Inicio,totalwork,sofar,(sofar/totalwork) * 100 pct_done,
time_remaining as TIEMPO_RESTANTE_SEGs, round((time_remaining /60 /60),2) as HORAS
from v$session_longops  where totalwork > sofar and OPNAME like '%RMAN%' order by 1;

col OPNAME for a30
select OPNAME,SOFAR/TOTALWORK*100 PERCENT_SOFAR, trunc(TIME_REMAINING/60) TIME_REMAINING,
trunc(ELAPSED_SECONDS/60) TIME_CONSUMED
from v$session_longops where TOTALWORK>0 and OPNAME like '%RMAN%';

col OPNAME for a30
select OPNAME,SOFAR/TOTALWORK*100 PERCENT_SOFAR, trunc(TIME_REMAINING/60) TIME_REMAINING,
trunc(ELAPSED_SECONDS/60) TIME_CONSUMED
from v$session_longops where TOTALWORK>0 and OPNAME like '%restore%';


································································································
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
REM RMAN Progress
alter session set nls_date_format='dd/mm/yy hh24:mi:ss'
/
select SID, START_TIME,TOTALWORK, sofar, (sofar/totalwork) * 100 done,
sysdate + TIME_REMAINING/3600/24 end_at
from v$session_longops
where totalwork > sofar
AND opname NOT LIKE '%aggregate%'
AND opname like 'RMAN%'
/

REM RMAN waits
set lines 120
column sid format 9999
column spid format 99999
column client_info format a25
column event format a30
column secs format 9999
SELECT SID, SPID, CLIENT_INFO, event, seconds_in_wait secs, p1, p2, p3
  FROM V$PROCESS p, V$SESSION s
  WHERE p.ADDR = s.PADDR
  and CLIENT_INFO like 'rman channel=%'
/


$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$4444
   
 ?+-+  -+?
 ¦¦¦ /¦/
 ¦¦¦/¦/
 ¦¦ /¦/---+?
 ¦¦¦¦|¦¦¦¦
+----+-+-+
¦¦+--+¦¦¦¦?
++¦¦¦¦¦¦++
?++¦¦¦¦+


 --------------
 
 When rebuilding fragmented (indexes with deleted leaf nodes) we will expect the space to be reduced:

col segment_name format a40
col blocks       format 999,999,999
 
select
   segment_name,
   blocks
from
   dba_segments
where
   segment_type = 'INDEX'
and
   owner = 'xxx';
 
 
 Tablas FRAGMENTADAS  1
 
SELECT table_name,
         ROUND ( (blocks / 1024 * 8), 2) "size (mb)",
         ROUND ( (num_rows * avg_row_len / 1024 / 1024), 2) "actual_data (mb)",
         (  ROUND ( (blocks / 1024 * 8), 2)  - ROUND ( (num_rows * avg_row_len / 1024 / 1024), 2))    "wasted_space (mb)",
          (  ROUND ( (blocks / 1024 * 8), 2)  - ROUND ( (num_rows * avg_row_len / 1024 / 1024), 2)) /  ROUND ( (blocks / 1024 * 8), 2) * 100
    FROM dba_tables
   WHERE     (ROUND ( (blocks / 1024 * 8), 2) >
                 ROUND ( (num_rows * avg_row_len / 1024 / 1024), 2))
and owner='SIEBEL'
and table_name like 'S_%'
ORDER BY 5 DESC;


--Query mejorado Tablas FRAGMENTADAS  2
 SELECT table_name, ROUND ( (blocks / 1024 * 8), 2) "size (mb)",ROUND ( (num_rows * avg_row_len / 1024 / 1024), 2) "actual_data (mb)",
( ROUND ((blocks / 1024 * 8), 2) - ROUND ( (num_rows * avg_row_len / 1024 / 1024), 2)) "wasted_space (mb)",
ROUND(( (ROUND ((blocks / 1024 * 8), 2) - ROUND ( (num_rows * avg_row_len / 1024 / 1024), 2)) / ROUND ( (blocks / 1024 * 8), 2) * 100 ) ,2)    
FROM dba_tables
WHERE (ROUND ( (blocks / 1024 * 8), 2) > ROUND ( (num_rows * avg_row_len / 1024 / 1024), 2))
AND owner='SIEBEL'
AND TABLE_NAME LIKE 'S_%'
AND (TABLE_NAME NOT LIKE 'S_%BK%' AND TABLE_NAME NOT LIKE 'S_%BCK%')
AND ROUND ( (blocks / 1024 * 8), 2)  > 1 
ORDER BY 5 DESC;


SELECT table_name,
         ROUND ( (blocks / 1024 * 8), 2) "size (mb)",
         ROUND ( (num_rows * avg_row_len / 1024 / 1024), 2) "actual_data (mb)",
         (  ROUND ( (blocks / 1024 * 8), 2)
          - ROUND ( (num_rows * avg_row_len / 1024 / 1024), 2))
            "wasted_space (mb)",
          round( ( (  ROUND ( (blocks / 1024 * 8), 2)
          - ROUND ( (num_rows * avg_row_len / 1024 / 1024), 2)) /  ROUND ( (blocks / 1024 * 8), 2)) * 100, 2)  "resultado%"
           
    FROM dba_tables
   WHERE     (ROUND ( (blocks / 1024 * 8), 2) >
                 ROUND ( (num_rows * avg_row_len / 1024 / 1024), 2))
and owner='SIEBEL'
and table_name = 'S_QUOTE_ITEM'

/**************Estos serán los pasos a ejecutar para el TP de Siebel fijo, mañana sábado. La parte que más demora es la reconstrucción de cada uno de los índices.

ALTER TABLE SIEBEL.S_ORG_EXT MOVE TABLESPACE SIEBEL_TBL11
      STORAGE ( INITIAL 20K
                NEXT 40K
                MINEXTENTS 2
                MAXEXTENTS 400
                PCTINCREASE 0 );


alter index SIEBEL.S_ORG_EXT_F10 rebuild parallel 3;
alter index SIEBEL.S_ORG_EXT_F11 rebuild parallel 3;
alter index SIEBEL.S_ORG_EXT_F2 rebuild parallel 3;


*/

 --SQL SERVER 
SELECT * FROM sys.dm_exec_sessions WHERE session_id = 68
SELECT * FROM sys.dm_exec_requests WHERE session_id = 68

siebel Fijo -
Notepad 1: alter user &&usuario ACCOUNT LOCK;
Notepad 2: alter user &&usuario ACCOUNT UNLOCK;
Notepad 3: alter user &&usuario identified by &password;
Notepad 4: create user &&usuario PROFILE SECURE_PROFILE identified by &password DEFAULT TABLESPACE USR TEMPORARY TABLESPACE TEMPN;

grant sse_role to &&usuario;


--archives generados por hora
SELECT to_date(first_time) DAY,
to_char(sum(decode(to_char(first_time,'HH24'),'00',1,0)),'9999') "00",
to_char(sum(decode(to_char(first_time,'HH24'),'01',1,0)),'9999') "01",
to_char(sum(decode(to_char(first_time,'HH24'),'02',1,0)),'9999') "02",
to_char(sum(decode(to_char(first_time,'HH24'),'03',1,0)),'9999') "03",
to_char(sum(decode(to_char(first_time,'HH24'),'04',1,0)),'9999') "04",
to_char(sum(decode(to_char(first_time,'HH24'),'05',1,0)),'9999') "05",
to_char(sum(decode(to_char(first_time,'HH24'),'06',1,0)),'9999') "06",
to_char(sum(decode(to_char(first_time,'HH24'),'07',1,0)),'999') "07",
to_char(sum(decode(to_char(first_time,'HH24'),'08',1,0)),'999') "08",
to_char(sum(decode(to_char(first_time,'HH24'),'09',1,0)),'999') "09",
to_char(sum(decode(to_char(first_time,'HH24'),'10',1,0)),'999') "10",
to_char(sum(decode(to_char(first_time,'HH24'),'11',1,0)),'999') "11",
to_char(sum(decode(to_char(first_time,'HH24'),'12',1,0)),'999') "12",
to_char(sum(decode(to_char(first_time,'HH24'),'13',1,0)),'999') "13",
to_char(sum(decode(to_char(first_time,'HH24'),'14',1,0)),'999') "14",
to_char(sum(decode(to_char(first_time,'HH24'),'15',1,0)),'999') "15",
to_char(sum(decode(to_char(first_time,'HH24'),'16',1,0)),'999') "16",
to_char(sum(decode(to_char(first_time,'HH24'),'17',1,0)),'999') "17",
to_char(sum(decode(to_char(first_time,'HH24'),'18',1,0)),'999') "18",
to_char(sum(decode(to_char(first_time,'HH24'),'19',1,0)),'999') "19",
to_char(sum(decode(to_char(first_time,'HH24'),'20',1,0)),'999') "20",
to_char(sum(decode(to_char(first_time,'HH24'),'21',1,0)),'999') "21",
to_char(sum(decode(to_char(first_time,'HH24'),'22',1,0)),'999') "22",
to_char(sum(decode(to_char(first_time,'HH24'),'23',1,0)),'999') "23"
from
v$log_history
where to_date(first_time) > sysdate -8                                  
GROUP by
to_char(first_time,'YYYY-MON-DD'), to_date(first_time)
order by to_date(first_time) 
/

--tamaño de archive generados por día
select trunc(COMPLETION_TIME,'DD') Day, thread#, round(sum(BLOCKS*BLOCK_SIZE)/1048576) MB,count(*) Archives_Generated from v$archived_log
group by trunc(COMPLETION_TIME,'DD'),thread# order by 1;

--tamaño de archive generados por hora
select trunc(COMPLETION_TIME,'HH') Hour,thread# , round(sum(BLOCKS*BLOCK_SIZE)/1048576) MB,count(*) Archives from v$archived_log
group by trunc(COMPLETION_TIME,'HH'),thread#  order by 1 ;

select trunc(first_time, 'HH') , count(*)
    from   v$loghist
    group by trunc(first_time, 'HH')
    order by trunc(first_time, 'HH');

--redo entries archives
select s.sid, n.name, s.value, sn.username, sn.program, sn.type, sn.module
from v$sesstat s 
  join v$statname n on n.statistic# = s.statistic#
  join v$session sn on sn.sid = s.sid
where name like '%redo entries%'
order by value desc;

--Busca en el sqlarea con los queries que se están ejecutando y los valores de cuanto tiempo en cpu y el elapsed time
SELECT
          sess.username,
          sqla.optimizer_mode,
          sqla.hash_value,
          sqla.address,
          sqla.cpu_time,
          sqla.elapsed_time,
          sqla.sql_text,
          count (sqla.sql_text)
     FROM gv$sqlarea sqla, gv$session sess
    WHERE sess.sql_hash_value = sqla.hash_value
      AND sess.sql_address = sqla.address
      group by
          sess.username,
          sqla.optimizer_mode,
          sqla.hash_value,
          sqla.address,
          sqla.cpu_time,
          sqla.elapsed_time,
          sqla.sql_text
          order by 6 desc;

-- tamaño de la BD
--There are several ways to measure the size of an Oracle database:

1 - The size of the Oracle database files can be computed several ways:
  -- get database size from v$datafile:

select round((sum(bytes)/1048576/1024),2) from v$datafile;

-- get Oracle database size from dba_data_files:
select
"Reserved_Space(MB)", "Reserved_Space(MB)" - "Free_Space(MB)" "Used_Space(MB)","Free_Space(MB)"
from(
select 
(select sum(bytes/(1014*1024)) from dba_data_files) "Reserved_Space(MB)",
(select sum(bytes/(1024*1024)) from dba_free_space) "Free_Space(MB)"
from dual
);

2 - The size of the sum of table extents

select 
   segment_name table_name, 
   sum(bytes)/(1024*1024) table_size_meg 
from 
   user_extents 
where 
   segment_type='TABLE' 
and 
   segment_name = 'MYTAB' 
group 
See code depot for full scripts.

3 - The sum of the size of the data within the tables

You can also compute the size of an Oracle database over time.  In Oracle 10g and beyond we have the dba_hist_seg_stat table with a wealth of information about all active segments within the database, including the space usage in the space_allocated_total and space_used_total columns.

This script will show "spaced used total" (total size) for a specific Oracle table, essentially computing the Oracle table size over time:

col c1 format a15 heading 'snapshot|date'
col c2 format a25 heading 'table|name'
col c3 format 999,999,999 heading 'space|used|total'
select
to_char(begin_interval_time,'yy/mm/dd hh24:mm') c1,
object_name c2,
space_used_total c3
from
dba_hist_seg_stat s,
dba_hist_seg_stat_obj o,
dba_hist_snapshot sn
where
o.owner = 'SCHEMA_07'
and
s.obj# = o.obj#
and
sn.snap_id = s.snap_id
and
object_name like 'XIF2%'
order by
begin_interval_time;

-----------diccionario

--Gather statistics for the object schema                  

exec DBMS_STATS.GATHER_SCHEMA_STATS(‘BERT’);
 
--Gather statistics for fixed tables and data dictionary                            

exec DBMS_STATS.GATHER_FIXED_OBJECTS_STATS;
exec DBMS_STATS.GATHER_DICTIONARY_STATS;

--solo da los usuarios SQL Server
select * from sysusers where altuid is null 
 



GRANT ALL ON *.* to mysqlroot@'172.18.92.158' IDENTIFIED BY 'wsgQ3chM' with grant option;
GRANT ALL ON *.* to nagiosopcss@'172.18.254.86' IDENTIFIED BY 'wsgQ3chM' with grant option;

GRANT ALL ON *.* to root@'172.18.1.52' IDENTIFIED BY 'sion' with grant option;

172.18.14.129 -134
admin/Dpees161ml

Export de NUMTEST

exp ni00/ni001@cwm-sfr-numtestni owner=ni00 file=/u01/export/exp_numtest_24oct2016.dmp rows=Y grants=y indexes=y                                                                            

$ imp file=/export/home/oracle/exp_numtest_22oct2016.dmp rows=y fromuser=ni00 touser=ni00 grants=y indexes=y





-------funciono numtest
expdp system dumpfile=file.dmp DIRECTORY=dmptemp logfile=export.log  schemas=ni00
impdp system dumpfile=file.dmp logfile=import.log remap_schema=ni00:ni00 DIRECTORY=dmptemp




-----SQL Fragmentacion

The following table summarizes when to use each one:
Reference Values (in %)	                     Action	            SQL statement
avg_fragmentation_in_percent > 5 AND < 30	  Reorganize Index	   ALTER INDEX REORGANIZE
avg_fragmentation_in_percent > 30	          Rebuild Index	       ALTER INDEX REBUILD

 

SELECT OBJECT_NAME(ind.OBJECT_ID) AS TableName, 
ind.name AS IndexName, indexstats.index_type_desc AS IndexType, 
indexstats.avg_fragmentation_in_percent 
FROM sys.dm_db_index_physical_stats(DB_ID(), NULL, NULL, NULL, NULL) indexstats 
INNER JOIN sys.indexes ind  
ON ind.object_id = indexstats.object_id 
AND ind.index_id = indexstats.index_id 
WHERE indexstats.avg_fragmentation_in_percent > 30 
ORDER BY indexstats.avg_fragmentation_in_percent DESC    

QUERY PARA HACER EL REBUILD DE INDICES  --Tambien hay que irse en SSMS en Tools - Options- Query Execution -  SQL Server General - Batch separator a ;

SELECT 'ALTER INDEX [' + ind.name   + ' ]  ON [dbo].[' +  OBJECT_NAME(ind.OBJECT_ID)  + '] REBUILD PARTITION = ALL WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON); '
FROM sys.dm_db_index_physical_stats(DB_ID(), NULL, NULL, NULL, NULL) indexstats 
INNER JOIN sys.indexes ind  
ON ind.object_id = indexstats.object_id 
AND ind.index_id = indexstats.index_id 
WHERE indexstats.avg_fragmentation_in_percent > 30 
ORDER BY indexstats.avg_fragmentation_in_percent DESC


SELECT dbschemas.[name] as 'Schema',
dbtables.[name] as 'Table',
dbindexes.[name] as 'Index',
indexstats.avg_fragmentation_in_percent,
indexstats.page_count
FROM sys.dm_db_index_physical_stats (DB_ID(), NULL, NULL, NULL, NULL) AS indexstats
INNER JOIN sys.tables dbtables on dbtables.[object_id] = indexstats.[object_id]
INNER JOIN sys.schemas dbschemas on dbtables.[schema_id] = dbschemas.[schema_id]
INNER JOIN sys.indexes AS dbindexes ON dbindexes.[object_id] = indexstats.[object_id]
AND indexstats.index_id = dbindexes.index_id
WHERE indexstats.database_id = DB_ID()
ORDER BY indexstats.avg_fragmentation_in_percent desc



 In SQL Server 2000 you cannot use the ALTER INDEX but you can use the DBCC DBREINDEX statement instead.

Syntax examples for rebuilding an index in SQL Server 2000:

— Rebuild a specific index in a given table
USE [DATABASE_NAME];
DBCC DBREINDEX ([TABLE_NAME], ‘[INDEX_NAME]’,[FILL_FACTOR_VALUE_BETWEEN_0_100])
GO

— Rebuild all the indexes in a given table
USE [DATABASE_NAME];
DBCC DBREINDEX ([TABLE_NAME], ”, [FILL_FACTOR_VALUE_BETWEEN_0_100])
GO

 Reorganizing an Index
————————–
Reorganizing an index physically reorders the leaf-level pages to match the logical, left to right, order of the leaf nodes. It also compacts the index pages based on the existing fill factor value.

Syntax examples for reorganizing an index in SQL Server 2005 or later:

— Reorganize a specific index in a given table
USE [DATABASE_NAME];
GO
ALTER INDEX [INDEX_NAME] ON [SCHEMA.TABLE_NAME]
REORGANIZE ;
GO

— Reorganize all indexes in a given table
USE [DATABASE_NAME];
GO
ALTER INDEX ALL ON [SCHEMA.TABLE_NAME]
REORGANIZE ;
GO

* In SQL Server 2000 you cannot use the ALTER INDEX but you can use the DBCC INDEXDEFRAG statement instead.

Syntax example for reorganizing an index in SQL Server 2000:

DBCC INDEXDEFRAG ([DATABASE_NAME], [TABLE_NAME], [INDEX_NAME])
GO
-------------

Borrar registros en lotes


#!/bin/sh

function DELETEIRMLOGAUX {
ORA_CONN=portal/xxxxxx@ictprd

vOUT=`sqlplus -s /nolog << LBLSQL
connect $ORA_CONN
set serveroutput on
declare

cursor ac is
select id
from portal.IRM_LOG_AUX 
where trunc(date_time) <= to_date('01/01/2013','DD/MM/YYYY')
and rownum < 1000;

begin

for i in  ac loop

delete from portal.IRM_LOG_AUX  a
where trunc(date_time) <= to_date('01/01/2013','DD/MM/YYYY')
and a.id=i.id;

commit;
end loop;

end;
/
exit;
LBLSQL`

}

function IRM_ROAMING_LOG {
ORA_CONN=portal/xxxxxx@ictprd

vOUT=`sqlplus -s /nolog << LBLSQL
connect $ORA_CONN
set serveroutput on
declare

cursor cur_log is
select id
from  portal.IRM_ROAMING_LOG
where trunc(date_time_generation) <= to_date('01/01/2013','DD/MM/YYYY')
and   rownum < 1000;

begin

for i in  cur_log loop

delete from  portal.IRM_ROAMING_LOG
where trunc(date_time_generation) <= to_date('01/01/2013','DD/MM/YYYY')
and a.id=i.id;

commit;
end loop;

end;
/
exit;
LBLSQL`

}

DELETEIRMLOGAUX
IRM_ROAMING_LOG

exit

+--------------------------------+

-- 1. Borrado en lotes SQL Server

+--------------------------------+


SET NOCOUNT ON;
 
DECLARE @r INT;
 
SET @r = 1;
 
WHILE @r > 0
BEGIN
  BEGIN TRANSACTION;
 
  DELETE TOP (100000) -- this will change
    dbo.SalesOrderDetailEnlarged
    WHERE ProductID IN (712, 870, 873);
 
  SET @r = @@ROWCOUNT;
 
  COMMIT TRANSACTION;
 
  -- CHECKPOINT;    -- if simple
  -- BACKUP LOG ... -- if full
END

 --------------------------------------

+----------------------------------------------------------------------------------------------+

#####################    2. Borrado en lotes SQL Server     #####################
https://www.mssqltips.com/sqlservertip/6240/script-to-delete-sql-server-data-in-batches/

+----------------------------------------------------------------------------------------------+

IF EXISTS (
   SELECT type_desc, type
    FROM sys.procedures WITH(NOLOCK)
    WHERE NAME = 'Batch_Delete'
            AND type = 'P'
)
DROP PROCEDURE Batch_Delete
GO
 
CREATE PROCEDURE Batch_Delete
@startDate          DATE,
@endDate            DATE,
@dbName             VARCHAR(64) = NULL,
@schemaName         VARCHAR(64) = NULL,
@tableName          VARCHAR(64) = NULL,
@dateFieldName      VARCHAR(64) = NULL,
@saveToHistoryTable BIT = 1,
@batch              INT = 1000
AS
  SET NOCOUNT ON
 
  DECLARE @tableExists BIT = 0
  DECLARE @fieldExists BIT = 0
  DECLARE @sqlCommand NVARCHAR(2048)
 
  IF(@startDate > @endDate OR @startDate = @endDate)
  BEGIN
   RAISERROR('startDate can''t be higher or equal than endDate!!!', 16, -1)
   RETURN
  END
 
  IF(@dbName IS NULL OR TRIM(@dbname) = '')
  BEGIN
   RAISERROR('You must specify the source database where the table is hosted!!!', 16, -1)
   RETURN
  END
 
  IF(@schemaName IS NULL OR TRIM(@schemaName) = '')
  BEGIN
   RAISERROR('You must specify the schema of the table!!!', 16, -1)
   RETURN
  END
 
  IF(@tableName IS NULL OR TRIM(@tableName) = '')
  BEGIN
   RAISERROR('You must specify the name of the table!!!', 16, -1)
   RETURN
  END
 
  IF(@dateFieldName IS NULL OR TRIM(@dateFieldName) = '')
  BEGIN
   RAISERROR('You must specify the name of the column that contains the dates for the lookups!!!', 16, -1)
   RETURN
  END
 
  DECLARE @e AS TABLE([objectID] BIGINT)
  SET @sqlCommand = '
  DECLARE @objectID BIGINT = 0
  SELECT @objectID = OBJECT_ID ('+CHAR(39)+'['+@dbname+'].['+@schemaName+'].['+@tableName+']'+CHAR(39)+',''U'')
  SELECT ISNULL(@objectID,-1)
  '
 
  INSERT INTO @e
  EXEC sp_executesql @sqlCommand
  SET @tableExists = (SELECT CASE [objectID] WHEN -1 THEN 0 ELSE 1 END FROM @e)
  DELETE FROM @e
 
  IF(@tableExists <> 1)
  BEGIN
   RAISERROR('The specified table can''t be located, please check and try again!!!', 16, -1)
   RETURN
  END
 
  DECLARE @f AS TABLE([size] SMALLINT)
  SET @sqlCommand = '
  DECLARE @colSize SMALLINT = 0
  SELECT @colSize = COL_LENGTH ('+CHAR(39)+'['+@dbname+'].['+@schemaName+'].['+@tableName+']'+CHAR(39)+','+CHAR(39)+@dateFieldName+CHAR(39)+')
  SELECT ISNULL(@colSize,-1)
  '
  INSERT INTO @f
  EXEC sp_executesql @sqlCommand
  SET @fieldExists = (SELECT CASE [size] WHEN -1 THEN 0 ELSE 1 END FROM @f)
  DELETE FROM @f
 
  IF(@fieldExists = 0)
  BEGIN
   RAISERROR('The specified field can''t be located, please check and try again!!!', 16, -1)
   RETURN
  END
 
  IF(@saveToHistoryTable = 0)
  PRINT 'Be aware that you have invoked the execution of this SP with historical data transfer turned off!!!'
 
  -- Per Day logic
  DECLARE @currentDate DATE
  DECLARE @startTime   DATETIME
  DECLARE @endTime     DATETIME
  DECLARE @rows        INT
  DECLARE @totalRows   INT
  DECLARE @deletedRows INT
 
  SET @currentDate = @startDate
 
  SET @sqlCommand = '
  USE '+'['+@dbname+']
  '
  EXEC(@sqlCommand)
 
  IF OBJECT_ID ('Delete_Metrics','U') IS NULL
  BEGIN
    CREATE TABLE Delete_Metrics(
      StartDate      DATE NOT NULL,
      EndDate        DATE NOT NULL,
      Records        INT NOT NULL,
      CompletionTime INT NOT NULL
   )
    CREATE NONCLUSTERED INDEX IX_StartDate ON Delete_Metrics(StartDate)
    CREATE NONCLUSTERED INDEX IX_EndDate ON Delete_Metrics(EndDate)
  END
 
  IF(@saveToHistoryTable = 1)
  BEGIN
   DECLARE @h AS TABLE([rows] INT)
    SET @sqlCommand = '
    SET NOCOUNT ON
 
    IF OBJECT_ID ('+CHAR(39)+'['+@dbname+'].['+@schemaName+'].['+@tableName+'_historic]'+CHAR(39)+',''U'') IS NULL
    BEGIN
        SELECT TOP 0 * INTO ['+@dbname+'].['+@schemaName+'].['+@tableName+'_historic] FROM ['+@dbname+'].['+@schemaName+'].['+@tableName+']  
    END
 
    INSERT INTO ['+@dbname+'].['+@schemaName+'].['+@tableName+'_historic]
    SELECT * FROM ['+@dbname+'].['+@schemaName+'].['+@tableName+'] WHERE ['+@dateFieldName+'] >= '+CHAR(39)+CONVERT(VARCHAR(20),@startDate)+CHAR(39)+' AND ['+@dateFieldName+'] < '+CHAR(39)+CONVERT(VARCHAR(20),@endDate)+CHAR(39)+'
   
   SELECT @@ROWCOUNT
   '
   INSERT INTO @h
    EXEC sp_executesql @sqlCommand
    SET @totalRows = (SELECT [rows] FROM @h)
    DELETE FROM @h
 
   IF(@totalRows > 0)
   RAISERROR ('#Finished transferring records to historic table#', 0, 1) WITH NOWAIT
  END
 
  WHILE(@currentDate < @endDate)
  BEGIN
   BEGIN TRANSACTION
      BEGIN TRY
            DECLARE @t AS TABLE([rows] INT)
            SET @sqlCommand = '
            DECLARE @tempTotalRows INT = 0
            SELECT @tempTotalRows = COUNT(*) FROM ['+@dbName+'].['+@schemaName+'].['+@tableName+'] WHERE ['+@dateFieldName+'] >= '+CHAR(39)+CONVERT(VARCHAR(20),@currentDate)+CHAR(39)+' AND ['+@dateFieldName+'] < DATEADD(DAY,1,'+CHAR(39)+CONVERT(VARCHAR(20),@currentDate)+CHAR(39)+')
            SELECT @tempTotalRows
            '
            INSERT INTO @t
            EXEC sp_executesql @sqlCommand
            SET @totalRows = (SELECT [rows] FROM @t)
            DELETE FROM @t
 
         SET @deletedRows = 0
         SET @startTime = GETDATE()
         DECLARE @d AS TABLE([rows] INT)
 
         WHILE @deletedRows < @totalRows 
         BEGIN
             SET @sqlCommand = '            
            DELETE TOP ('+CONVERT(VARCHAR(16),@batch)+')
            FROM ['+@dbName+'].['+@schemaName+'].['+@tableName+'] WHERE ['+@dateFieldName+'] >= '+CHAR(39)+CONVERT(VARCHAR(20),@currentDate)+CHAR(39)+' AND ['+@dateFieldName+'] < DATEADD(DAY,1,'+CHAR(39)+CONVERT(VARCHAR(20),@currentDate)+CHAR(39)+')
 
            SELECT @@ROWCOUNT
                '
 
                INSERT INTO @d
            EXEC sp_executesql @sqlCommand
            SET @deletedRows += (SELECT [rows] FROM @d)
            DELETE FROM @d
         
            SELECT l.total_size AS TotalSize,f.free_space AS FreeSpace
            FROM(
               SELECT CONVERT(DECIMAL(10,2),(total_log_size_in_bytes - used_log_space_in_bytes)/1024.0/1024.0) AS [free_space]  
               FROM sys.dm_db_log_space_usage
            )AS f,
            (
               SELECT CONVERT(DECIMAL(10,2),size*8.0/1024.0) AS [total_size]
               FROM sys.database_files
               WHERE type_desc = 'LOG'
            )AS l
 
         END
 
         IF(@deletedRows > 0)
         BEGIN
            DECLARE @stringDate VARCHAR(10) = CONVERT(VARCHAR(10),@currentDate)
            RAISERROR('Finished deleting records for date: %s',0,1,@stringDate) WITH NOWAIT
            INSERT INTO Delete_Metrics VALUES(@currentDate, DATEADD(DAY,1,@currentDate),@deletedRows,DATEDIFF(SECOND,@startTime,GETDATE()))
         END
 
         SET @currentDate = DATEADD(DAY,1,@currentDate)
 
         COMMIT TRANSACTION
      END TRY
      BEGIN CATCH
         ROLLBACK TRANSACTION
         SELECT ERROR_MESSAGE() AS ErrorMessage;
      END CATCH
  END


--|""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""|
--| Here is the query you can use to get information about the delete process: |
--|""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""|

SELECT 
   StartDate,
   EndDate,
   Records,
   [Total Records] = SUM(Records) OVER (ORDER BY StartDate),
   CompletionTime,
   [Total Time] = SUM(CompletionTime) OVER (ORDER BY StartDate),
   CONVERT(DECIMAL(10,2),(SUM(Records) OVER (ORDER BY StartDate) / (SELECT CONVERT(DECIMAL(10,2),COUNT(*)) FROM big_table_historic) ) * 100) AS 'Progress'
FROM Delete_Metrics


--------------------------------------
Question: How to I collect a STATSPACK or AWR snapshot?  How to I invoke a STATSPACK or AWR report?
 
Answer: You can take a snapshot easily from the SQL*Plus prompt:
Taking an AWR snapshot (10g and beyond)
 
EXEC dbms_workload_repository.create_snapshot;
Taking a STATSPACK snapshot:

EXEC statspack.snap;

Step 2:  To execute a STATSPACK or AWR report, go to your $ORACLE_HOME/rdbms/admin directory and run:

awrrpt.sql

spreport.sql

 

Step 3:  Analyze the output with AWR Report Analysis screen.

 -------------------------------------------
 Sentencias para activar auditoria
 AUDIT CREATE USER BY ACCESS;
AUDIT ALTER USER BY ACCESS;
AUDIT DROP USER BY ACCESS;
AUDIT CREATE ROLE BY ACCESS;
AUDIT SELECT ON DBA_USERS BY ACCESS;
AUDIT CREATE EXTERNAL JOB BY ACCESS; -- 10g Rel.2
AUDIT CREATE JOB BY ACCESS; -- 10g Rel.1
AUDIT CREATE ANY JOB BY ACCESS;
AUDIT CREATE ANY LIBRARY BY ACCESS;
AUDIT ALTER DATABASE BY ACCESS;
AUDIT ALTER SYSTEM BY ACCESS;
AUDIT AUDIT SYSTEM BY ACCESS;
AUDIT EXEMPT ACCESS POLICY BY ACCESS;
AUDIT GRANT ANY PRIVILEGE BY ACCESS;
AUDIT GRANT ANY ROLE BY ACCESS;
AUDIT ALTER PROFILE BY ACCESS;
AUDIT CREATE ANY PROCEDURE BY ACCESS;
AUDIT ALTER ANY PROCEDURE BY ACCESS;
AUDIT DROP ANY PROCEDURE BY ACCESS;
AUDIT CREATE PUBLIC DATABASE LINK BY ACCESS;
AUDIT CREATE PUBLIC SYNONYM BY ACCESS;
AUDIT EXECUTE ON DBMS_FGA BY ACCESS;
AUDIT EXECUTE ON DBMS_RLS BY ACCESS;
AUDIT EXECUTE ON DBMS_FILE_TRANSFER BY ACCESS;
AUDIT EXECUTE ON DBMS_SCHEDULER BY ACCESS;
AUDIT EXECUTE ON DBMS_JOB BY ACCESS;
AUDIT SELECT ON SYS.V_$SQL BY ACCESS; 
AUDIT SELECT ON SYS.GV_$SQL BY ACCESS;
AUDIT EXECUTE ON SYS.KUPP$PROC BY ACCESS;
AUDIT EXECUTE ON DBMS_XMLGEN BY ACCESS;
audit audit system by access;
audit grant any object privilege by access;
audit create any table by access;
audit alter any table by access;
audit drop user by access;
audit drop any procedure by access;
audit drop any table by access;
audit drop profile by access;



Deshabilitar AWR
• Valor antes de deshabilitar el snapshot collection del AWR:

select extract( day from snap_interval) *24*60+extract( hour from snap_interval) *60+extract( minute from snap_interval ) snapshot_interval, extract( day from retention) *24*60+extract( hour from retention) *60+extract( minute from retention ) retention_interval, topnsql
from dba_hist_wr_control;

• Se coloca el Interval a 0
exec dbms_workload_repository.modify_snapshot_settings(interval=>0);

• Valor después de deshabilitar el snapshot collection del AWR:
 select extract( day from snap_interval) *24*60+extract( hour from snap_interval) *60+extract( minute from snap_interval ) snapshot_interval,extract( day from r 2 etention) *24*60+extract( hour from retention) *60+extract( minute from retention ) retention_interval, topnsql from dba_hist_wr_control;


* Drop AWR snapshots in range 
EXEC dbms_workload_repository.drop_snapshot_range (low_snap_id=>1107, high_snap_id=>1108);


---------------------------------------------------------------------

Habilitar Statpack
 
Step 1: Create the perfstat Tablespace
create tablespace perfstat datafile '/u03/oradata/prodb1/perfstat.dbf' size 500m;

Step 2: Run the create Script

 statscre.sql script      
 Install Prerequisites
Note that you must have performed the following before attempting to install STATSPACK:

1.      Run catdbsyn.sql when connected as SYS.
2.      Run dbmspool.sql when connected as SYS.
3.      Allocate a tablespace called perfstat with at least 180 megabytes of storage.
 
Step 3: Test the STATSPACK Install
execute statspack.snap;

Step 4: Schedule Automatic STATSPACK Data Collections

@spauto.sql
execute dbms_job.submit(:jobno, 'statspack.snap;',trunc(sysdate+1/24,'HH'), 'trunc(SYSDATE+1/24,''HH'')', TRUE, :instno);

select extract( day from snap_interval) *24*60+ extract( hour from snap_interval) *60+ extract( minute from snap_interval ) "Snapshot Interval", extract( day from retention) *24*60+ extract( hour from retention) *60+ extract( minute from retention ) "Retention Interval" from dba_hist_wr_control;

//////////////////////////////////////////////////////
más facil  Statpack


1. Lo primero es crearle un TS dedicado: Por ejemplo buscar una ruta con espacio en:
create tablespace perfstat datafile '/u01/app/oracle/product/12.1.0/db_3/rdbms/admin/perfstat.dbf' size 1500m;

2.  sqlplus / as sysdba
SQL> @spcreate
Choose the PERFSTAT user's password
Choose the Default tablespace for the PERFSTAT user
hoose the Temporary tablespace for the PERFSTAT user

3. Ejecutar un snapshot manual
SQL> execute statspack.snap

4. Programar un job automático
SQL> @spauto 
 



*********
*
*SQL> alter database mount standby database;

Database altered.

SQL> alter database mount standby database;
alter database mount standby database
*
ERROR at line 1:
ORA-01100: database already mounted


alter database recover managed standby database disconnect from session;


SQL> RECOVER STANDBY DATABASE
  /export/zonas/z1_os_unicorn/root/DBData/DBArch/unicorn/archive/*
  
  /export/zonas/z1_os_unicorn/root/Backup
  
alter database register physical logfile '/DBData/DBArch/unicorn/stdby_archive/arch_1_690192.arc';  

startup nomount;
alter database mount standby database;
ALTER DATABASE RECOVER MANAGED STANDBY DATABASE DISCONNECT FROM SESSION;


select process, thread#, sequence#, status from v$managed_standby where process='MRP0';


****
select max(sequence#) from v$archived_log where applied='YES';
****
*
SELECT PROCESS, STATUS, THREAD#, SEQUENCE#, BLOCK#, BLOCKS FROM V$MANAGED_STANDBY;

ALTER DATABASE REGISTER LOGFILE '/DBData/DBArch/unicorn/stdby_archive/arch_1_29340_902919362.arc';


                                               
recover managed standby database cancel; 
recover automatic standby database;


SELECT name, value FROM v$parameter WHERE name = 'spfile';


select extract( day from snap_interval) *24*60+extract( hour from snap_interval) *60+extract( minute from snap_interval ) snapshot_interval,
extract( day from retention) *24*60+extract( hour from retention) *60+extract( minute from retention ) retention_interval,
topnsql from dba_hist_wr_control;

--------------------------------------------

Archivelog generado por hora
SELECT to_date(first_time) DAY,
to_char(sum(decode(to_char(first_time,'HH24'),'00',1,0)),'99') "00",
to_char(sum(decode(to_char(first_time,'HH24'),'01',1,0)),'99') "01",
to_char(sum(decode(to_char(first_time,'HH24'),'02',1,0)),'99') "02",
to_char(sum(decode(to_char(first_time,'HH24'),'03',1,0)),'99') "03",
to_char(sum(decode(to_char(first_time,'HH24'),'04',1,0)),'99') "04",
to_char(sum(decode(to_char(first_time,'HH24'),'05',1,0)),'99') "05",
to_char(sum(decode(to_char(first_time,'HH24'),'06',1,0)),'99') "06",
to_char(sum(decode(to_char(first_time,'HH24'),'07',1,0)),'99') "07",
to_char(sum(decode(to_char(first_time,'HH24'),'08',1,0)),'99') "08",
to_char(sum(decode(to_char(first_time,'HH24'),'09',1,0)),'99') "09",
to_char(sum(decode(to_char(first_time,'HH24'),'10',1,0)),'99') "10",
to_char(sum(decode(to_char(first_time,'HH24'),'11',1,0)),'99') "11",
to_char(sum(decode(to_char(first_time,'HH24'),'12',1,0)),'99') "12",
to_char(sum(decode(to_char(first_time,'HH24'),'13',1,0)),'99') "13",
to_char(sum(decode(to_char(first_time,'HH24'),'14',1,0)),'99') "14",
to_char(sum(decode(to_char(first_time,'HH24'),'15',1,0)),'99') "15",
to_char(sum(decode(to_char(first_time,'HH24'),'16',1,0)),'99') "16",
to_char(sum(decode(to_char(first_time,'HH24'),'17',1,0)),'99') "17",
to_char(sum(decode(to_char(first_time,'HH24'),'18',1,0)),'99') "18",
to_char(sum(decode(to_char(first_time,'HH24'),'19',1,0)),'99') "19",
to_char(sum(decode(to_char(first_time,'HH24'),'20',1,0)),'99') "20",
to_char(sum(decode(to_char(first_time,'HH24'),'21',1,0)),'99') "21",
to_char(sum(decode(to_char(first_time,'HH24'),'22',1,0)),'99') "22",
to_char(sum(decode(to_char(first_time,'HH24'),'23',1,0)),'99') "23"
from
v$log_history
where to_date(first_time) > sysdate -8
GROUP by
to_char(first_time,'YYYY-MON-DD'), to_date(first_time)
order by to_date(first_time)
/


-- Utilisation (MB) du FRA
set lines 100
col name format a60
 
select
   name,
  floor(space_limit / 1024 / 1024) "Size MB",
  ceil(space_used / 1024 / 1024) "Used MB"
from v$recovery_file_dest;
 
-- FRA Occupants
SELECT * FROM V$FLASH_RECOVERY_AREA_USAGE;
 
-- Location and size of the FRA
show parameter db_recovery_file_dest
 
-- Size, used, Reclaimable 
SELECT
  ROUND((A.SPACE_LIMIT / 1024 / 1024 / 1024), 2) AS FLASH_IN_GB, 
  ROUND((A.SPACE_USED / 1024 / 1024 / 1024), 2) AS FLASH_USED_IN_GB, 
  ROUND((A.SPACE_RECLAIMABLE / 1024 / 1024 / 1024), 2) AS FLASH_RECLAIMABLE_GB,
  SUM(B.PERCENT_SPACE_USED)  AS PERCENT_OF_SPACE_USED
FROM
  V$RECOVERY_FILE_DEST A,
  V$FLASH_RECOVERY_AREA_USAGE B
GROUP BY
  SPACE_LIMIT, 
  SPACE_USED , 
  SPACE_RECLAIMABLE ;



****************************************************
*
*Recipe #1 - find blocking sessions with v$session
SELECT
   s.blocking_session, 
   s.sid, 
   s.serial#, 
   s.seconds_in_wait
FROM
   v$session s
WHERE
   blocking_session IS NOT NULL
Recipe #2 - find blocking sessions using v$lock
SELECT 
   l1.sid || ' is blocking ' || l2.sid blocking_sessions
FROM 
   v$lock l1, v$lock l2
WHERE
   l1.block = 1 AND
   l2.request > 0 AND
   l1.id1 = l2.id1 AND
   l1.id2 = l2.id2
Recipe #3 - blocking sessions with all available information
The next query prints a few more information, it let's you quickly see who's blocking who. Run this query and you can immediately call the colleague who's locking your table:

SELECT s1.username || '@' || s1.machine
    || ' ( SID=' || s1.sid || ' )  is blocking '
    || s2.username || '@' || s2.machine || ' ( SID=' || s2.sid || ' ) ' AS blocking_status
    FROM v$lock l1, v$session s1, v$lock l2, v$session s2
    WHERE s1.sid=l1.sid AND s2.sid=l2.sid
    AND l1.BLOCK=1 AND l2.request > 0
    AND l1.id1 = l2.id1
    AND l1.id2 = l2.id2
Recipe #4 - identifying blocked objects
The view v$lock we've already used in the queries above exposes even more information. There are differnet kind of locks - check this site for a complete list: http://download.oracle.com/docs/cd/B13789_01/server.101/b10755/dynviews_1123.htm#sthref3198

If you encounter a TM lock is means that two sessions are trying to modify some data but blocking each other. Unless one sessions finished (commit or rollback), you'll never have to wait forever.

The following queries shows you all the TM locks:

SELECT sid, id1 FROM v$lock WHERE TYPE='TM'
SID	ID1
92	20127
51	20127
The ID you get from this query refers to the actual database object which can help you to identify the problem, look at the next query:

SELECT object_name FROM dba_objects WHERE object_id=20127
There queries should help you to identify the cause of your blocking sessions!



×,.·´¨'°÷·..§  CONSULTAS ÚTILES RELACIONADAS CON EL UNDO §.·´¨'°÷·..×
 no ORA-1555 or ORA-30036 errors are reported


I'll try to expose the workflow of undo extents.
The undo tablespace, has undo segments.
The each undo segment is composed by undo extents.

When transactions hit a database and they need undo space the allocation happens in the following sequence:
1. Allocate an extent in an undo segment which has no active transaction. Oracle tries to distribute transactions over all undo segments.
2. If no undo segment found then oracle tries to set online an off-line undo segment and use it.
3. If no undo segments can be set to online, then we create a new undo segment and use it.
4. If space does not permit creation of undo segment, then we try to reuse an expired extent from the existing undo segments.

For a running transaction associated with undo segment/ extent, if it needs more undo space then:
1. If the current extent has more free blocks then use the next free block that is already allocated to the extent.
2. If the current extent does not have free blocks and if the next extent of the segment has expired then wrap in the the next extent and return the first block.
3. If the next extent has not expired then get space from the UNDO tablespace. If a free extent is available then allocate it to the undo segment and return the first block in the new extent.
4. If there is no free extent available then steal from an offline undo segment. Deallocate the extent from the offline undo segment and add it to the current undo segment. Return the first free block of the extent.
5. Steal from online undo segment. Deallocate the extent from the online undo segment and add it to the current undo segment. Return the first free block of the extent.
6. Extend the file in the UNDO tablespace. If the file can be extended then add an extent to the current undo segment then return the block.
7. Otherwise try to reuse unexpired extents from own undo segment. If all extents are currently busy(they contains uncommitted information) go to the step 8. Otherwise wrap into the next extent.
8. Randomly steal unexpired extents from offline undo segments. If this fails then try to online undo segments for reuse.
9. If all the above fails then return ORA-30036 unable to extend segment by %s in undo tablespace '%s'

On your query you can see the status of each extent:
Active: Extents that are currently in use
Unexpired: This represents the extents which are required to satisfy the time specified by Undo_retention Initialisation parameter.
Expired: These are extents which are not being used by transaction and have crossed the time specified by Undo_retention .

Does it means that you have
8M(Active)+153M(Unexpired)=161M Busy
3599M(Expired)= Free, and can be reutilized.
Then you have 3599Mb free to use on UNDO without need to expand the undo_tablespace.

Your settings:
undo_management string AUTO
undo_retention integer 1800
undo_suppress_errors boolean FALSE
undo_tablespace string UNDO

SQL> select count(segment_name),sum(bytes/1024/1024),status from dba_undo_extents group by status
2 /

COUNT(SEGMENT_NAME) SUM(BYTES/1024/1024) STATUS
------------------- -------------------- ---------
1 8 ACTIVE
1116 3599.67578 EXPIRED
601 153.375 UNEXPIRED

Reference: Troubleshooting ORA-30036 - Unable To Extend Undo Tablespace [ID 460481.1]

I hope you find it helps

La siguiente consulta busca una sesión de usuario que está en el undo para poderla matar…

column username format a30

SELECT a.name,b.status , d.username , d.sid , d.serial#
FROM   v$rollname a,v$rollstat b, v$transaction c , v$session d
WHERE  a.usn = b.usn
AND    a.usn = c.xidusn
AND    c.ses_addr = d.saddr
AND    a.name IN (
    SELECT segment_name
    FROM dba_segments
    WHERE tablespace_name = 'UNDOTBS1'
   );
Para matar la sesión ejecutaremos:
 SQL>  alter system kill session '147,4';
 donde 147 es el SID y 4 el SERIAL#
# Con la siguiente query podemos ver el estado de los segmentos de UNDO:
# UNEXPIRED significa que estos segmentos de UNDO no contienen ninguna transacción activa,
# pero estos contienen transacciones que todavía son requeridos para FLASHBACK.
# EXPIRED significa que estos segmentos no son requeridos después del periodo de retención definido en undo_retention.
# ACTIVE significa que estos segmentos de UNDO contienen transacciones activas, o sea, no se ha realizado commit.
# Los valores son en MB.  

SELECT SYSDATE AS fecha,
       unexpired.unexpired,
       expired.expired,
       active.active
FROM   (SELECT Sum(bytes / 1024 / 1024) AS unexpired
        FROM   dba_undo_extents
        WHERE  status = 'UNEXPIRED') unexpired,
       (SELECT Sum(bytes / 1024 / 104) AS expired
        FROM   dba_undo_extents tr
        WHERE  status = 'EXPIRED') expired,
       (SELECT CASE
                 WHEN Count(status) = 0
                 THEN 0
                 ELSE Sum(bytes / 1024 / 1024)
               END AS active
        FROM   dba_undo_extents
        WHERE  status = 'ACTIVE') active
/
# Buscar la sesión que está colgada o pendiente de ponerse a OFFLINE en TS UNDO para luego matarla

set lines 10000
column name format a10

SELECT a.name,b.status
FROM   v$rollname a,v$rollstat b
WHERE  a.usn = b.usn
AND    a.name IN (
    SELECT segment_name
    FROM dba_segments
    WHERE tablespace_name = 'UNDOTBS1'
   );
# Transacciones activas en TS UNDO

SELECT NAME, XACTS "ACTIVE TRANSACTIONS"
FROM V$ROLLNAME, V$ROLLSTAT
WHERE STATUS = 'PENDING OFFLINE'
AND V$ROLLNAME.USN = V$ROLLSTAT.USN;

 
-- Consulta sesiones Activas
set pages 9999;
set linesize 1000;
select sid,SERIAL#, username, machine ,program,module, round (last_call_et/60,2) minutos, action, sql_id,event,PROCESS
from v$session a
where status='ACTIVE'
and username is not null
order by last_call_et desc;


 
•• Query por particiones

select * from  pos_data partition for (to_date('15-AUG-2007','dd-mon-yyyy'));

•• QUERY tamaño particiones 

SELECT owner, segment_name, segment_type, partition_name, ROUND(bytes/(1024*1024*1024),2) SIZE_GB, tablespace_name 
FROM DBA_SEGMENTS 
WHERE SEGMENT_TYPE IN ('TABLE', 'TABLE PARTITION', 'TABLE SUBPARTITION','INDEX', 'INDEX PARTITION', 'INDEX SUBPARTITION', 'TEMPORARY', 'LOBINDEX', 'LOBSEGMENT', 'LOB PARTITION')
AND TABLESPACE_NAME LIKE '%TBS_BASE%' 
AND SEGMENT_NAME in ('DWD_RAW_DATA_DAY_CWP',
'DWB_WRLS_CALL_EVT',
'DWB_RAW_WRLS_CALL_EVT',
'DWB_CNTNT_DLVRY_EVT_ARCV',
'DWD_SBCRBR_BASE_DTL_HIST_CWP',
'DWB_CHARGING_DEDICATED_ACCT',
'DWB_FIXED_LN_CALL_EVT',
'DWB_CHARGING_STAT',
'DWB_DIGITAL_HARVEST',
'DWD_RAW_VOICE_DAY_CWP') 
--AND partition_name LIKE 'P20100201%'
--AND segment_type = 'TABLE'
AND OWNER = 'OCDM_SYS' 
--AND ROUND(bytes/(1024*1024),2) > 1000 
ORDER BY partition_name ASC;  


--Forecast
-- File: tbs_forecast.sql
-- Description: OEM Tablespace Forecast
-- Author: Raul Ibanez (raul @ dbajunior.com)
-- Gracias a Facundo por retocar la query para evitar los grupos
 
WITH rl AS (
 SELECT
 --G.COMPOSITE_TARGET_NAME,
 --CASE G.COMPOSITE_TARGET_NAME
 -- WHEN 'prod_group' THEN '80'
 -- WHEN 'nonprod_group' THEN '90'
 -- ELSE '90'
 --END
 '85' THRESHOLD,
 T.TARGET_NAME,
 M.KEY_VALUE TABLESPACE,
 REGR_SLOPE(M.VALUE_AVERAGE, ((M.ROLLUP_TIMESTAMP - to_date('1970-01-01 00:00:00','YYYY-MM-DD HH24:MI:SS')) * 86400)) SLOPE,
 REGR_INTERCEPT(M.VALUE_AVERAGE, ((M.ROLLUP_TIMESTAMP - to_date('1970-01-01 00:00:00','YYYY-MM-DD HH24:MI:SS')) * 86400)) YINTERCEPT,
 M.METRIC_GUID,
 M.TARGET_GUID,
 C.VALUE CURRENT_PERC
 FROM
  sysman.MGMT_METRICS_1DAY M,
  sysman.MGMT_TARGETS T,
 --MGMT$GROUP_FLAT_MEMBERSHIPS G,
 sysman.MGMT_CURRENT_METRICS C
 WHERE
 -- Metric D34E49F7B030C38C5DBEB6C62D4CAFA8 => TBS SPACE USED (MB) / Collected every week
 M.METRIC_GUID = HEXTORAW('D34E49F7B030C38C5DBEB6C62D4CAFA8') AND
 -- Metric 3E6F70DB22758B7B9756EF342180E7BB => TBS SPACE USED (%)
 C.METRIC_GUID = HEXTORAW('3E6F70DB22758B7B9756EF342180E7BB') AND
 M.KEY_VALUE = C.KEY_VALUE AND
 M.ROLLUP_TIMESTAMP >= SYSDATE-60 AND
 M.TARGET_GUID = T.TARGET_GUID AND
 T.TARGET_GUID = C.TARGET_GUID AND
 --G.MEMBER_TARGET_GUID = M.TARGET_GUID AND
 --G.COMPOSITE_TARGET_NAME = 'prod_group' AND -- Filter OEM Group
 --T.TARGET_NAME NOT LIKE '%dr%' AND -- Filter Target Name
 --G.COMPOSITE_TARGET_TYPE = 'composite' AND
 M.KEY_VALUE NOT LIKE 'UNDOTBS%' AND -- Filter Tablespace Name
 M.KEY_VALUE NOT LIKE '%TEMP%'
 GROUP BY
 T.TARGET_NAME, M.KEY_VALUE, M.METRIC_GUID, M.TARGET_GUID, C.VALUE
)
SELECT
 TARGET_NAME,
 TABLESPACE,
 THRESHOLD "THRESHOLD %",
 -- SLOPE,
 -- YINTERCEPT,
 ROUND(CURRENT_PERC,2) "CURR%",
 ROUND(((((((SYSDATE+31) - to_date('1970-01-01 00:00:00','YYYY-MM-DD HH24:MI:SS')) * 86400) * SLOPE + YINTERCEPT)* CURRENT_PERC) /
 ((((SYSDATE) - to_date('1970-01-01 00:00:00','YYYY-MM-DD HH24:MI:SS')) * 86400) * SLOPE + YINTERCEPT)),2) "NEXT1M%",
 ROUND(((((((SYSDATE+138) - to_date('1970-01-01 00:00:00','YYYY-MM-DD HH24:MI:SS')) * 86400) * SLOPE + YINTERCEPT)* CURRENT_PERC) /
 ((((SYSDATE) - to_date('1970-01-01 00:00:00','YYYY-MM-DD HH24:MI:SS')) * 86400) * SLOPE + YINTERCEPT)),2) "NEXT6M%",
 ROUND(((((((SYSDATE+365) - to_date('1970-01-01 00:00:00','YYYY-MM-DD HH24:MI:SS')) * 86400) * SLOPE + YINTERCEPT)* CURRENT_PERC) /
 ((((SYSDATE) - to_date('1970-01-01 00:00:00','YYYY-MM-DD HH24:MI:SS')) * 86400) * SLOPE + YINTERCEPT)),2) "NEXT12M%",
 ROUND((((SYSDATE) - to_date('1970-01-01 00:00:00','YYYY-MM-DD HH24:MI:SS')) * 86400) * SLOPE + YINTERCEPT) "CURR(MB)",
 ROUND((((SYSDATE+31) - to_date('1970-01-01 00:00:00','YYYY-MM-DD HH24:MI:SS')) * 86400) * SLOPE + YINTERCEPT) "NEXT1M(MB)",
 ROUND((((SYSDATE+138) - to_date('1970-01-01 00:00:00','YYYY-MM-DD HH24:MI:SS')) * 86400) * SLOPE + YINTERCEPT) "NEXT6M(MB)",
 ROUND((((SYSDATE+365) - to_date('1970-01-01 00:00:00','YYYY-MM-DD HH24:MI:SS')) * 86400) * SLOPE + YINTERCEPT) "NEXT12M(MB)",
 '+' || TO_CHAR(ROUND(((100*((((SYSDATE+365) - to_date('1970-01-01 00:00:00','YYYY-MM-DD HH24:MI:SS')) * 86400) * SLOPE + YINTERCEPT)/(THRESHOLD-10))-
 (100*((((SYSDATE) - to_date('1970-01-01 00:00:00','YYYY-MM-DD HH24:MI:SS')) * 86400) * SLOPE + YINTERCEPT)/CURRENT_PERC))/1024))||'GB' "REQ 12M"
FROM rl
WHERE
 SLOPE > 0 AND
 ROUND(((((((SYSDATE+365) - to_date('1970-01-01 00:00:00','YYYY-MM-DD HH24:MI:SS')) * 86400) * SLOPE + YINTERCEPT)* CURRENT_PERC) /
 ((((SYSDATE) - to_date('1970-01-01 00:00:00','YYYY-MM-DD HH24:MI:SS')) * 86400) * SLOPE + YINTERCEPT)),2) > THRESHOLD
ORDER BY
 ROUND(((100*((((SYSDATE+365) - to_date('1970-01-01 00:00:00','YYYY-MM-DD HH24:MI:SS')) * 86400) * SLOPE + YINTERCEPT)/(THRESHOLD-10))-
 (100*((((SYSDATE) - to_date('1970-01-01 00:00:00','YYYY-MM-DD HH24:MI:SS')) * 86400) * SLOPE + YINTERCEPT)/CURRENT_PERC))/1024) DESC;




--   obtain the Historical Database Total Used and Allocated Size from OEM Repository
--   crecimiento de BD histórico - growth 
 SELECT Database,
Month_Date,
round(sum(decode(metric_column, 'spaceUsed', maximum))/1024/1024, 3) Used_Size_Tb,
round(sum(decode(metric_column, 'spaceAllocated', maximum))/1024/1024, 3) Allocated_Size_Tb
FROM
(
SELECT target_name Database, trunc(rollup_timestamp, 'MONTH') Month_Date, key_value TB, metric_column, round(max(maximum),0) maximum
FROM sysman.mgmt$metric_daily
WHERE 
--target_type = 'rac_database'
metric_name = 'tbspAllocation'
and metric_column in ('spaceAllocated', 'spaceUsed')
--and target_name in ('VERS')
GROUP BY target_name, key_value, trunc(rollup_timestamp, 'MONTH'), metric_column
)
GROUP BY Database, Month_Date
ORDER BY Database, Month_Date
/

Helps DBA to find out quickly which database takes a lot of space and which file could be shrunk. Very useful when output is sorted by Drive Letter when "Out of space" occurs.

Author: Leonid Sheinkman

	/*
Author: Leonid Sheinkman
Created: 2009-01-12
Updated: 2013-02-15

This script use undocumented DBCC showfilestats command */ 

USE master GO

SET NOCOUNT ON
DECLARE @Kb float
DECLARE @PageSize float
DECLARE @SQL varchar(max)

SELECT @Kb = 1024.0
SELECT @PageSize=v.low/@Kb FROM master..spt_values v WHERE v.number=1 AND v.type='E'

IF OBJECT_ID('tempdb.dbo.#FileSize') IS NOT NULL  DROP TABLE #FileSize CREATE TABLE #FileSize (  DatabaseName sysname,  [FileName] varchar(max),  FileSize int,  FileGroupName varchar(max),  LogicalName varchar(max)
)

IF OBJECT_ID('tempdb.dbo.#FileStats') IS NOT NULL  DROP TABLE #FileStats CREATE TABLE #FileStats (  FileID int,  FileGroup int,  TotalExtents int,  UsedExtents int,  LogicalName varchar(max),  FileName varchar(max)
)

IF OBJECT_ID('tempdb.dbo.#LogSpace') IS NOT NULL  DROP TABLE #LogSpace CREATE TABLE #LogSpace (  DatabaseName sysname,  LogSize float,  SpaceUsedPercent float,  Status bit
)

INSERT #LogSpace EXEC ('DBCC sqlperf(logspace)')

DECLARE @DatabaseName sysname

DECLARE cur_Databases CURSOR FAST_FORWARD FOR  SELECT DatabaseName = [name] FROM dbo.sysdatabases WHERE [name] <> 'RVR_FSA' ORDER BY DatabaseName OPEN cur_Databases FETCH NEXT FROM cur_Databases INTO @DatabaseName WHILE @@FETCH_STATUS = 0
  BEGIN
 print @DatabaseName
 SET @SQL = '
USE [' + @DatabaseName + '];
DBCC showfilestats;
INSERT #FileSize (DatabaseName, [FileName], FileSize, FileGroupName, LogicalName) SELECT ''' +@DatabaseName + ''', filename, size, ISNULL(FILEGROUP_NAME(groupid),''LOG''), [name]  FROM dbo.sysfiles sf; '
PRINT @SQL
 INSERT #FileStats EXECUTE (@SQL)
 FETCH NEXT FROM cur_Databases INTO @DatabaseName
  END

CLOSE cur_Databases
DEALLOCATE cur_Databases


SELECT
 DatabaseName = fsi.DatabaseName,
 FileGroupName = fsi.FileGroupName,
 LogicalName = RTRIM(fsi.LogicalName),
 [FileName] = RTRIM(fsi.FileName),
 DriveLetter = LEFT(RTRIM(fsi.FileName),2),  FileSize = CAST(fsi.FileSize*@PageSize/@Kb as decimal(15,2)),  UsedSpace = CAST(ISNULL((fs.UsedExtents*@PageSize*8.0/@Kb), fsi.FileSize*@PageSize/@Kb * ls.SpaceUsedPercent/100.0) as decimal(15,2)),  FreeSpace = CAST(ISNULL(((fsi.FileSize - UsedExtents*8.0)*@PageSize/@Kb), (100.0-ls.SpaceUsedPercent)/100.0 * fsi.FileSize*@PageSize/@Kb) as decimal(15,2)),  [FreeSpace %] = CAST(ISNULL(((fsi.FileSize - UsedExtents*8.0) / fsi.FileSize * 100.0), 100-ls.SpaceUsedPercent) as decimal(15,2))  FROM #FileSize fsi  LEFT JOIN #FileStats fs  ON fs.FileName = fsi.FileName  LEFT JOIN #LogSpace ls  ON ls.DatabaseName = fsi.DatabaseName  ORDER BY 5, 8 DESC

--SQL  Server - File Growth...
SET NOCOUNT ON
CREATE TABLE ##tbl_DataSize
		(
		Size	DECIMAL(20)
		)

CREATE TABLE #tbl_GrowthData
		(
		 DatabaseName					VARCHAR(50)
		,NoSampleDays					DECIMAL(20,3)
		,DataSizeMB					DECIMAL(20,3)
		,LogSizeMB					DECIMAL(20,3)
		,BackupSizeMB					DECIMAL(20,3)
		,TotalSpaceMB					DECIMAL(20,3)
		,DataGrowth					DECIMAL(20,3)
		,LogGrowth					DECIMAL(20,3)
		,GrowthPercentage				DECIMAL(20,3)
		)

DECLARE 
	 @iNoSamples		INT
	,@nMaxBackupSize	DECIMAL
	,@nMinBackupSize	DECIMAL
	,@nMaxLogSize		DECIMAL
	,@nMinLogSize		DECIMAL
	,@nMaxDataSize		DECIMAL
	,@nMinDataSize		DECIMAL
	,@vcDatabaseName	VARCHAR(50)
	,@dtMaxBackupTime	DATETIME
	,@dtMinBackupTime	DATETIME
	,@iMinBackupID		INT
	,@iMaxBackupID		INT
	
DECLARE file_cursor CURSOR FOR
SELECT [name] FROM master.dbo.sysdatabases
ORDER BY [name]
OPEN file_cursor

   FETCH NEXT FROM file_cursor
   INTO @vcDatabaseName

WHILE @@FETCH_STATUS = 0
BEGIN  

SET @dtMaxBackupTime = (SELECT MAX(backup_finish_date)FROM msdb.dbo.backupset WHERE database_name = @vcDatabaseName AND [type] = 'D')
SET @dtMinBackupTime = (SELECT MIN(backup_finish_date)FROM msdb.dbo.backupset WHERE database_name = @vcDatabaseName AND [type] = 'D')
SET @iNoSamples =	
	DATEDIFF 
		( 
		  dd
		 ,@dtMinBackupTime
		 ,@dtMaxBackupTime
		)

SET @nMaxBackupSize	= (SELECT backup_size FROM msdb.dbo.backupset WHERE database_name = @vcDatabaseName AND [type] = 'D' AND backup_finish_date = @dtMaxBackupTime)
SET @nMinBackupSize	= (SELECT backup_size FROM msdb.dbo.backupset WHERE database_name = @vcDatabaseName AND [type] = 'D' AND backup_finish_date = @dtMinBackupTime)

SET @iMaxBackupID	= (SELECT MAX(backup_set_id) FROM msdb.dbo.backupset WHERE database_name = @vcDatabaseName AND [type] = 'D' AND backup_finish_date = @dtMaxBackupTime)
SET @iMinBackupID	= (SELECT MAX(backup_set_id) FROM msdb.dbo.backupset WHERE database_name = @vcDatabaseName AND [type] = 'D' AND backup_finish_date = @dtMinBackupTime)

SET @nMaxLogSize	= (SELECT ((CAST((SUM(file_size)) AS DECIMAL(20,3))) /  1048576) FROM msdb.dbo.backupfile	WHERE backup_set_id = @iMaxBackupID AND file_type = 'L')
SET @nMinLogSize	= (SELECT ((CAST((SUM(file_size)) AS DECIMAL(20,3))) /  1048576) FROM msdb.dbo.backupfile	WHERE backup_set_id = @iMinBackupID AND file_type = 'L')
SET @nMaxDataSize	= (SELECT ((CAST((SUM(file_size)) AS DECIMAL(20,3))) /  1048576) FROM msdb.dbo.backupfile	WHERE backup_set_id = @iMaxBackupID AND file_type = 'D')
SET @nMinDataSize	= (SELECT ((CAST((SUM(file_size)) AS DECIMAL(20,3))) /  1048576) FROM msdb.dbo.backupfile	WHERE backup_set_id = @iMinBackupID AND file_type = 'D')

EXEC ('
INSERT INTO ##tbl_DataSize
SELECT CAST((SUM(size)) as DECIMAL(20,3)) FROM '+@vcDatabaseName+'.dbo.sysfiles'
)

INSERT INTO #tbl_GrowthData
SELECT 
	 @vcDatabaseName DatabaseName
	,@iNoSamples NoSampleDays
	,@nMaxDataSize
	,@nMaxLogSize
	,@nMaxBackupSize / 1048576
	,((size * 8192) / 1048576) TotalSpaceUsed  
	,@nMaxDataSize - @nMinDataSize
	,@nMaxLogSize  - @nMinLogSize
	,(((@nMaxDataSize + @nMaxLogSize) - (@nMinDataSize+ @nMinLogSize)) / (@nMinDataSize+ @nMinLogSize)) * 100.00
	--growth percentage is calculated based upon the original data size, before the growth. as a result it may look a little funny, but it is accurate. or at least I think so :)
FROM ##tbl_DataSize

	TRUNCATE TABLE ##tbl_DataSize

   FETCH NEXT FROM file_cursor
   INTO @vcDatabaseName

END
CLOSE file_cursor
DEALLOCATE file_cursor

SELECT 
	*
FROM #tbl_GrowthData

DROP TABLE ##tbl_DataSize
DROP TABLE #tbl_GrowthData

SET NOCOUNT OFF


###############################################################################################33
      TRUNCATE TABLE DEMORA MUCHO-----POSBILE  SESION  CON LA TABLA ABIERTA..IDENTIFICAR CUAL ES-


declare @tablename sysname

select @tablename = 'Staging.dbo.salesforce_agrupada'

select convert (smallint, req_spid) As spid,

rsc_dbid As dbid,

rsc_objid As ObjId,

rsc_indid As IndId,

substring (v.name, 1, 4) As Type,

substring (rsc_text, 1, 32) as Resource,

substring (u.name, 1, 8) As Mode,

substring (x.name, 1, 5) As Status

from master.dbo.syslockinfo,

master.dbo.spt_values v,

master.dbo.spt_values x,

master.dbo.spt_values u

where master.dbo.syslockinfo.rsc_type = v.number

and v.type = 'LR'

and master.dbo.syslockinfo.req_status = x.number

and x.type = 'LS'

and master.dbo.syslockinfo.req_mode + 1 = u.number

and u.type = 'L'

and rsc_objid = object_id(@tablename)

###############################################################################################33

 
 --Generar password o contraseña aleatoria - random   en Linux
tr -dc A-Za-z0-9 < /dev/urandom | head -c 8 | xargs

Incluye 10 y caracteres especiales
tr -dc A-Za-z0-9:#%_!=: < /dev/urandom | head -c 10 | xargs

--Generar password o contraseña aleatoria - random  SOLARIS

perl -e 'print [0..9,a..z,A..Z,qw{- _ / & ?}]->[rand 67]for 0..10'

perl -e 'print[0..9,a..z,A..Z]->[rand 62]for 1..10'
                                                          
 
 -Sofar en SQL Server
 SELECT
	session_id,
	start_time,
	status,
	command,
	percent_complete,
	estimated_completion_time,
	estimated_completion_time /60/1000 as estimate_completion_minutes,
	--(select convert(varchar(5),getdate(),8)),
	DATEADD(n,(estimated_completion_time /60/1000),GETDATE()) as estimated_completion_time
FROM    sys.dm_exec_requests where command = 'BACKUP DATABASE' OR command = 'RESTORE DATABASE'

--ubicación de todos los datafiles en SQL Server
SELECT name, physical_name AS current_file_location
FROM sys.master_files

SELECT name,filename from sysdatabases 

SELECT * from sysdatabases 

--ubicación de todos  las unidades en donde están los datafiles en SQL Server
SELECT distinct substring(physical_name,1,1 ) AS current_file_location
FROM sys.master_files
  

SELECT *
FROM sys.master_files


SELECT s.sid, s.serial#,p.spid as "OS PID",s.username,s.module,st.value/100 as "CPU sec"
FROM v$sesstat st, v$statname sn, v$session s, v$process p
WHERE sn.name = 'CPU used by this session' -- CPU
AND st.statistic# = sn.statistic#
AND st.sid = s.sid
AND s.paddr = p.addr
AND s.last_call_et < 1800 -- active within last 1/2 hour
AND s.logon_time > (SYSDATE - 240/1440) -- sessions logged on within 4 hours
ORDER BY st.value desc;

--Identificación del nombre de la Bd, el nombre lógico  del datafile y su ubicación física
SELECT DB_NAME(database_id) AS DatabaseName, name AS LogicalFileName, physical_name AS PhysicalFileName 
FROM sys.master_files AS mf
where physical_name like 'C:%'


--Buscar tamaño de Diskgroup DG sin tener que ir a asmcmd --- para hacer lsdg

SELECT name, free_mb, total_mb, free_mb/total_mb*100 as percentage 
     FROM v$asm_diskgroup;

--RAC QUeries
Quite a good script which provides a lot of information in one go

clear columns
                      

set wrap off
set lines 200
set pages 999
col "Group"        form 999
col "Group Name"   form a25
col "Disk Name"    form a30
col "State"  form a15
col "Type"   form a7

prompt
prompt ASM Disk Groups 
prompt ===============
select group_number  "Group"
,      name          "Group Name"
,      state         "State"
,      type          "Type"
,      total_mb/1024 "Total GB"
,      free_mb/1024  "Free GB" 
from   v$asm_diskgroup 
/


prompt
prompt ASM Disks 
prompt =========

col "Group"          form 999       f
col "Disk"           form 999
col "Header"         form a9
col "Mode"           form a8
col "Redundancy"     form a10
col "Failure Group"  form a30
col "Path"           form a50
set linesize 200
set pagesize 500

select group_number  "Group"
,      disk_number   "Disk"
,      header_status "Header"
,      mode_status   "Mode"
,      state         "State"
,      redundancy    "Redundancy"
,      total_mb      "Total MB"
,      free_mb       "Free MB"
,      name          "Disk Name"
,      failgroup     "Failure Group"
,      path          "Path"
from   v$asm_disk
order by group_number
,        disk_number
/

prompt
prompt Instances currently accessing these diskgroups
prompt ==============================================
col "Instance" form a8
select c.group_number  "Group"
,      g.name          "Group Name"
,      c.instance_name "Instance"
from   v$asm_client c
,      v$asm_diskgroup g
where  g.group_number=c.group_number
/

prompt
prompt Current ASM disk operations
prompt ===========================
select *
from   v$asm_operation
/

clear columns



-------------------------
Space - Espacio en SQL SErver 

sp_helpdb

sp_helpdb Test5 

dBCC SQLPERF(logspace)

This dynamic management view collects all the information since the time when the SQL Server services have been restarted. You can also manually clear the wait stats using the following command:
DBCC SQLPERF('sys.dm_os_wait_stats', CLEAR);
Once the wait stats are collected, we can start analysis them and try to see what is causing any particular wait stats to achieve higher percentages than the others.
 

DBCC SHRINKFILE (test5) 
DBCC SHRINKFILE (test5_log) 

SQL SERVER 2000 - Fragmentacion


SELECT   'DBCC SHOWCONTIG (' + convert(VARCHAR,o.id) + ',' +

convert(VARCHAR,i.indid) + ') -- ' + object_name(o.id) + -- table name 

          '.' + i.name -- index name 

FROM     sysobjects o

         JOIN sysindexes i

           ON (o.id = i.id)

WHERE    o.xtype = 'U'

         AND i.rows > 0

ORDER BY object_name(o.id),

         i.indid

 

GO


--Con este query se puede generar las sentencias para poner a correr el dbcc contig para cada índice 

select 'dbcc showcontig ( ''FMOnline.dbo.' + (SO.Name +''', ''' + SI.name)+ ''')' Salida  
from sysobjects as SO
join sysindexes as SI 
on SO.Id = SI.id
join sysfilegroups as SFG 
on SI.GroupId = SFG.GroupId
order by SO.Name, SI.name



DBCC SHOWCONTIG (14623095,1) -- AppErrores.PK_AppErrores
DBCC SHOWCONTIG (2055678371,0) -- contrasena_usuarios.contrasena_usuarios
DBCC SHOWCONTIG (1879677744,0) -- Cuentas_Unicorn.Cuentas_Unicorn
DBCC SHOWCONTIG (2007678200,0) -- cuentasactivasunicorn.cuentasactivasunicorn
DBCC SHOWCONTIG (910626287,0) -- Cwp_Tmp_Cambios.Cwp_Tmp_Cambios
DBCC SHOWCONTIG (894626230,0) -- Cwp_UnionUsuarioSistemas.Cwp_UnionUsuarioSistemas
DBCC SHOWCONTIG (1822629536,0) -- DatosUsuarios.DatosUsuarios
DBCC SHOWCONTIG (1515152443,0) -- DatosUsuarios_Cesados.DatosUsuarios_Cesados
DBCC SHOWCONTIG (1934629935,0) -- DatosUsuarios_Expirados.DatosUsuarios_Expirados
DBCC SHOWCONTIG (1845581613,1) -- DetalleFactura.DetalleFactura_PK
DBCC SHOWCONTIG (1845581613,9) -- DetalleFactura.DetalleFactura_IDX1
DBCC SHOWCONTIG (1691153070,1) -- DetalleLlamadas.DetalleLlamadas_PKPP
DBCC SHOWCONTIG (1691153070,2) -- DetalleLlamadas.DetalleLlamadas_IDX1
DBCC SHOWCONTIG (718625603,1) -- Emails.PK_Emails
DBCC SHOWCONTIG (1531152500,0) -- Emails_Cesados.Emails_Cesados
DBCC SHOWCONTIG (1131151075,0) -- emails_old.emails_old
DBCC SHOWCONTIG (1195151303,0) -- emailsup.emailsup
DBCC SHOWCONTIG (519672899,1) -- EmailsXLS.PK_EmailsXLS
DBCC SHOWCONTIG (519672899,2) -- EmailsXLS.IX_Email
DBCC SHOWCONTIG (2025058250,1) -- Empresa.Empresa_PK
DBCC SHOWCONTIG (1541580530,1) -- Factura.Factura_PK
DBCC SHOWCONTIG (1541580530,13) -- Factura.Factura_IDX1
DBCC SHOWCONTIG (654625375,0) -- FechaEjecucion.FechaEjecucion
DBCC SHOWCONTIG (670625432,1) -- FMOSenderConf.PK_FMOSenderConf
DBCC SHOWCONTIG (1070626857,0) -- Load_tmp.Load_tmp
DBCC SHOWCONTIG (1669580986,1) -- Mensaje.PK_Mensaje
DBCC SHOWCONTIG (1669580986,7) -- Mensaje.Mensaje_IDX1
DBCC SHOWCONTIG (658101385,0) -- MyTable.MyTable
DBCC SHOWCONTIG (171147655,1) -- PiePagina.PK_PiePagina
DBCC SHOWCONTIG (171147655,2) -- PiePagina.PiePagina_IDX1
DBCC SHOWCONTIG (251147940,1) -- PreAfiliacion.PK_PreAfiliacion
DBCC SHOWCONTIG (1214627370,1) -- ResumenCuenta.ResumenCuenta_PK
DBCC SHOWCONTIG (1214627370,2) -- ResumenCuenta.ResumenCuenta_IDX1
DBCC SHOWCONTIG (1749581271,1) -- ResumenMes.ResumenMes_PK
DBCC SHOWCONTIG (1749581271,14) -- ResumenMes.ResumenMes_IDX1
DBCC SHOWCONTIG (615673241,1) -- Sender_FactEnviadasXLS.PK_Sender_FactEnviadasXLS
DBCC SHOWCONTIG (1163151189,1) -- SendLog.PK_SendLog
DBCC SHOWCONTIG (2043154324,1) -- SendLog2.PK_SendLog2
DBCC SHOWCONTIG (2057058364,1) -- Sistemas.Sistemas_PK
DBCC SHOWCONTIG (439672614,1) -- Solicitud_No_Impresion_No_Afiliado.PK_Solicitud_No_Impresion_No_Afiliado
DBCC SHOWCONTIG (699149536,0) -- SolicitudesBK.SolicitudesBK
DBCC SHOWCONTIG (859150106,1) -- SolicitudesUsuarios.PK_SolicitudesUsuarios
DBCC SHOWCONTIG (2018106230,0) -- Table1.Table1
DBCC SHOWCONTIG (1147151132,0) -- Tano.Tano
DBCC SHOWCONTIG (1678629023,0) -- Tano1.Tano1
DBCC SHOWCONTIG (1547152557,0) -- Temp_Cesados.Temp_Cesados
DBCC SHOWCONTIG (1079674894,0) -- temp_cuentas_sendfail.temp_cuentas_sendfail
DBCC SHOWCONTIG (295672101,0) -- Temporal_No_Afiliados_Unicorn.Temporal_No_Afiliados_Unicorn
DBCC SHOWCONTIG (695673526,0) -- Temporal_No_Afiliados_Unicorn_Borrar.Temporal_No_Afiliados_Unicorn_Borrar
DBCC SHOWCONTIG (1090102924,0) -- Tipo_Actividad.Tipo_Actividad
DBCC SHOWCONTIG (1074102867,0) -- Tipo_Usuarios.Tipo_Usuarios
DBCC SHOWCONTIG (1977058079,1) -- TipoUsuario.TipoUsuario_PK
DBCC SHOWCONTIG (651149365,0) -- TLog.TLogPagos
DBCC SHOWCONTIG (2110630562,0) -- TLogPagos_Pruebas.TLogPagos_Pruebas
DBCC SHOWCONTIG (635149308,0) -- TLogPagosbk.TLogPagosbk
DBCC SHOWCONTIG (1630628852,0) -- Tmes.Tmes
DBCC SHOWCONTIG (1662628966,0) -- TTipoCC.TTipoCC
DBCC SHOWCONTIG (834102012,1) -- UnionUsuarioSistemas.UnionUsuarioSistemas_PK
DBCC SHOWCONTIG (1483152329,0) -- UnionUsuarioSistemas_Cesados.UnionUsuarioSistemas_Cesados
DBCC SHOWCONTIG (1950629992,0) -- UnionUsuarioSistemas_Expirados.UnionUsuarioSistemas_Expirados
DBCC SHOWCONTIG (2119678599,1) -- Usuarios.PK_Usuarios
DBCC SHOWCONTIG (2119678599,2) -- Usuarios.usuarios_IDX1
DBCC SHOWCONTIG (1451152215,0) -- Usuarios_Cesados.Usuarios_Cesados
DBCC SHOWCONTIG (500196832,0) -- Usuarios_Desconfigurados.Usuarios_Desconfigurados
DBCC SHOWCONTIG (1982630106,0) -- Usuarios_Expirados.Usuarios_Expirados
DBCC SHOWCONTIG (1579152671,0) -- usuarios_match.usuarios_match
DBCC SHOWCONTIG (94623380,1) -- UsuariosActividades.PK_Usuarios_Log
DBCC SHOWCONTIG (1435152158,0) -- UsuariosActividades_Cesados.UsuariosActividades_Cesados
DBCC SHOWCONTIG (1966630049,0) -- UsuariosActividades_Expirados.UsuariosActividades_Expirados
DBCC SHOWCONTIG (27147142,1) -- UsuariosRechazados.PK_UsuariosRechazados
DBCC SHOWCONTIG (1067150847,1) -- Validations.PK_Validations
DBCC SHOWCONTIG (1755153298,1) -- vsSender_FactEnviadas.PK_vsSender_FactEnviadas
DBCC SHOWCONTIG (855674096,0) -- vsSender_FactEnviadas_ARCH.vsSender_FactEnviadas_ARCH
DBCC SHOWCONTIG (983674552,0) -- vsSender_FactEnviadas_temp.vsSender_FactEnviadas_temp


CP 083400659

--muestra  todos los archivos de todas las bases de datos, registradas en la master, su ubicación, tamaños de los file (en pag. De 8k) y en MB.,
SELECT sys.databases.database_id,sys.databases.name,sys.databases.create_date,
sys.databases.recovery_model_desc,sys.databases.state_desc,
sys.master_files.type_desc,sys.master_files.name,
sys.master_files.physical_name,sys.master_files.size as cant_pag_de_8kb,
(sys.master_files.size*8)/1024 as size_mb,--el campo size muestra la cantidad de paginas del archivo (cada pagina es de 8 KB)
                                                     -- por eso debe multipliarse size * 8 = tot kb / 1024 = size mb  (ó size/128)
sys.master_files.max_size,sys.master_files.growth
FROM sys.master_files,sys.databases 
where sys.master_files.database_id = sys.databases.database_id
order by sys.databases.database_id,sys.master_files.type_desc asc

--importante: sys.master_files.size representa el (Tamaño actual del archivo), mostrado en cantidad de páginas de 8 KB.  



--Problems running sp_helpdb in SQL Server
--sql server 2000 sp_helpdb Cannot insert the value NUL into column '', table ''; column does not allow nulls. INSERT fails.

--Correr el query para saber cual no tiene owner
SELECT name, suser_sname(sid), convert(nvarchar(11), crdate),dbid, cmptlevel 
FROM master.dbo.sysdatabases     uRdwloT0wM1YGsAf5U

--ejecutar esto para generar el script
SELECT 'USE ' + name + '; EXEC sp_changedbowner ''sa'';' 
FROM master.dbo.sysdatabases WHERE suser_sname(sid) IS NULL

--cambiarle el owner
USE GxPortal; EXEC sp_changedbowner 'sa';

--The proposed new database owner is already a user or aliased in the database.
USE rmdb; 
go
SP_DROPUSER 'rm'
GO
EXEC sp_changedbowner 'rm'


exec master.dbo.xp_servicecontrol 'QUERYSTATE', 'MSSQLServer'
exec master.dbo.xp_servicecontrol 'QUERYSTATE', 'SQLServerAgent'
exec master.dbo.xp_servicecontrol 'QUERYSTATE', 'SQLBrowser'


--Did all of your SQL Agent Jobs run successfully?
use msdb
go
select 'FAILED' as Status, cast(sj.name as varchar(100)) as "Job Name",
       cast(sjs.step_id as varchar(5)) as "Step ID",
       cast(sjs.step_name as varchar(30)) as "Step Name",
       cast(REPLACE(CONVERT(varchar,convert(datetime,convert(varchar,sjh.run_date)),102),'.','-')+' '+SUBSTRING(RIGHT('000000'+CONVERT(varchar,sjh.run_time),6),1,2)+':'+SUBSTRING(RIGHT('000000'+CONVERT(varchar,sjh.run_time),6),3,2)+':'+SUBSTRING(RIGHT('000000'+CONVERT(varchar,sjh.run_time),6),5,2) as varchar(30)) 'Start Date Time',
       sjh.message as "Message"
from sysjobs sj
join sysjobsteps sjs 
 on sj.job_id = sjs.job_id
join sysjobhistory sjh 
 on sj.job_id = sjh.job_id and sjs.step_id = sjh.step_id
where sjh.run_status <> 1
  and cast(sjh.run_date as float)*1000000+sjh.run_time > 
      cast(convert(varchar(8), getdate()-1, 112) as float)*1000000+70000 --yesterday at 7am
union
select 'FAILED',cast(sj.name as varchar(100)) as "Job Name",
       'MAIN' as "Step ID",
       'MAIN' as "Step Name",
       cast(REPLACE(CONVERT(varchar,convert(datetime,convert(varchar,sjh.run_date)),102),'.','-')+' '+SUBSTRING(RIGHT('000000'+CONVERT(varchar,sjh.run_time),6),1,2)+':'+SUBSTRING(RIGHT('000000'+CONVERT(varchar,sjh.run_time),6),3,2)+':'+SUBSTRING(RIGHT('000000'+CONVERT(varchar,sjh.run_time),6),5,2) as varchar(30)) 'Start Date Time',
       sjh.message as "Message"
from sysjobs sj
join sysjobhistory sjh 
 on sj.job_id = sjh.job_id
where sjh.run_status <> 1 and sjh.step_id=0
  and cast(sjh.run_date as float)*1000000+sjh.run_time >
      cast(convert(varchar(8), getdate()-1, 112) as float)*1000000+70000 --yesterday at 7am
      
--Do you have a recent backup of all your SQL Server databases?
SELECT d.name AS "Database",
       ISNULL(CONVERT(VARCHAR,b.backupdate,120),'NEVER') AS "Last Full Backup"
FROM sys.databases d
LEFT JOIN (SELECT database_name,type,MAX(backup_finish_date) backupdate FROM backupset
           WHERE type LIKE 'D'
           GROUP BY database_name,type) b on d.name=b.database_name
WHERE (backupdate IS NULL OR backupdate < getdate()-1)
SELECT d.name AS "Database",
       ISNULL(CONVERT(VARCHAR,b.backupdate,120),'NEVER') AS "Last Log Backup"
FROM sys.databases d
LEFT JOIN (SELECT database_name,type,MAX(backup_finish_date) backupdate FROM backupset
           WHERE type LIKE 'L'
           GROUP BY database_name,type) b on d.name=b.database_name
WHERE recovery_model = 1
  AND (backupdate IS NULL OR backupdate < getdate()-1)      


--Are there any errors in your SQL Server Error Log?
declare @Time_Start datetime;
declare @Time_End datetime;
set @Time_Start=getdate()-2;
set @Time_End=getdate();
-- Create the temporary table
CREATE TABLE #ErrorLog (logdate datetime
                      , processinfo varchar(255)
                      , Message varchar(500))
-- Populate the temporary table
INSERT #ErrorLog (logdate, processinfo, Message)
   EXEC master.dbo.xp_readerrorlog 0, 1, null, null , @Time_Start, @Time_End, N'desc';
-- Filter the temporary table
SELECT LogDate, Message FROM #ErrorLog
WHERE (Message LIKE '%error%' OR Message LIKE '%failed%') AND processinfo NOT LIKE 'logon'
ORDER BY logdate DESC
-- Drop the temporary table 
DROP TABLE #ErrorLog
      
https://www.mssqltips.com/sqlservertip/2522/sql-server-monitoring-checklist/




 **************************************************************************************************
Step 1: Download & run sp_Blitz.
Go to our download page and get our First Responder Kit. There’s a bunch of scripts and white papers in there, but the one to start with is sp_Blitz.sql. Open that in SSMS, run the script, and it will install sp_Blitz in whatever database you’re in. (I usually put it in the master database, but you don’t have to – it works anywhere.)

Then, run it with these options:
                                                                                                                          Transact-SQL

EXEC sp_Blitz @CheckUserDatabaseObjects = 0, @CheckServerInfo = 1;
1
EXEC sp_Blitz @CheckUserDatabaseObjects = 0, @CheckServerInfo = 1;
These two parameters give you a server-level check without looking inside databases (slowly) for things like heaps and triggers.

**************************************************************************************************
--CURSOR para BORRADO EN SQL SERVER
SET NOCOUNT ON;
 
DECLARE @r INT;
 
SET @r = 1;
 
WHILE @r > 0
BEGIN
  BEGIN TRANSACTION;
 
  DELETE TOP (100000) -- this will change
    dbo.SalesOrderDetailEnlarged
    WHERE ProductID IN (712, 870, 873);
 
  SET @r = @@ROWCOUNT;
 
  COMMIT TRANSACTION;
 
  -- CHECKPOINT;    -- if simple
  -- BACKUP LOG ... -- if full
END


---------------------
UNDO.

SQL> column tablespace format a20;
SQL> column sum_in_mb format 999999.99;
SQL> select tablespace_name tablespace, status, sum(bytes)/1024/1024 sum_in_mb, count(*) counts from dba_undo_extents group by tablespace_name, status order by 1,2;

TABLESPACE           STATUS     SUM_IN_MB     COUNTS
-------------------- --------- ---------- ----------
UNDOTBS1             EXPIRED        10.50         41
UNDOTBS1             UNEXPIRED   11241.50       1084
UNDOTBS2             UNEXPIRED    3929.25        378

SQL>  select u.tablespace_name tablespace, s.username, u.status, sum(u.bytes)/1024/1024 sum_in_mb, count(u.segment_name) seg_cnts from dba_undo_extents u left join v$transaction t on u.segment_name = '_SYSSMU' || t.xidusn || '$' left join v$session s on t.addr = s.taddr group by u.tablespace_name, s.username, u.status order by 1,2,3;

TABLESPACE           USERNAME                       STATUS     SUM_IN_MB
-------------------- ------------------------------ --------- ----------
  SEG_CNTS
----------
UNDOTBS1                                            EXPIRED        10.50
        41

UNDOTBS1                                            UNEXPIRED   11241.50
      1084

UNDOTBS2                                            UNEXPIRED    3929.25
       378


SQL> set linesize 180
SQL> /

TABLESPACE           USERNAME                       STATUS     SUM_IN_MB   SEG_CNTS
-------------------- ------------------------------ --------- ---------- ----------
UNDOTBS1                                            EXPIRED        10.50         41
UNDOTBS1                                            UNEXPIRED   11241.50       1084
UNDOTBS2                                            UNEXPIRED    3929.25        378

SQL> select dbms_undo_adv.best_possible_retention(sysdate-7, sysdate) UNDO_RETENTION from dual;

UNDO_RETENTION
--------------
       3143137

SQL> select dbms_undo_adv.longest_query(sysdate-7, sysdate) UNDO_RETENTION from dual;

UNDO_RETENTION
--------------
          1748

SQL> select dbms_undo_adv.required_retention(sysdate-7, sysdate) UNDO_RETENTION from dual;

UNDO_RETENTION
--------------
          1748

SQL> select dbms_undo_adv.rbu_migration(sysdate-7, sysdate) UNDO_RETENTION from dual;

UNDO_RETENTION
--------------
          7146

SQL>
http://logic.edchen.org/when-undo_retention-is-useless-when-is-not/


--Listar los datafiles en SQL Server
SELECT sd.NAME
,smf.NAME
,smf.type_desc
,(CAST(smf.size AS FLOAT) * 8096) AS SizeBytes
,(CAST(smf.size AS FLOAT) * 8096) / (1024) AS SizeKB
,(CAST(smf.size AS FLOAT) * 8096) / (1024 * 1024) AS SizeMB
,(CAST(smf.size AS FLOAT) * 8096) / (1024 * 1024 * 1024) AS SizeGB
,smf.physical_name
,sd.log_reuse_wait_desc
,sd.recovery_model_desc
,*
FROM sys.databases sd
INNER JOIN sys.master_files smf ON sd.database_id = smf.database_id
WHERE
smf.type_desc IN (
    'ROWS'
    ,'LOG'
    )
ORDER BY sd.NAME DESC


--Privilegios SQL Server

T-SQL: Retrieve All Users And Associated Roles For ALL Databases
by Mohammed Mawla January 24, 2012
Posted in: Technical Track
Tags: DBA Lounge, Group Blog Posts, Microsoft SQL Server
A frequent inquiry concerning databases’ security is to retrieve the database role(s) associated with each user for auditing or troubleshooting purposes.

Each database user (principal) can be retrieved from sys.database_principals and the associated database roles can be retrieved from sys.database_role_members

The following code runs against ALL the databases using SP_MSForeachdb and all roles for one principal is concatenated in one row

DECLARE @DB_USers TABLE
(DBName sysname, UserName sysname, LoginType sysname, AssociatedRole varchar(max),create_date datetime,modify_date datetime)
 
INSERT @DB_USers
EXEC sp_MSforeachdb
 
'
use [?]
SELECT ''?'' AS DB_Name,
case prin.name when ''dbo'' then prin.name + '' (''+ (select SUSER_SNAME(owner_sid) from master.sys.databases where name =''?'') + '')'' else prin.name end AS UserName,
prin.type_desc AS LoginType,
isnull(USER_NAME(mem.role_principal_id),'''') AS AssociatedRole ,create_date,modify_date
FROM sys.database_principals prin
LEFT OUTER JOIN sys.database_role_members mem ON prin.principal_id=mem.member_principal_id
WHERE prin.sid IS NOT NULL and prin.sid NOT IN (0x00) and
prin.is_fixed_role <> 1 AND prin.name NOT LIKE ''##%'''
 
SELECT
 
dbname,username ,logintype ,create_date ,modify_date ,
 
STUFF(
 
(
 
SELECT ',' + CONVERT(VARCHAR(500),associatedrole)
 
FROM @DB_USers user2
 
WHERE
 
user1.DBName=user2.DBName AND user1.UserName=user2.UserName
 
FOR XML PATH('')
 
)
 
,1,1,'') AS Permissions_user
 
FROM @DB_USers user1
 
GROUP BY
 
dbname,username ,logintype ,create_date ,modify_date
 
ORDER BY DBName,username
The code applies few filters:

– No Guest user account; you should NOT enable a guest account for a production database.

– Skip fixed database roles such as DB_OWNER , db_datawriter,db_datareader,….etc

– Principals with NULL SID ; those are internal to the DB such as INFORMATION_SCHEMA & sys

Remarks

– SYSADMINS don’t need to be part of explicit database’s users list to gain access as they have access to everything on server. You can get list of SYSADMIN users by running following code

SELECT
p.name AS [Name] ,r.type_desc,r.is_disabled,r.create_date , r.modify_date,r.default_database_name
FROM
sys.server_principals r
INNER JOIN sys.server_role_members m ON r.principal_id = m.role_principal_id
INNER JOIN sys.server_principals p ON
p.principal_id = m.member_principal_id
WHERE r.type = 'R' and r.name = N'sysadmin'
– If a windows login is part of a windows group then you may need to look at the members of this Windows group to identify who can access this database.

– A user may still be revoked access to database indvidual objects even the role allows access normally.

Following blog has a query to list permissions on indvidual objects

http://consultingblogs.emc.com/jamiethomson/archive/2007/02/09/SQL-Server-2005_3A00_-View-all-permissions–_2800_2_2900_.aspx

HTH



REPLICA

SQL> select max(sequence#) from v$archived_log where applied='YES';

MAX(SEQUENCE#)
--------------
        690506

SQL> select process, thread#, sequence#, status from v$managed_standby where process='MRP0';

PROCESS      THREAD#  SEQUENCE# STATUS
--------- ---------- ---------- ------------
MRP0               1     690509 APPLYING_LOG

SQL>


SELECT archived_seq#-applied_seq# 
FROM V$ARCHIVE_DEST_STATUS    
WHERE DEST_ID = 3;



BEGIN 
  SYS.DBMS_JOB.REMOVE(1522);
COMMIT;
END;
/

DECLARE
  X NUMBER;
BEGIN
  SYS.DBMS_JOB.SUBMIT
  ( job       => X 
   ,what      => 'UNICORN.sp_populate_debtors;'
   ,next_date => to_date('01/01/4000 00:00:00','dd/mm/yyyy hh24:mi:ss')
   ,interval  => 'TRUNC(SYSDATE+1)+12/24'
   ,no_parse  => FALSE
  );
  SYS.DBMS_OUTPUT.PUT_LINE('Job Number is: ' || to_char(x));
  SYS.DBMS_JOB.BROKEN
   (job    => X,
    broken => TRUE);
COMMIT;
END;
/

-------------------------------------------------------------------------------------------------------------------

Standby database process status: You can run following query on standby database to see what MRP and RFS processes are doing, which block of which archivelog sequences are being shipped or being applied.


SQL> select process, status, thread#, sequence#, block#, blocks from v$managed_standby ;

PROCESS   STATUS          THREAD#  SEQUENCE#     BLOCK#     BLOCKS
--------- ------------ ---------- ---------- ---------- ----------
ARCH      CLOSING               1      69479     932864        261
ARCH      CLOSING               1      69480     928768        670
ARCH      CLOSING               2      75336     933888        654
ARCH      CLOSING               2      78079     930816        842
ARCH      CLOSING               1      69475     943104         79
RFS       IDLE                  0          0          0          0
...
RFS       RECEIVING             1      69481     688130       1024
MRP0      WAIT_FOR_LOG          2      78080          0          0
RFS       IDLE                  2      78080     873759          3


Last applied log: Run this query on the standby database to see the last applied archivelog sequence number for each thread.


SQL> SELECT thread#, max(SEQUENCE#) FROM V$ARCHIVED_LOG where APPLIED='YES' group by thread#;

   THREAD# MAX(SEQUENCE#)
---------- --------------
         1          69479
         2          78079

Archivelog difference: Run this on primary database. (not for real time apply)

SQL> ALTER SESSION SET NLS_DATE_FORMAT = 'DD-MON-YYYY HH24:MI:SS';
SQL> SELECT   a.thread#,  b. last_seq, a.applied_seq, a. last_app_timestamp, b.last_seq-a.applied_seq   ARC_DIFF FROM (SELECT  thread#, MAX(sequence#) applied_seq, MAX(next_time) last_app_timestamp FROM gv$archived_log WHERE applied = 'YES' GROUP BY thread#) a,           (SELECT  thread#, MAX (sequence#) last_seq FROM gv$archived_log GROUP BY thread#) b WHERE a.thread# = b.thread#;

   THREAD#   LAST_SEQ APPLIED_SEQ LAST_APP_TIMESTAMP     ARC_DIFF
---------- ---------- ----------- -------------------- ----------
         2      78083       78082 01-JUL-2013 16:05:25          1
         1      69486       69485 01-JUL-2013 16:08:21          1

Apply/transport lags: v$dataguard_stats view will show the general synchronization status of standby database. Better to use on 11gR2 even with the latest PSU (Check bugs : 13394040, 7119382, 9968073, 7507011, 13045332, 6874522).


SQL> set lines 200
SQL> col name format a40
SQL> col value format a20
SQL> select * from v$dataguard_stats;

NAME                     VALUE             UNIT        TIME_COMPUTED         DATUM_TIME
------------------------ ----------------- ------      --------------------- ---------------------
transport lag            +00 00:09:44      …           07/01/2013 15:49:29   07/01/2013 15:49:27
apply lag                +00 00:09:44      …           07/01/2013 15:49:29   07/01/2013 15:49:27
apply finish time        +00 00:00:00.001  …           07/01/2013 15:49:29
estimated startup time   27                second      07/01/2013 15:49:29    

Apply rate: To find out the speed of media recovery in a standby database, you can use this query:


SQL> set lines 200
SQL> col type format a30
SQL> col ITEM format a20
SQL> col comments format a20
SQL> select * from v$recovery_progress;

START_TIM TYPE             ITEM                 UNITS        SOFAR      TOTAL TIMESTAMP COMMENTS
--------- ---------------- -------------------- ------------------ ---------- --------- ----
20-JUN-13 Media Recovery   Log Files            Files         3363          0
20-JUN-13 Media Recovery   Active Apply Rate    KB/sec       21584          0
20-JUN-13 Media Recovery   Average Apply Rate   KB/sec        3239          0
20-JUN-13 Media Recovery   Maximum Apply Rate   KB/sec       48913          0
20-JUN-13 Media Recovery   Redo Applied         Megabytes  2953165          0
20-JUN-13 Media Recovery   Last Applied Redo    SCN+Time         0          0 01-JUL-13 
20-JUN-13 Media Recovery   Active Time          Seconds     233822          0
20-JUN-13 Media Recovery   Apply Time per Log   Seconds         57          0
20-JUN-13 Media Recovery   Checkpoint Time per  Seconds         11          0
                           Log
20-JUN-13 Media Recovery   Elapsed Time         Seconds     933565          0
20-JUN-13 Media Recovery   Standby Apply Lag    Seconds        483          0

11 rows selected.

You can also use below before 11gR2. (Deprecated in 11gR2):

SQL> select APPLY_RATE from V$STANDBY_APPLY_SNAPSHOT;

To check Redo apply mode on physical standby database:

SQL> SELECT RECOVERY_MODE FROM V$ARCHIVE_DEST_STATUS where dest_id=2;

RECOVERY_MODE
-----------------------
MANAGED

To check what MRP process is waiting:

select a.event, a.wait_time, a.seconds_in_wait from gv$session_wait a, gv$session b where a.sid=b.sid and b.sid=(select SID from v$session where PADDR=(select PADDR from v$bgprocess where NAME='MRP0'))

EVENT                                           WAIT_TIME SECONDS_IN_WAIT
---------------------------------------------- ---------- ---------------
parallel recovery control message reply                 0               0

Archive Lag Histogram: The  V$STANDBY_EVENT_HISTOGRAM view came with 11gR2 and shows the historical occurance of archive lags in terms of seconds. For example following output shows that in 07/01/2013 archive lag reached 5 hours and in 06/15/2013 gap was 22 hours which was resolved after more than a week.

SQL> col name format a10
SQL> select * from  V$STANDBY_EVENT_HISTOGRAM;

NAME             TIME UNIT             COUNT LAST_TIME_UPDATED
---------- ---------- ------------  -------- --------------------
apply lag           0 seconds              0
apply lag           1 seconds              1 04/13/2013 01:40:23
apply lag           2 seconds              1 04/13/2013 01:40:24
apply lag           3 seconds              1 04/13/2013 01:40:25
apply lag           4 seconds              1 04/13/2013 01:40:26
...
apply lag          25 seconds              3 05/21/2013 06:31:19
apply lag          26 seconds              3 05/21/2013 06:31:20
apply lag          27 seconds              3 05/21/2013 06:31:23
apply lag          28 seconds              5 05/21/2013 06:31:22
apply lag          29 seconds              1 05/15/2013 07:47:46
apply lag          30 seconds              4 05/21/2013 06:31:24
...
apply lag          44 seconds              8 06/26/2013 00:33:14
apply lag          45 seconds              8 06/26/2013 00:33:15
apply lag          46 seconds              8 06/26/2013 00:33:17
apply lag          47 seconds              8 06/26/2013 00:33:18
apply lag          48 seconds              9 06/26/2013 00:33:19
...
apply lag          57 seconds             29 06/26/2013 06:33:02
apply lag          58 seconds             25 06/26/2013 06:33:27
apply lag          59 seconds             28 06/26/2013 06:33:28
apply lag           1 minutes              0
apply lag           2 minutes           9316 06/30/2013 18:33:45
apply lag           3 minutes          94601 07/01/2013 14:23:11
apply lag           4 minutes         209262 07/01/2013 14:56:13
apply lag           5 minutes         355744 07/01/2013 16:02:33
apply lag           6 minutes         522176 07/01/2013 16:03:30
apply lag           7 minutes         634199 07/01/2013 16:01:10
...
apply lag          47 minutes          28174 07/01/2013 05:14:53
apply lag          48 minutes          28231 07/01/2013 05:14:49
apply lag          49 minutes          27099 07/01/2013 05:14:44
apply lag          50 minutes          26532 07/01/2013 05:14:40
...
apply lag           3 hours           564493 07/01/2013 05:00:08
apply lag           4 hours           511628 06/22/2013 07:43:26
apply lag           5 hours           448572 06/22/2013 07:34:03
apply lag           6 hours           369037 06/22/2013 07:09:59
apply lag           7 hours           206117 06/21/2013 00:53:27
apply lag           8 hours           137932 06/21/2013 00:33:53
apply lag           9 hours           137091 06/21/2013 00:03:33
apply lag          10 hours            98103 06/20/2013 23:26:34
apply lag          11 hours           104157 06/20/2013 22:53:12
apply lag          12 hours           102141 06/20/2013 22:14:07
apply lag          13 hours            89214 06/20/2013 21:32:22
apply lag          14 hours            64880 06/20/2013 21:04:29
apply lag          15 hours            43471 06/20/2013 21:01:45
apply lag          16 hours            38075 06/20/2013 20:59:37
apply lag          17 hours            38449 06/20/2013 20:55:34
apply lag          18 hours            22049 06/16/2013 01:22:55
apply lag          19 hours            19873 06/16/2013 00:53:55
apply lag          20 hours            15985 06/15/2013 23:52:16
apply lag          21 hours            13290 06/15/2013 03:08:49
apply lag          22 hours             7330 06/15/2013 02:07:26
apply lag          23 hours             1606 02/15/2013 22:16:11
apply lag           1 days              3216 02/15/2013 22:00:42
apply lag           2 days             16768 02/15/2013 20:54:06

144 rows selected.


Redo switch report of primary database can be seen with the following query. This information may be helpful when investigating the possible causes of archive gaps, apply lags or data guard performance issues.

SQL> SET PAGESIZE 9999
SQL> col day format a15
SQL> SELECT A.*, Round(A.Count#*B.AVG#/1024/1024) Daily_Avg_Mb FROM(SELECT To_Char(First_Time,'YYYY-MM-DD') DAY, Count(1) Count#, Min(RECID) Min#, Max(RECID) Max# FROM gv$log_history GROUP BY To_Char(First_Time,'YYYY-MM-DD') ORDER BY 1 DESC) A,(SELECT Avg(BYTES) AVG#, Count(1) Count#, Max(BYTES) Max_Bytes, Min(BYTES) Min_Bytes FROM gv$log ) B;

DAY                 COUNT#       MIN#       MAX# DAILY_AVG_MB
--------------- ---------- ---------- ---------- ------------
2013-07-01             442     147345     147566       452608
2013-06-30             526     147083     147347       538624
2013-06-29             532     146817     147082       544768
2013-06-28             928     146353     146816       950272
2013-06-27             760     145973     146352       778240
2013-06-26             708     145619     145972       724992
2013-06-25             560     145338     145618       573440
2013-06-24             498     145090     145339       509952
2013-06-23             104     145038     145089       106496
2013-06-22             338     144869     145037       346112
2013-06-21             748     144495     144868       765952
2013-06-20             748     144121     144494       765952
2013-06-19             952     143645     144120       974848
2013-06-18             882     143204     143644       903168
2013-06-17             914     142746     143203       935936
2013-06-16             454     142520     142747       464896
2013-06-15            1520     141760     142519      1556480
2013-06-14            1862     140829     141759      1906688
2013-06-13             970     140343     140828       993280
2013-06-12             598     140045     140345       612352
2013-06-11             550     139770     140044       563200
2013-06-10             516     139511     139769       528384
2013-06-09             178     139423     139512       182272
2013-06-08             296     139275     139422       303104
2013-06-07             490     139030     139274       501760
2013-06-06             572     138744     139029       585728
2013-06-05             488     138499     138743       499712
2013-06-04             554     138223     138500       567296

The last one is a shell command and lists the archive log apply records of standby database alert log with the corresponding times at the end of the line. This is useful to see a clean picture of redo apply status on the standby database.

tail -10000 /u01/app/oracle/product/diag/rdbms/testdb/TESTDB/trace/alert_TESTDB.log |awk -v x="" '{if (index($0,"Media Recovery Log ")!=0) print $0" "x; else if($1=="Mon"||$1=="Tue"||$1=="Wed"||$1=="Thu"||$1=="Fri"||$1=="Sat"||$1=="Sun") x=$0}'


Media Recovery Log +DATA/…/thread_1_seq_69468.904.819643305 Mon Jul 01 14:42:14 2013
Media Recovery Log +DATA/…/thread_1_seq_69469.899.819643701 Mon Jul 01 14:48:51 2013











































































************************MYSQL********
*--**Livechat**--
201.224.58.214
Credenciales Sistema Operativo
root/Lcnpn2015

BD
root/@L1#9d3y4*x.XC

--**Intranet**--
172.18.2.244
Credenciales Sistema Operativo
root/intranetgssi

BD:
root/master#mysql
mysqlroot/master#al0e

--**Extranet**--

Credenciales Sistema Operativo
root/$gssidbcwp$

BD:
root/master#mysql
mysqlroot/master#al0e

--**Nagios**--
172.18.2.98
Credenciales Sistema Operativo
root/nag1408

BD:
root/nagiosxi
mysqlroot/www.xnxx.com

--**DBASES**--
172.18.1.127
Credenciales Sistema Operativo
root/password

BD:
root/@cWp.m@R14.sS0
mysqlroot/www.xnxx.com

--Acceder a consola de mysql

[root@cwp-vm-dbases ~]# mysql -u root -p
Enter password: @cWp.m@R14.sS0    --SO

Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 1019763
Server version: 5.5.37-MariaDB MariaDB Server

Copyright (c) 2000, 2014, Oracle, Monty Program Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]>
  SHOW FULL PROCESSLIST; 
  SHOW GLOBAL VARIABLES; 
  SHOW GLOBAL STATUS;
  SHOW ENGINE INNODB STATUS;


Kamikaze

usuario SA: sa#s3gur0

servicios:
----------

usuario servicio de sqlserver sqlservices_db/SSDB#al0e

usuario de integration services  sqlservices_is/SSIS#al0e

usuario de agente  sqlservices_ag/SSAGS#al0e

usuario de analysis services sqlservices_as/SSAS#al0e

reporting sqlservices_rs/SSRS#al0e


ADMINISTRACION:
---------------
MASTER base de datos ssdbroot/master#al0e

MASTER int serv ssisroot/master#3tl


PROCESOS ETL:
-------------
etl runner ssisprocesses/3tl#runner



RedGateBackup/backup$sql

DBA GSSI

grupo apps oper

grupo dba dba

clientes de oracle

usuario fullaccess r/w para ETL en sql

usuario fullaccess r/w oracle settler, siebel f y m, unicorn, etc



nueva intranet

so:
root/intranetgssi


BD: root/master#mysql

mysqlroot/master#al0e

nagiosopcss/wsgQ3chM
GRANT ALL ON *.* to nagiosopcss@'172.18.254.86' IDENTIFIED BY 'wsgQ3chM' with grant option;
GRANT ALL ON *.* to mysqlroot@'172.18.1.134' IDENTIFIED BY 'master#al0e' with grant option;
GRANT ALL ON *.* to 'gssi'@'localhost' IDENTIFIED BY 'gss1mysql' with grant option;
GRANT ALL ON *.* to 'mysqlroot'@'172.18.92.158' IDENTIFIED BY 'master#al0e' with grant option;
GRANT ALL ON *.* to nagiosopcss@'172.18.254.86' IDENTIFIED BY 'wsgQ3chM' with grant option;
GRANT ALL ON *.* to mysqlroot@'192.168.34.53' IDENTIFIED BY '' with grant option;                           

promocionescwp/Pr0m0#CWP


ETL PWD: gssi3tl

'nagiosopcss', password = 'wsgQ3chM'
OS: root/nag1408
mysql: root/nagiosxi

run maintenance: gssi/gss1mysql

CREATE USER 'gssi'@'localhost' IDENTIFIED BY 'gss1mysql';

GRANT ALL PRIVILEGES ON * . * TO 'gssi'@'localhost' IDENTIFIED BY '***' WITH GRANT OPTION MAX_QUERIES_PER_HOUR 0 MAX_CONNECTIONS_PER_HOUR 0 MAX_UPDATES_PER_HOUR 0 MAX_USER_CONNECTIONS 0 ;


root oracle:
cwm-sfr-dbco1 - htl#01s0n
cwm-sfr-dbco2 - htl#01s0n
cwm-sfr-act1 - NMwu7Jg
cwm-sfr-act2 - NMwu7Jg
cwm-sfr-dbact1 - u6130S3
cwm-sfr-dbact2 - u6130S3
cwm-sfr-urep - U9QR0aJ
cwm-sfr-rman - g1XnM7s
cwm-sfr-ntrack - sme8OOk
cwm-sfr-sibmov - 4jsEAlH (ele)
cwm-sfr-rep - VyP1L1c (V mayus)
SAP07 – s4pr00t
SAP11 -  2013sap  (s4pr00t)
pans00 - Vobz9682
NUEVOS:
-------
system:
alter user system identified by h1ck#bad;

roots:

uprod: cru444UKU

uprod2:  cru444UKU

urep: hUdraR4g

repdrm:  cru444UKU

roaming: pHa8exan

rman: CuStax5H

c0rusc4nt


Perf. Analisis SQLServer: quest/qu3s+
Perf. Analisis User ORACLE: quest_pa/qu3s+2k
Capacity Manager User UREP ORACLE: quest_cm/qu3s+2k
QUEST_SPC_DEMO_USER/
Perf. Analisis Domain User: cwp\quest / foglight+2k
foglight web: foglight/foglight+2k

Data Source=CWP-JFR-BWDF;Initial Catalog=reportes

Sap07 
User: root
Pass: s4pr00t

Sap11
User: root
Pass: sap2013



clrg switch -n cwm-sfr-bdco2:z5sibmov1 SblmovDB-rg

UNICORN/CELITA22

sql server : dbtuna/dbtun@088

----------------------------------------------------

DLO
tvcsop con password:itcwp13 
usuario itcwp fue creado con el password: tvcsop

----------------------------------------------------

IP Servidor de Desarrollo (Base de Datos Tertio)= 172.18.254.224
Name del server= cwp-sfr-terdb01

Root/Usbi8724

Instancia de +ASM
user= sys/asmsnmp
password= asmtdesa01

Instancia de Tertio
users=sys/sysman/dbsnmp
password:tdesa#msa01


Usuario oracle11g (Con este usuario se instaló la instacia de Tertio)
Password:tesdesa

Usuario oragrid (con este usuario se instaló el +ASM)
Password= tesdesa

--------------------------------------------------------
SITIO CWPANAMA.COM y MYCWP
CWP-VM-EXNDB
USER: root
PASSWORD: $gssidbcwp$

CWP-VM-EXNET01
USER: root
PASSWORD: $gssiapacwp$


cwpanama.com
cwpcomfx880p / DrEdrew2ustu#$!

MyCWP
mycwpkxr540p / qes3KaSTusas#$!
---------------


tertio 7.6 test app node:
Hostname : cwp-sfr-terap01
IP : 172.18.254.223
usuario oracle con el password intelx86


CWP-JFR-BZTSQL1\JFRBIZTALK01
consulta_bi\bibiztalk99
dwh: bdbzt1_lnksvr/biztalk99
asdf: tdwservices/Ldata12345678
ConsultaEC/Password01
pa_cwp_beai_unicorn/bztlkora2007 

replica_biztal/replicabzt2012

bwdf: report_movil_consult/repmovcon

-----------------
cwp-vm-glpi
root password
mysql: root/secroot$911

-----------------

MPPG TEST DB: cwp-sfr-mppgtdb
SID: mppg
ASM: oragrid/asm#mppg
DB: Sys/db#mppg

-----------------

cwp-sfr-webtp 


 u: cwp-sfr-webtp\cwpwebtp
 P: Admin2005

el user es sa
password cgtp2008


cgtp: db_datareader

---------------------------

backup/backup$816

---------------------------


CWP\cwp
cwp@cwpanama.com / Sitel200505

---------------------------


REPAIRSHOP:
RepShop_Reports / RSreps$486

unicorn: Id=REPORTES;Password=repmobilek6


--------------------

Servidor de Backup de los RAC's de Oracle (MPPG/INTRAWAY)
cwp-vm-bckpa0
root/Panama2014

--------------------

Intraway
oma/welcome1

MPPG
oma/welcome1

Exadata
dbsnmp/welcome1



Unable to proceed because you have selected a platform for which Agent software is not available on the OMS. 
Go to Setup > Extensibility > Self Update and download the Agent software for the selected platform, and then, return to this wizard to continue with the installation.


http://www.gokhanatil.com/2014/01/how-to-add-rac-databases-to-enterprise-manager-cloud-control-12c.html#comment-390996



 ./emcli import_update_catalog -file=/app/oracle/Middleware/oms/p9348486_112000_Generic.zip –omslocal
 
 https://updates.oracle.com/Orion/Download/download_patch/p9348486_112000_Generic.zip
 
 
 
/db/app/oracle/middleware/bin/emcli setup -url=https://172.18.254.2:7802/em -username=SYSMAN

/db/app/oracle/middleware/bin
/db/app/oracle/middleware/bin/

 Port 3872 must be available on all IP addresses associated with host  
 Actual Result: Port 3872, which is bound to IP address 172.18.1.73 on host cwp-jfr-mppgdb1.cwpanama.com is busy. 
 Check complete. The overall result of this check is: Failed 
 
 
 ****** Lista todos los crontab de todos los usuarios
 *
 *for user in $(cut -f1 -d: /etc/passwd); do echo $user; crontab -u $user -l; done  
 *
 *
 *
 Checking for temporary space allocated and in-use
This query (version 12+) will show the current size, allocated space, and free space for all temporary tablespaces in the database.

Version 12:

SELECT * FROM DBA_TEMP_FREE_SPACE;

TABLESPACE_NAME               TABLESPACE_SIZE ALLOCATED_SPACE FREE_SPACE

—————————— ————— ————— ———-

TEMP                                 20971520       14680064 19922944

Temporary segments
The following query displays information about all sort segments in the database. 
(As a reminder, we use the term “sort segment” to refer to a temporary segment in a temporary tablespace.)
 Typically, Oracle will create a new sort segment the very first time a sort to disk occurs in a new temporary tablespace.
  The sort segment will grow as needed, but it will not shrink and will not go away after all sorts to disk are completed. 
  A database with one temporary tablespace will typically have just one sort segment.

Pre version 11:

SELECT   A.tablespace_name tablespace, D.mb_total,

SUM (A.used_blocks * D.block_size) / 1024 / 1024 mb_used,

D.mb_total – SUM (A.used_blocks * D.block_size) / 1024 / 1024 mb_free

FROM     v$sort_segment A,

(

SELECT   B.name, C.block_size, SUM (C.bytes) / 1024 / 1024 mb_total

FROM     v$tablespace B, v$tempfile C

WHERE    B.ts#= C.ts#

GROUP BY B.name, C.block_size

) D

WHERE    A.tablespace_name = D.name

GROUP by A.tablespace_name, D.mb_total;

The query displays for each sort segment in the database the tablespace the segment resides in, the size of the tablespace, the amount of space within the sort segment that is currently in use, and the amount of space available. Sample output from this query is as follows:

TABLESPACE                        MB_TOTAL    MB_USED    MB_FREE

——————————- ———- ———- ———-

TEMP                                 10000          9       9991

This example shows that there is one sort segment in a 10,000 MB tablespace called TEMP. Right now, 9 MB of the sort segment is in use, leaving a total of 9,991 MB available for additional sort operations. (Note that the available space may consist of unused blocks within the sort segment, unallocated extents in the TEMP tablespace, or a combination of the two.)

Sort space usage by session
The following query displays information about each database session that is using space in a sort segment. Although one session may have many sort operations active at once, this query summarizes the information by session. This query will need slight modification to run on Oracle 8i databases, since the dba_tablespaces view did not have a block_size column in Oracle 8i.

SELECT   S.sid || ‘,’ || S.serial# sid_serial, S.username, S.osuser, P.spid, S.module,

S.program, SUM (T.blocks) * TBS.block_size / 1024 / 1024 mb_used, T.tablespace,

COUNT(*) sort_ops

FROM     v$sort_usage T, v$session S, dba_tablespaces TBS, v$process P

WHERE    T.session_addr = S.saddr

AND      S.paddr = P.addr

AND      T.tablespace = TBS.tablespace_name

GROUP BY S.sid, S.serial#, S.username, S.osuser, P.spid, S.module,

S.program, TBS.block_size, T.tablespace

ORDER BY sid_serial;

The query displays information about each database session that is using space in a sort segment, along with the amount of sort space and the temporary tablespace being used, and the number of sort operations in that session that are using sort space. Sample output from this query is as follows:

SID_SERIAL USERNAME OSUSER SPID MODULE PROGRAM   MB_USED TABLESPACE SORT_OPS

———- ——– —— —- —— ——— ——- ———- ——–

33,16998   RPK_APP  rpk    3061 inv    httpd@db1       9 TEMP              2    




----Validar la existencia de un usuario en SQL Server

DECLARE @DB_USers TABLE
(DBName sysname, UserName sysname, LoginType sysname, AssociatedRole varchar(max),create_date datetime,modify_date datetime)
 
INSERT @DB_USers
EXEC sp_MSforeachdb
 
'
use [?]
SELECT ''?'' AS DB_Name,
case prin.name when ''dbo'' then prin.name + '' (''+ (select SUSER_SNAME(owner_sid) from master.sys.databases where name =''?'') + '')'' else prin.name end AS UserName,
prin.type_desc AS LoginType,
isnull(USER_NAME(mem.role_principal_id),'''') AS AssociatedRole ,
create_date,
modify_date
FROM sys.database_principals prin
LEFT OUTER JOIN sys.database_role_members mem ON prin.principal_id=mem.member_principal_id
WHERE prin.sid IS NOT NULL 
and prin.sid NOT IN (0x00) 
and prin.is_fixed_role <> 1 
AND prin.name NOT LIKE ''##%''
and prin.name like ''%SLL80822%'''

 
SELECT
 
dbname,username ,logintype ,create_date ,modify_date ,
 
STUFF(
 
(
 
SELECT ',' + CONVERT(VARCHAR(500),associatedrole)
 
FROM @DB_USers user2
 
WHERE
 
user1.DBName=user2.DBName AND user1.UserName=user2.UserName
 
FOR XML PATH('')
 
)
 
,1,1,'') AS Permissions_user
 
FROM @DB_USers user1
 
GROUP BY
 
dbname,username ,logintype ,create_date ,modify_date
 
ORDER BY DBName,username


set lines 220
set pages 1000
col cf for 9,999
col df for 9,999
col elapsed_seconds heading "ELAPSED|SECONDS"
col i0 for 9,999
col i1 for 9,999
col l for 9,999
col output_mbytes for 9,999,999 heading "OUTPUT|MBYTES"
col session_recid for 999999 heading "SESSION|RECID"
col session_stamp for 99999999999 heading "SESSION|STAMP"
col status for a10 trunc
col time_taken_display for a10 heading "TIME|TAKEN"
col output_instance for 9999 heading "OUT|INST"
select
  to_char(j.start_time, 'yyyy-mm-dd hh24:mi:ss') start_time,
  to_char(j.end_time, 'yyyy-mm-dd hh24:mi:ss') end_time,
  (j.output_bytes/1024/1024) output_mbytes, j.status, j.input_type,
  decode(to_char(j.start_time, 'd'), 1, 'Sunday', 2, 'Monday',
                                     3, 'Tuesday', 4, 'Wednesday',
                                     5, 'Thursday', 6, 'Friday',
                                     7, 'Saturday') dow,
  j.elapsed_seconds, j.time_taken_display,
  x.cf, x.df, x.i0, x.i1, x.l,
  ro.inst_id output_instance
from v$RMAN_BACKUP_JOB_DETAILS j
  left outer join (select
                     d.session_recid, d.session_stamp,
                     sum(case when d.controlfile_included = 'YES' then d.pieces else 0 end) CF,
                     sum(case when d.controlfile_included = 'NO'
                               and d.backup_type||d.incremental_level = 'D' then d.pieces else 0 end) DF,
                     sum(case when d.backup_type||d.incremental_level = 'D0' then d.pieces else 0 end) I0,
                     sum(case when d.backup_type||d.incremental_level = 'I1' then d.pieces else 0 end) I1,
                     sum(case when d.backup_type = 'L' then d.pieces else 0 end) L
                   from
                     v$BACKUP_SET_DETAILS d
                     join v$BACKUP_SET s on s.set_stamp = d.set_stamp and s.set_count = d.set_count
                   where s.input_file_scan_only = 'NO'
                   group by d.session_recid, d.session_stamp) x
    on x.session_recid = j.session_recid and x.session_stamp = j.session_stamp
  left outer join (select o.session_recid, o.session_stamp, min(inst_id) inst_id
                   from Gv$RMAN_OUTPUT o
                   group by o.session_recid, o.session_stamp)
    ro on ro.session_recid = j.session_recid and ro.session_stamp = j.session_stamp
where j.start_time > trunc(sysdate)-&NUMBER_OF_DAYS
order by j.start_time
/


select sum(bytes)/1024/1024 from v$datafile;  
--2,251,933


select sum(bytes)/1024/1024 from dba_free_space; 
--623,939.6875    


select 2251933 - 623939.6875 from dual;
--1,627,993.3125

--How the database size increased in GBytes per month for the last year.
SELECT TO_CHAR(creation_time, 'RRRR MM') "Month", 
round(SUM(bytes)/1024/1024/1024) "Growth in GBytes" 
FROM sys.v_$datafile 
WHERE creation_time > SYSDATE-865 
GROUP BY TO_CHAR(creation_time, 'RRRR MM')
order by 1;

--great script to display table size changes between two periods.  
select * from (select to_char(end_interval_time, 'MM/DD/YY') mydate, sum(space_used_delta) / 1024 / 1024 "Space used (MB)", avg(c.bytes) / 1024 / 1024 "Total Object Size (MB)",
round(sum(space_used_delta) / sum(c.bytes) * 100, 2) "Percent of Total Disk Usage"
from 
   dba_hist_snapshot sn, 
   dba_hist_seg_stat a, 
   dba_objects b, 
   dba_segments c
where 
begin_interval_time > trunc(sysdate) - &days_back
and sn.snap_id = a.snap_id
and b.object_id = a.obj#
and b.owner = c.owner
and b.object_name = c.segment_name
group by to_char(end_interval_time, 'MM/DD/YY'))
order by to_date(mydate, 'MM/DD/YY');

--Find out fast growing Objects within Database
SELECT b.tsname tablespace_name

, MAX(b.used_size_mb) cur_used_size_mb

, round(AVG(inc_used_size_mb),2)avg_increas_mb

FROM (

  SELECT a.days, a.tsname, used_size_mb

  , used_size_mb - LAG (used_size_mb,1)  OVER ( PARTITION BY a.tsname ORDER BY a.tsname,a.days) inc_used_size_mb

  FROM (

      SELECT TO_CHAR(sp.begin_interval_time,'MM-DD-YYYY') days

       ,ts.tsname

       ,MAX(round((tsu.tablespace_usedsize* dt.block_size )/(1024*1024),2)) used_size_mb

      FROM DBA_HIST_TBSPC_SPACE_USAGE tsu, DBA_HIST_TABLESPACE_STAT ts

       ,DBA_HIST_SNAPSHOT sp, DBA_TABLESPACES dt

      WHERE tsu.tablespace_id= ts.ts# AND tsu.snap_id = sp.snap_id

       AND ts.tsname = dt.tablespace_name  AND sp.begin_interval_time > sysdate-180

      GROUP BY TO_CHAR(sp.begin_interval_time,'MM-DD-YYYY'), ts.tsname

      ORDER BY ts.tsname, days

  ) A

) b GROUP BY b.tsname ORDER BY b.tsname;



--Estado de backup de rman
select to_char(START_TIME,'DD MON YY HH24:Mi') START_TIME,to_char(END_TIME,'DD MON YY HH24:Mi') END_TIME ,OUTPUT_BYTES/1000000  PROCESSED_IN_MB,STATUS from v$rman_status where trunc(START_TIME)> trunc(sysdate) - 20;


--crecimiento de la BD
SET LINESIZE 200
SET PAGESIZE 200
COL "Database Size" FORMAT a13
COL "Used Space" FORMAT a11
COL "Used in %" FORMAT a11
COL "Free in %" FORMAT a11
COL "Database Name" FORMAT a13
COL "Free Space" FORMAT a12
COL "Growth DAY" FORMAT a11
COL "Growth WEEK" FORMAT a12
COL "Growth DAY in %" FORMAT a16
COL "Growth WEEK in %" FORMAT a16
SELECT
(select min(creation_time) from v$datafile) "Create Time",
(select name from v$database) "Database Name",
ROUND((SUM(USED.BYTES) / 1024 / 1024 ),2) || ' MB' "Database Size",
ROUND((SUM(USED.BYTES) / 1024 / 1024 ) - ROUND(FREE.P / 1024 / 1024 ),2) || ' MB' "Used Space",
ROUND(((SUM(USED.BYTES) / 1024 / 1024 ) - (FREE.P / 1024 / 1024 )) / ROUND(SUM(USED.BYTES) / 1024 / 1024 ,2)*100,2) || '% MB' "Used in %",
ROUND((FREE.P / 1024 / 1024 ),2) || ' MB' "Free Space",
ROUND(((SUM(USED.BYTES) / 1024 / 1024 ) - ((SUM(USED.BYTES) / 1024 / 1024 ) - ROUND(FREE.P / 1024 / 1024 )))/ROUND(SUM(USED.BYTES) / 1024 / 1024,2 )*100,2) || '% MB' "Free in %",
ROUND(((SUM(USED.BYTES) / 1024 / 1024 ) - (FREE.P / 1024 / 1024 ))/(select sysdate-min(creation_time) from v$datafile),2) || ' MB' "Growth DAY",
ROUND(((SUM(USED.BYTES) / 1024 / 1024 ) - (FREE.P / 1024 / 1024 ))/(select sysdate-min(creation_time) from v$datafile)/ROUND((SUM(USED.BYTES) / 1024 / 1024 ),2)*100,3) || '% MB' "Growth DAY in %",
ROUND(((SUM(USED.BYTES) / 1024 / 1024 ) - (FREE.P / 1024 / 1024 ))/(select sysdate-min(creation_time) from v$datafile)*7,2) || ' MB' "Growth WEEK",
ROUND((((SUM(USED.BYTES) / 1024 / 1024 ) - (FREE.P / 1024 / 1024 ))/(select sysdate-min(creation_time) from v$datafile)/ROUND((SUM(USED.BYTES) / 1024 / 1024 ),2)*100)*7,3) || '% MB' "Growth WEEK in %"
FROM    (SELECT BYTES FROM V$DATAFILE
UNION ALL
SELECT BYTES FROM V$TEMPFILE
UNION ALL
SELECT BYTES FROM V$LOG) USED,
(SELECT SUM(BYTES) AS P FROM DBA_FREE_SPACE) FREE
GROUP BY FREE.P;

--Saber quien bloqueo una cuenta de oracle----

   CREATE TABLE sys.logon_trigger
(
USERNAME VARCHAR2(30),
USERHOST VARCHAR2(128),
TIMESTAMP DATE
);


CREATE OR REPLACE TRIGGER sys.logon_trigger
AFTER SERVERERROR ON DATABASE
BEGIN
  IF (IS_SERVERERROR(1017)) THEN
    INSERT INTO logon_trigger VALUES(SYS_CONTEXT('USERENV', 'AUTHENTICATED_IDENTITY'), SYS_CONTEXT('USERENV', 'HOST'), SYSDATE);
    COMMIT;
  END IF;
END;
/


SELECT * FROM sys.logon_trigger ORDER BY TIMESTAMP DESC;

-----------
--Cuando sale el error del agente disable XPs

sp_configure 'show advanced options', 1;  
GO  
RECONFIGURE;  
GO  
sp_configure 'Agent XPs', 1;  
GO  
RECONFIGURE  
GO  

--------------------------Inmemory ----------------

ALTER TABLE OCDM_SYS.DWR_ACCT INMEMORY;
ALTER TABLE OCDM_SYS.DWR_CUST INMEMORY;
ALTER TABLE OCDM_SYS.DWR_SBRP INMEMORY;
ALTER TABLE OCDM_SYS.DWR_ACCS_MTHD INMEMORY;

select name,currently_used from dba_feature_usage_statistics where name like '%In-Memory%' ;

SELECT OWNER, TABLE_NAME, INMEMORY FROM DBA_TABLES WHERE OWNER='OCDM_SYS' AND INMEMORY='ENABLED';

SELECT TABLE_NAME,PARTITION_NAME,INMEMORY FROM DBA_TAB_PARTITIONS WHERE TABLE_OWNER='OCDM_SYS' AND INMEMORY='ENABLED' and table_name in ('DWR_ACCT','DWR_CUST','DWR_ACCS_MTH','DWR_SBRP');

SELECT TABLE_NAME,PARTITION_NAME,SUBPARTITION_NAME,INMEMORY FROM DBA_TAB_SUBPARTITIONS WHERE TABLE_OWNER='OCDM_SYS' AND INMEMORY='ENABLED';

-------------------------------

OBIEE
--archivo de configuracion
cd /u00/app/oracle/obiee_12.2.1.2.0/user_projects/domains/bi/pending/fmwconfig/biconfig/OBIPS/

--ubicacion de servicios
cd /u00/app/oracle/obiee_12.2.1.2.0/user_projects/domains/bi/bitools/bin


----------------------------SWAP ---------------
 So who is using my swap space on this Linux system? I can run the following command to find out.
for file in /proc/*/status ; do awk '/VmSwap|Name/{printf $2 " " $3}END{print ""}' $file; done | sort -k 2 -n
for file in /proc/*/status ; do awk '/VmSwap|Name/{printf $2 " " $3}END{ print ""}' $file; done | sort -k 2 -n -r | less



-----espacio ocupado por la papelera de reciclaje.  recyble_bin

 select sum(space*8)/1024 space_in_MB from dba_recyclebin;

 ------------buscar nombre de particion 

WITH DATA AS (
select   partition_name, 
       to_date (
          trim (
          '''' from regexp_substr (
                     extractvalue (
                       dbms_xmlgen.getxmltype (
                       'select high_value from all_tab_partitions where table_name='''
                                || table_name
                                || ''' and table_owner = '''
                                || table_owner
                                || ''' and partition_name = '''
                                || partition_name
                                || ''''),
                             '//text()'),
                          '''.*?''')),
          'syyyy-mm-dd hh24:mi:ss')
          high_value_in_date_format
  FROM all_tab_partitions
 WHERE table_name = 'DWB_CHARGING_ADJ' AND table_owner = 'OCDM_SYS'
 )
 SELECT partition_name FROM DATA
 WHERE to_char(high_value_in_date_format, 'DD/MON/YYYY' ) = trunc(sysdate - 91)
 
***********************
*
*CREATE OR REPLACE FUNCTION part_hv_to_date (p_table_owner IN VARCHAR2,
 p_table_name IN VARCHAR2,
 p_partition_name IN VARCHAR2)
 RETURN DATE
-- -----------------------------------------------------------------------------------
-- File Name : https://oracle-base.com/dba/miscellaneous/part_hv_to_date.sql
-- Author : Tim Hall
-- Description : Create a function to turn partition HIGH_VALUE column to a date.
-- Call Syntax : @part_hv_to_date
-- Last Modified: 19/01/2012
-- Notes : Has to re-select the value from the view as LONG cannot be passed as a parameter.
-- Example call:
--
-- SELECT a.partition_name, 
-- part_hv_to_date(a.table_owner, a.table_name, a.partition_name) as high_value
-- FROM all_tab_partitions a;
--
-- Does no error handling. 
-- -----------------------------------------------------------------------------------
AS
 l_high_value VARCHAR2(32767);
 l_date DATE;
BEGIN
 SELECT high_value
 INTO l_high_value
 FROM all_tab_partitions
 WHERE table_owner = p_table_owner
 AND table_name = p_table_name
 AND partition_name = p_partition_name;
 
 EXECUTE IMMEDIATE 'SELECT ' || l_high_value || ' FROM dual' INTO l_date;
 RETURN l_date;
END;
/
------------  


Funciona  para buscar particiones con  nombre raro

WITH DATA AS (
select   partition_name, 
       to_date (
          trim (
          '''' from regexp_substr (
                     extractvalue (
                       dbms_xmlgen.getxmltype (
                       'select high_value from all_tab_partitions where table_name='''
                                || table_name
                                || ''' and table_owner = '''
                                || table_owner
                                || ''' and partition_name = '''
                                || partition_name
                                || ''''),
                             '//text()'),
                          '''.*?''')),
          'syyyy-mm-dd hh24:mi:ss')
          high_value_in_date_format
  FROM all_tab_partitions
 WHERE table_name = 'DWB_CHARGING_ADJ' AND table_owner = 'OCDM_SYS'
 )
  SELECT * FROM DATA
 WHERE to_char(high_value_in_date_format, 'DD/MON/YYYY' ) = trunc(sysdate - 91);

/



-----crear  cascaron

select 'create tablespace ' || df.tablespace_name || chr(10)
 || ' datafile ''' || df.file_name || ''' size ' || df.bytes 
 || decode(autoextensible,'N',null, chr(10) || ' autoextend on maxsize ' 
 || maxbytes) 
 || chr(10) 
 || 'default storage ( initial ' || initial_extent 
 || decode (next_extent, null, null, ' next ' || next_extent )
 || ' minextents ' || min_extents
 || ' maxextents ' ||  decode(max_extents,'2147483645','unlimited',max_extents) 
 || ') ;'
 from dba_data_files df, dba_tablespaces t
 where df.tablespace_name=t.tablespace_name 



mediate3 root/laso5276

#FORMATO DEL CRONTAB
#minute (0-59), hour (0-23), day of the month (1-31), month of the year (1-12), day of the week (0-6 with 0=Sunday).


--Buscar un proceso de SO en BD sino aparece entonces kill -
SELECT s.sid,s.serial#,p.spid,s.username,s.program FROM v$session s
JOIN v$process p ON p.addr = s.paddr
WHERE s.sid='&process'; 



Crecimiento SQL Server:  GROWTH SQL SERVER

-- Script T-SQL para analizar el crecimiento de tamaño de la base de datos utilizando la historia de copias de respaldo.
DECLARE @endDate DATETIME, @months smallint;
SET @endDate = GETDATE();    -- Incluir las estadísticas de las copias de respaldo de hoy.
SET @months = 6;            -- hasta 6 meses atrás.

;WITH HIST AS
   (SELECT BS.database_name AS DatabaseName
          ,YEAR(BS.backup_start_date) * 100
           + MONTH(BS.backup_start_date) AS YearMonth
          ,CONVERT(numeric(10, 1), MIN(BF.file_size / 1048576.0)) AS MinSizeMB
          ,CONVERT(numeric(10, 1), MAX(BF.file_size / 1048576.0)) AS MaxSizeMB
          ,CONVERT(numeric(10, 1), AVG(BF.file_size / 1048576.0)) AS AvgSizeMB
    FROM msdb.dbo.backupset AS BS
         INNER JOIN
         msdb.dbo.backupfile AS BF
             ON BS.backup_set_id = BF.backup_set_id
    WHERE NOT BS.database_name IN
              ('master', 'msdb', 'model', 'tempdb')
          AND BF.file_type = 'D'
          AND BS.backup_start_date BETWEEN DATEADD(mm, - @months, @endDate) AND @endDate
    GROUP BY BS.database_name
            ,YEAR(BS.backup_start_date)
            ,MONTH(BS.backup_start_date))SELECT MAIN.DatabaseName
      ,MAIN.YearMonth
      ,MAIN.MinSizeMB
      ,MAIN.MaxSizeMB
      ,MAIN.AvgSizeMB
      ,MAIN.AvgSizeMB 
       - (SELECT TOP 1 SUB.AvgSizeMB
          FROM HIST AS SUB
          WHERE SUB.DatabaseName = MAIN.DatabaseName
                AND SUB.YearMonth < MAIN.YearMonth
          ORDER BY SUB.YearMonth DESC) AS GrowthMB FROM HIST AS MAIN ORDER BY MAIN.DatabaseName
        ,MAIN.YearMonth;
GO     


RECENT SQL SERVER BACKUP - RESPALDO SQL SERVER

SELECT d.name AS "Database",
       ISNULL(CONVERT(VARCHAR,b.backupdate,120),'NEVER') AS "Last Full Backup"
FROM sys.databases d
LEFT JOIN (SELECT database_name,type,MAX(backup_finish_date) backupdate FROM backupset
           WHERE type LIKE 'D'
           GROUP BY database_name,type) b on d.name=b.database_name
WHERE (backupdate IS NULL OR backupdate < getdate()-1)
SELECT d.name AS "Database",
       ISNULL(CONVERT(VARCHAR,b.backupdate,120),'NEVER') AS "Last Log Backup"
FROM sys.databases d
LEFT JOIN (SELECT database_name,type,MAX(backup_finish_date) backupdate FROM backupset
           WHERE type LIKE 'L'
           GROUP BY database_name,type) b on d.name=b.database_name
WHERE recovery_model = 1
  AND (backupdate IS NULL OR backupdate < getdate()-1)     
  


( _¯:_¯:_¯:_¯[_¯ _¯]_¯:_¯:_¯:_¯ ) (List of Most Recent SQL Server Backups ) ELAPSED BACKUP RESPALDO ( _¯:_¯:_¯:_¯[_¯ _¯]_¯:_¯:_¯:_¯ )


DECLARE @dbname sysname
SET @dbname = NULL --set this to be whatever dbname you want
SELECT 
  bup.user_name AS [User],
  bup.database_name AS [Database],
  bup.server_name AS [Server],
  bup.backup_start_date AS [Backup Started],
  bup.backup_finish_date AS [Backup Finished]
  ,CAST((CAST(DATEDIFF(s, bup.backup_start_date, bup.backup_finish_date) AS int))/3600 AS varchar) + ' hours, ' 
  + CAST((CAST(DATEDIFF(s, bup.backup_start_date, bup.backup_finish_date) AS int))/60 AS varchar)+ ' minutes, '
  + CAST((CAST(DATEDIFF(s, bup.backup_start_date, bup.backup_finish_date) AS int))%60 AS varchar)+ ' seconds'
  AS [Total Time]
FROM msdb.dbo.backupset bup
WHERE bup.backup_set_id IN
  (SELECT MAX(backup_set_id) 
   FROM msdb.dbo.backupset
   WHERE database_name = ISNULL(@dbname, database_name) --if no dbname, then return all
   AND type = 'D' --only interested in the time of last full backup
   GROUP BY database_name) 
/* COMMENT THE NEXT LINE IF YOU WANT ALL BACKUP HISTORY */
AND bup.database_name IN (SELECT name FROM master.dbo.sysdatabases)
ORDER BY bup.database_name
 


( _¯:_¯:_¯:_¯[_¯ _¯]_¯:_¯:_¯:_¯ ) (UNDO) ( _¯:_¯:_¯:_¯[_¯ _¯]_¯:_¯:_¯:_¯ )
https://blog.oracle48.nl/oracle-database-undo-space-explained/
*********************

SELECT TO_CHAR(BEGIN_TIME, 'MM/DD/YYYY HH24:MI:SS') BEGIN_TIME,
  TO_CHAR(END_TIME, 'MM/DD/YYYY HH24:MI:SS') END_TIME,
  UNDOTSN, UNDOBLKS, TXNCOUNT, MAXCONCURRENCY AS "MAXCON"
FROM v$UNDOSTAT WHERE rownum <= 100;

select tablespace_name tablespace, status, sum(bytes)/1024/1024 sum_in_mb, count(*) counts from dba_undo_extents group by tablespace_name, status order by 1,2;


select u.tablespace_name tablespace, s.username, u.status, sum(u.bytes)/1024/1024 sum_in_mb, count(u.segment_name) seg_cnts from dba_undo_extents u left join v$transaction t on u.segment_name = '_SYSSMU' || t.xidusn || '$' left join v$session s on t.addr = s.taddr group by u.tablespace_name, s.username, u.status order by 1,2,3;


--Summary
--Active undo is used by active transactions: rollback and read consistency.
--Expired undo is old and can be reused.
--Unexpired undo is used for read consistency, retention time has not passed yet.
--Unexpired undo can be stolen for Active undo. If this is happening you can get ORA-01555 before Undo retention has passed.
--Unexpired undo can be secured by setting the RETENTION GUARANTEE option when creating the Undo tablespace (see Undo Sizing).


select status,
  round(sum_bytes / (1024*1024), 0) as MB,
  round((sum_bytes / undo_size) * 100, 0) as PERC
from
(
  select status, sum(bytes) sum_bytes
  from dba_undo_extents
  group by status
),
(
  select sum(a.bytes) undo_size
  from dba_tablespaces c
    join v$tablespace b on b.name = c.tablespace_name
    join v$datafile a on a.ts# = b.ts#
  where c.contents = 'UNDO'
    and c.status = 'ONLINE'
);

--Normal’ operation
--STATUS            MB       PERC
----------- ---------- ----------
--ACTIVE            10          4
--EXPIRED          110         43
--UNEXPIRED         25         10
--This is an example of ‘normal’ contents of the Undo tablespace. The system is using ACTIVE extents, some are UNEXPIRED used for read consistency and there are EXPIRED extents which can be reused.
--
--Out of Free/EXPIRED extents
--STATUS            MB       PERC
----------- ---------- ----------
--ACTIVE           230         90
--EXPIRED            0          0
--UNEXPIRED         26         10
--When the system is under load and the EXPIRED extents are near 0%, the total of ACTIVE and UNEXPIRED is near 100% and the Undo tablespace is not able to extend, Oracle will steal UNEXPIRED extents for ACTIVE extents. If this is the case you might expect ORA-01555 errors, because Undo retention can not be met.
--
--Out of Undo space
--STATUS            MB       PERC
----------- ---------- ----------
--ACTIVE           255        100
--EXPIRED            0          0
--UNEXPIRED          1          0
--When the system is under load and the ACTIVE extents are near 100%, the total of EXPIRED and UNEXPIRED is near 0% and the Undo Tablespace is not able to extend, Oracle is not able to allocate free extents or steal UNEXPIRED extents for ACTIVE extents. If this is the case you might expect ORA-30036 errors.
--
--Retention to large or UNDO to small?
--STATUS            MB       PERC
----------- ---------- ----f------
--ACTIVE             2          1
--EXPIRED            0          0
--UNEXPIRED        254         99
--In this case, all undo extents are used for the retention period. It might be the retention is to large, or the UNDO tablespace is to small. A DBA must investigate this and take a decision!



-----------------


The error -***integrity constraint (LTERTIO76.FK_MULTIINSTANCESERVICE_MOP3) violated - parent key not found means there are some entry in MultiInstanceService table which are not there in Subscriberservice table.

So the query you using to identify isn’t correct

select count(*) from LTERTIO76.SUBSCRIBERSERVICE a
where a.subscriberkey not in (
select subscriberkey from ltertio76.multiinstanceservice b where a.subscriberkey = b.subscriberkey );--54,131,402

you also need to understand that the FK is in two columns so you really can’t just use Subscriberkey column to identify.

Try using below

select * from MULTIINSTANCESERVICE a
where   not exists (
         select null
         from   SUBSCRIBERSERVICE b
         where  b.subscriberkey = a.subscriberkey and b.servicename=a.servicename);



×,.·´¨'°÷·..§ RELOCATE DE INSTANCIA CON SERVICIO PREFERIDO §.·´¨'°÷·..×


Como comentario, se bajó la instancia de la siguiente manera considerando lo de la información de referencia.

[oracle@rac01-adm02vm01 ~]$ srvctl stop instance -d ocdmdb -i ocdmdb2 –failover -> Referencia https://community.oracle.com/thread/4117991
[oracle@rac01-adm02vm01 ~]$ ps -ef | grep pmon
oracle    47050 126504  0 20:01 pts/0    00:00:00 grep pmon
grid      88729      1  0 Sep02 ?        00:05:13 asm_pmon_+ASM2


Esto debido a que el ambiente cuenta con un servicio que es preferido en ambas instancias y se requería que se reubicara en la instancia 1.

[oracle@rac01-adm02vm01 ~]$ srvctl config service -db ocdmdb -service ocdmpa

Service is enabled
Preferred instances: ocdmdb,ocdmdb2
Available instances:


Keep Alive
http://www.tldp.org/HOWTO/TCP-Keepalive-HOWTO/usingkeepalive.html

___________________________________
¦¦¦¦¦¦¦¦¦¯¦_¯_¯¦¦¦¦¦¦¦¯¦_¯_¯¦¦¦¦¦¦                                    
¦¦¦¦ ¦¦¦¦¦¦¦¯¦_¦_¦¦¦¯¦¦¦ ¯¦_¦_¦¦¦





Realmente la migración puede resumirse en estos pasos:

1.	Hacer el backup de las BD(PHONE y DWH) en el servidor cwp-sfr-data1
2.	Copiar por la red el respaldo  una vez termine hacia el nuevo servidor cwp-vm-data1.
3.	Restaurar los respaldos de las BD(PHONE y DWH) en cwp-vm-data1
4.	Ejecutar el script abajo enviado para exportar los login del servidor cwp-sfr-data1, la salida de este script  debe copiarse  y ejecutarse luego en el nuevo servidor(cwp-vm-data1)
5.	Asignarle luego a los Login: comport y pronet, privilegios en el user Mapping de DWH y de PHONE como db_owner en ambas BD.
6.	Que Jorge Lasso haga las validaciones

Es fue el script utilizado para hacer la exportación de los login en SQL 2000 del servidor cwp-sfr-data1.  La salida de este script  debe copiarse  y ejecutarse luego en el nuevo servidor(cwp-vm-data1)

/************************************************************************************************
                *
                *             Purpose:             To capture all the SQL Server logins with the binary password regardless of SQL version.  
                *                                                            Script is compatiable with SQL 7 / SQL 2000 / SQL 2005. Need to save the results
                *                                                            to a text file and run within a new query window.
                *
                *             Created Date:    Inital - 01/13/2006
                *
                *             Revsions:            01/15/2006 - Made some formatting changes to the output text.
                *                                                            01/16/2006 - Made syntax change to account for Binary version of SQL Server.
                *                                                            01/16/2006 - Change version SQL version check because of syntax differences between 
                *                                                                                                            SQL 2000 and 2005 with @@version.
                *                                                            04/10/2007 - Made change to deal with user names that begin with numbers instead of characters.
                *
************************************************************************************************/

                USE master
                GO
                IF OBJECT_ID ('sp_hexadecimal') IS NOT NULL
                  DROP PROCEDURE sp_hexadecimal
                GO
                CREATE PROCEDURE sp_hexadecimal
                               @binvalue varbinary(256),
                               @hexvalue varchar(256) OUTPUT
                AS
                DECLARE @charvalue varchar(256)
                DECLARE @i int
                DECLARE @length int
                DECLARE @hexstring char(16)
                SELECT @charvalue = '0x'
                SELECT @i = 1
                SELECT @length = DATALENGTH (@binvalue)
                SELECT @hexstring = '0123456789ABCDEF'
                WHILE (@i <= @length)
                BEGIN
                  DECLARE @tempint int
                  DECLARE @firstint int
                  DECLARE @secondint int
                  SELECT @tempint = CONVERT(int, SUBSTRING(@binvalue,@i,1))
                  SELECT @firstint = FLOOR(@tempint/16)
                  SELECT @secondint = @tempint - (@firstint*16)
                  SELECT @charvalue = @charvalue +
                               SUBSTRING(@hexstring, @firstint+1, 1) +
                               SUBSTRING(@hexstring, @secondint+1, 1)
                  SELECT @i = @i + 1
                END
                SELECT @hexvalue = @charvalue
                GO

                IF OBJECT_ID ('sp_help_revlogin') IS NOT NULL
                  DROP PROCEDURE sp_help_revlogin
                GO
                CREATE PROCEDURE sp_help_revlogin @login_name sysname = NULL AS
                DECLARE @name    sysname
                DECLARE @xstatus int
                DECLARE @binpwd  varbinary (256)
                DECLARE @txtpwd  sysname
                DECLARE @tmpstr  varchar (256)
                DECLARE @SID_varbinary varbinary(85)
                DECLARE @SID_string varchar(256)

                IF (@login_name IS NULL)
                  DECLARE login_curs CURSOR FOR
                               SELECT sid, name, xstatus, password FROM master..sysxlogins
                               WHERE srvid IS NULL AND name <> 'sa'
                ELSE
                  DECLARE login_curs CURSOR FOR
                               SELECT sid, name, xstatus, password FROM master..sysxlogins
                               WHERE srvid IS NULL AND name = @login_name
                OPEN login_curs
                FETCH NEXT FROM login_curs INTO @SID_varbinary, @name, @xstatus, @binpwd
                IF (@@fetch_status = -1)
                BEGIN
                  PRINT 'No login(s) found.'
                  CLOSE login_curs
                  DEALLOCATE login_curs
                  RETURN -1
                END
                SET @tmpstr = '/* sp_help_revlogin script '
                PRINT @tmpstr
                SET @tmpstr = '** Generated '
                  + CONVERT (varchar, GETDATE()) + ' on ' + @@SERVERNAME + ' */'
                PRINT @tmpstr
                PRINT ''
                PRINT 'DECLARE @pwd sysname'
                WHILE (@@fetch_status <> -1)
                BEGIN
                  IF (@@fetch_status <> -2)
                  BEGIN
                               PRINT ''
                               SET @tmpstr = '-- Login: ' + @name
                               PRINT @tmpstr
                               IF (@xstatus & 4) = 4
                               BEGIN -- NT authenticated account/group
                                 IF (@xstatus & 1) = 1
                                 BEGIN -- NT login is denied access
                                               SET @tmpstr = 'EXEC master..sp_denylogin ''' + @name + ''''
                                               PRINT @tmpstr
                                 END
                                 ELSE BEGIN -- NT login has access
                                               SET @tmpstr = 'EXEC master..sp_grantlogin ''' + @name + ''''
                                               PRINT @tmpstr
                                 END
                               END
                               ELSE BEGIN -- SQL Server authentication
                                 IF (@binpwd IS NOT NULL)
                                 BEGIN -- Non-null password
                                               EXEC sp_hexadecimal @binpwd, @txtpwd OUT
                                               IF (@xstatus & 2048) = 2048
                                                 SET @tmpstr = 'SET @pwd = CONVERT (varchar(256), ' + @txtpwd + ')'
                                               ELSE
                                                 SET @tmpstr = 'SET @pwd = CONVERT (varbinary(256), ' + @txtpwd + ')'
                                               PRINT @tmpstr
                               EXEC sp_hexadecimal @SID_varbinary,@SID_string OUT
                                               SET @tmpstr = 'EXEC master..sp_addlogin ''' + @name + ''
                                                 + ''', @pwd, @sid = ' + @SID_string + ', @encryptopt = '
                                 END
                                 ELSE BEGIN
                                               -- Null password
                               EXEC sp_hexadecimal @SID_varbinary,@SID_string OUT
                                               SET @tmpstr = 'EXEC master..sp_addlogin ''' + @name + ''
                                                 + ''', NULL, @sid = ' + @SID_string + ', @encryptopt = '
                                 END
                                 IF (@xstatus & 2048) = 2048
                                               -- login upgraded from 6.5
                                               SET @tmpstr = @tmpstr + '''skip_encryption_old'''
                                 ELSE
                                               SET @tmpstr = @tmpstr + '''skip_encryption'''
                                 PRINT @tmpstr
                               END
                  END
                  FETCH NEXT FROM login_curs INTO @SID_varbinary, @name, @xstatus, @binpwd
                  END
                CLOSE login_curs
                DEALLOCATE login_curs
                RETURN 0
                GO
                IF OBJECT_ID ('seeMigrateSQLLogins') IS NOT NULL
                  DROP PROCEDURE seeMigrateSQLLogins
                GO
                create procedure seeMigrateSQLLogins @login_name sysname = NULL
                as
                declare
                @name char(50),
                @binpwd  varbinary (256),
                @txtpwd  sysname,
                @tmpstr  varchar (256),
                @SID_varbinary varbinary(85),
                @SID_string varchar(256),
                @Is_Policy bit,
                @Is_Exp bit,
                @type char(1),
                @Pol char(3),
                @Exp char(3)
                set nocount on
                create table #logins (
                [name] nvarchar(128) NOT NULL,
                [sid] varbinary(85) NOT NULL,
                [type] char(1) NOT NULL,
                [is_policy_checked] bit default 0,
                [is_expiration_checked] bit default 0,
                [password_hash] varbinary(256) )
                insert #logins (name, sid, type)
                select name, sid, type from sys.server_principals where 
                               (type_desc = 'SQL_LOGIN' or type_desc = 'WINDOWS_LOGIN') and name <> 'sa' and name <> 'NT AUTHORITY\SYSTEM'
                update a set a.is_policy_checked = b.is_policy_checked, a.is_expiration_checked = b.is_expiration_checked, a.password_hash = b.password_hash
                               from #logins a, sys.sql_Logins b
                               where a.sid = b.sid
                set nocount off
                IF (@login_name IS NULL) --Not a single user, get the list
                  DECLARE seelogin_curs CURSOR FOR
                               SELECT name, sid, password_hash, type, is_policy_checked, is_expiration_checked FROM #logins
                               WHERE name <> 'sa'
                ELSE
                  DECLARE seelogin_curs CURSOR FOR
                               SELECT name, sid, password_hash, type, is_policy_checked, is_expiration_checked FROM #logins
                               WHERE name = @login_name
                OPEN seelogin_curs
                FETCH NEXT FROM seelogin_curs INTO @name, @SID_varbinary, @binpwd, @type, @Is_Policy, @Is_Exp
                IF (@@fetch_status = -1)
                BEGIN
                  PRINT 'No login(s) found.'
                  CLOSE seelogin_curs
                  DEALLOCATE seelogin_curs
                END
                SET @tmpstr = '/* seeMigrateSQLLogins - For SQL Server 2005 Only '
                PRINT @tmpstr
                SET @tmpstr = '** Generated '
                  + CONVERT (varchar, GETDATE()) + ' on ' + @@SERVERNAME + ' */'
                PRINT @tmpstr
                PRINT ''
                WHILE (@@fetch_status <> -1)
                BEGIN
                               IF @type = 'S'
                                               BEGIN
                                                               PRINT '/* SQL Login ******************/'
                                                               EXEC sp_hexadecimal @binpwd, @txtpwd OUT
                                                               EXEC sp_hexadecimal @SID_varbinary, @SID_string OUT
                                                               IF @Is_Policy = 1 Begin set @Pol = 'ON' End ELSE Begin set @Pol = 'OFF' END     
                                                               IF @Is_Exp = 1 Begin set @Exp = 'ON' End ELSE Begin set @Exp = 'OFF' END        
                                                               SET @tmpstr = 'Create Login [' + rtrim(@name) + '] WITH PASSWORD = ' + @txtpwd + ' hashed, sid = ' + @SID_string + ', CHECK_POLICY = ' + @Pol + ', CHECK_EXPIRATION = ' + @Exp
                                                               PRINT @tmpstr
                                                               PRINT ''
                                               END
                               Else
                                               BEGIN
                                                               PRINT '/* SQL Login ******************/'
                                                               EXEC sp_hexadecimal @SID_varbinary, @SID_string OUT
                                                               SET @tmpstr = 'Create Login [' + rtrim(@name) + '] FROM WINDOWS; '
                                                               PRINT @tmpstr
                                                               PRINT ''
                                               END
                FETCH NEXT FROM seelogin_curs INTO @name, @SID_varbinary, @binpwd, @type, @Is_Policy, @Is_Exp
                END
                CLOSE seelogin_curs
                DEALLOCATE seelogin_curs
                drop table #logins
                GO

                declare
                @version char(5)

                --Get the current version of SQL Server running
                select @version = substring(@@version,29,4)

                if @version = '9.00'
                               Begin
                                               exec seeMigrateSQLLogins
                               End
                Else
                               begin
                                               exec sp_help_revlogin
                               End

                IF OBJECT_ID ('sp_hexadecimal') IS NOT NULL
                  DROP PROCEDURE sp_hexadecimal
                GO
                IF OBJECT_ID ('sp_help_revlogin') IS NOT NULL
                  DROP PROCEDURE sp_help_revlogin
                GO
                IF OBJECT_ID ('seeMigrateSQLLogins') IS NOT NULL
                  DROP PROCEDURE seeMigrateSQLLogins
                GO
/* End Script */


×,.·´¨'°÷·..§ SHRINK DATAFILES ORACLE RESIZE §.·´¨'°÷·..×


select value from v$parameter where name = 'db_block_size'

select 'alter database datafile '''||file_name||''' resize ' ||
ceil( (nvl(hwm,1)*&&blksize)/1024/1024 ) || 'm;' cmd
from dba_data_files a,
( select file_id, max(block_id+blocks-1) hwm
from dba_extents
group by file_id ) b
where a.file_id = b.file_id(+)
and ceil( blocks*&&blksize/1024/1024) -
ceil( (nvl(hwm,1)*&&blksize)/1024/1024 ) > 0


http://www.oracle-ckpt.com/how-to-shrink-datafiles-adjusting-hwm/


select value from v$parameter where name = 'db_block_size';
/
select file_name,
       ceil( (nvl(hwm,1)*&&blksize)/1024/1024 ) smallest,
       ceil( blocks*&&blksize/1024/1024) currsize,
       ceil( blocks*&&blksize/1024/1024) -
       ceil( (nvl(hwm,1)*&&blksize)/1024/1024 ) savings
from dba_data_files a,
     ( select file_id, max(block_id+blocks-1) hwm
         from dba_extents
        group by file_id ) b
where a.file_id = b.file_id(+) order by savings desc


--COLOCAS el valor del bloque : puede ser 8096 y luego  lo que sale se le hace resize tomando como referencia el campo smallest y haciendole resize a un valor mas grande que el campo smallest.

Ejemplo:

file_name                                          smallest currsize  savings 
+DATA/rmgprd/datafile/cdr_index_001.306.880381643	  268	     25300	    25032
+DATA/rmgprd/datafile/users.573.1018674969	        6559	    30360	    23801

alter database datafile '+DATA/rmgprd/datafile/cdr_index_001.306.880381643' resize 500m;
alter database datafile '+DATA/rmgprd/datafile/users.573.1018674969' resize 7000m;

Lo haces para varios y  también se verifica a nivel de tablespaces y diskgroups 
                   ANTES
[grid@cwp-jfr-wbms01 ~]$ asmcmd
ASMCMD> lsdg
State    Type    Rebal  Sector  Block       AU  Total_MB  Free_MB  Req_mir_free_MB  Usable_file_MB  Offline_disks  Voting_files  Name
MOUNTED  EXTERN  Y         512   4096  4194304   3174400    37980                0           37980              0             N  DATA/
MOUNTED  HIGH    N         512   4096  4194304     10180     8936             4072            1621              0             Y  DGGRID/

                DESPUES
ASMCMD> lsdg
State    Type    Rebal  Sector  Block       AU  Total_MB  Free_MB  Req_mir_free_MB  Usable_file_MB  Offline_disks  Voting_files  Name
MOUNTED  EXTERN  Y         512   4096  4194304   3174400   137764                0          137764              0             N  DATA/
MOUNTED  HIGH    N         512   4096  4194304     10180     8936             4072            1621              0             Y  DGGRID/
ASMCMD>


--------------------------------------------------------------------------------------------------------------------------
Using NFS to Share RHEL 6 Folders with Remote Linux and UNIX Systems
Montar NFS en linux

https://www.techotopia.com/index.php/Using_NFS_to_Share_RHEL_6_Folders_with_Remote_Linux_and_UNIX_Systems

[oracle@cwp-jfr-setprod SETTLER]$ service nfs status
rpc.svcgssd is stopped
rpc.mountd is stopped
nfsd is stopped
rpc.rquotad is stopped
[oracle@cwp-jfr-setprod SETTLER]$ exit
logout
[root@cwp-jfr-setprod Backup02]# /sbin/service nfs status
rpc.svcgssd is stopped
rpc.mountd is stopped
nfsd is stopped
rpc.rquotad is stopped
[root@cwp-jfr-setprod Backup02]# /sbin/service nfs start
Starting NFS services:                                     [  OK  ]
Starting NFS quotas:                                       [  OK  ]
Starting NFS mountd:                                       [  OK  ]
Starting NFS daemon:                                       [  OK  ]
Starting RPC idmapd:                                       [  OK  ]
[root@cwp-jfr-setprod Backup02]# /sbin/service nfs status
rpc.svcgssd is stopped
rpc.mountd (pid 2466) is running...
nfsd (pid 2483 2482 2481 2480 2479 2478 2476 2475) is running...
rpc.rquotad (pid 2458) is running...
[root@cwp-jfr-setprod Backup02]# vi /etc/exports
[root@cwp-jfr-setprod Backup02]# /usr/sbin/exportfs -a
[root@cwp-jfr-setprod Backup02]# /usr/sbin/exportfs
/Backup02       172.18.3.137
[root@cwp-jfr-setprod Backup02]#


AHORA EN EL OTRO SERVER
[root@CWP-VM-SETDEV Backup_20190529]# mount -t nfs 172.18.2.50:/Backup02/rman/SETTLER /Backup02/rman/SETTLER
[root@CWP-VM-SETDEV Backup_20190529]# df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/mapper/vg_cwpvmwbdev-lv_root
                       50G  8.7G   38G  19% /
tmpfs                  12G  436M   12G   4% /dev/shm
/dev/sda1             477M   36M  416M   8% /boot
/dev/mapper/vg_cwpvmwbdev-lv_home
                       53G   25G   26G  49% /home
/dev/sdb1              15G   38M   14G   1% /tmp
/dev/sdc1              99G   24G   70G  26% /u01
/dev/sdd1             197G  135G   53G  72% /ora
/dev/sde1             5.8G   13M  5.5G   1% /ORACLE_HOME
/dev/sdf1             5.8G   13M  5.5G   1% /GRID_HOME
/dev/sdg1             788G  266G  483G  36% /ora1
/dev/sdh1              99G   60M   94G   1% /arch
/dev/sdi1             493G  183G  285G  40% /bmd
/dev/sdj1             4.8G   11M  4.6G   1% /bulkload
/dev/sdk1              71G   37G   31G  55% /dwf
/dev/sdl1              59G   52M   56G   1% /edr_extract
/dev/sdm1             5.8G   13M  5.5G   1% /ict_archive
/dev/sdn1              20G  2.6G   16G  14% /product/ict
/dev/sdo1             5.8G   13M  5.5G   1% /refdata
/dev/sds1              33G   22G  8.8G  72% /data
/dev/sdt1             6.8G   16M  6.4G   1% /index
/dev/sdu1              33G  3.5G   28G  12% /edr_data
/dev/sdv1             292G   89G  188G  33% /edr_index
/dev/sdw1             148G   50G   91G  36% /redo1
/dev/sdx1             194G   60M  184G   1% /redo2
/dev/sdy1              98G   60M   93G   1% /redo3
/dev/sdz1             2.9G  4.6M  2.8G   1% /redo4
/dev/sdaf1             40G  6.0G   32G  17% /dcs/appl01
/dev/sdag1             69G  1.3G   64G   2% /opt/dcs
/dev/sdah1             11G  557M  9.7G   6% /opt/dcs_7.0
/dev/sdai1             41G  6.0G   33G  16% /var/dcs_7.0
/dev/sdak1             11G  3.3G  6.9G  33% /dcs/data01
/dev/mapper/vg_TDB-lv_TDB
                      2.5T   75M  2.4T   1% /TDB
172.18.2.50:/Backup02/rman/SETTLER
                      788G  446G  302G  60% /Backup02/rman/SETTLER
[root@CWP-VM-SETDEV Backup_20190529]#



×,.·´¨'°÷·..§  Line Break Removal Tool     §.·´¨'°÷·..×  
×,.·´¨'°÷·..§  carriage return newline remover lineas caracteres especiales lync     §.·´¨'°÷·..×  
https://www.textfixer.com/tools/remove-line-breaks.php


 SE [Staging] GO /****** Object: StoredProcedure [dbo].[sp_update_stat_2020] Script Date: 04/06/2020 19:17:25 ******/ SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO ALTER procedure [dbo].[sp_update_stat_2020] --declaracion de variables para parametros recibidos AS BEGIN

 --declaracion de variables dentro del sp DECLARE @VART1 NVARCHAR(150); DECLARE @VART2 NVARCHAR(250);

 --Dropear la tabla temporal con las tablas para stas drop table tmp_tablas_para_estadisticas;

 --Cargar tabla en tmp_tablas_para_estadisticas SELECT tb.name AS [Table Name], st.name AS [Stat Name], STATS_DATE(tb.object_id,st.stats_id) AS [Last Updated] into tmp_tablas_para_estadisticas --insertar en tabla tmp FROM sys.stats AS st INNER JOIN sys.tables AS tb ON st.object_id = tb.object_id WHERE tb.type = 'U' --tipo tablas and STATS_DATE(tb.object_id,st.stats_id)not like '%2020%'and tb.name <>'FuzzyLookupMatchIndex_FLRef_180723_14:01:08_33068_0f6dc331-5dc0-47fd-8351-e9025b944a41' --Cursor para obtener las tablas para Stat anteriormentes consultadas

DECLARE CURSOR_1 CURSOR FOR select distinct[Table Name] from tmp_tablas_para_estadisticas where [Table Name] <> 'ordenes_pmo' and [Table Name] <> 'SETT_CARGA_CONTROL_ORIGINAL' -->tablas con problemas, no se actualizan OPEN CURSOR_1 FETCH NEXT FROM CURSOR_1 INTO @VART1 WHILE @@FETCH_STATUS = 0 BEGIN

 set @VART2='UPDATE STATISTICS dbo.['+ @VART1 + '];' exec (@VART2); --print @VART2; 

 FETCH NEXT FROM CURSOR_1 INTO @VART1 END --cursor

 CLOSE CURSOR_1 DEALLOCATE CURSOR_1
END--sp 



LAST BACKUP
--SQL SERVER

SELECT sdb.Name AS DatabaseName,
COALESCE(CONVERT(VARCHAR(12), MAX(bus.backup_finish_date), 101),'-') AS LastBackUpTime
FROM sys.sysdatabases sdb
LEFT OUTER JOIN msdb.dbo.backupset bus ON bus.database_name = sdb.name
GROUP BY sdb.Name




ULTIMO BACKUP
LAST RESPALDO

select input_type,(to_char( start_time,'DD-MON-RR HH24:MI:SS' )) ,(to_char( end_time,'DD-MON-RR HH24:MI:SS' )),status 
from V$RMAN_BACKUP_JOB_DETAILS 
where start_time between (sysdate-1) and (sysdate) 
order by start_time asc;


SELECT OPERATION, STATUS, OBJECT_TYPE, TO_CHAR(START_TIME,'MM/DD/YYYY:hh:mi:ss') as START_TIME,
TO_CHAR(END_TIME,'MM/DD/YYYY:hh:mi:ss') as END_TIME
FROM sys.V_$RMAN_STATUS WHERE START_TIME > SYSDATE -2 AND OPERATION = 'BACKUP'
--and object_type = 'DB FULL'
order by start_time desc


--Database Backups for all databases For Previous Week
SELECT 
CONVERT(CHAR(100), SERVERPROPERTY('Servername')) AS Server, 
msdb.dbo.backupset.database_name, 
msdb.dbo.backupset.backup_start_date, 
msdb.dbo.backupset.backup_finish_date, 
msdb.dbo.backupset.expiration_date, 
CASE msdb..backupset.type 
WHEN 'D' THEN 'Database' 
WHEN 'L' THEN 'Log' 
END AS backup_type, 
msdb.dbo.backupset.backup_size, 
msdb.dbo.backupmediafamily.logical_device_name, 
msdb.dbo.backupmediafamily.physical_device_name, 
msdb.dbo.backupset.name AS backupset_name, 
msdb.dbo.backupset.description 
FROM msdb.dbo.backupmediafamily 
INNER JOIN msdb.dbo.backupset ON msdb.dbo.backupmediafamily.media_set_id = msdb.dbo.backupset.media_set_id 
WHERE (CONVERT(datetime, msdb.dbo.backupset.backup_start_date, 102) >= GETDATE() - 7) 
ORDER BY 
msdb.dbo.backupset.database_name, 
msdb.dbo.backupset.backup_finish_date 

------------------------------------------------------------------------------------------- 
--Most Recent Database Backup for Each Database 
------------------------------------------------------------------------------------------- 
SELECT  
   CONVERT(CHAR(100), SERVERPROPERTY('Servername')) AS Server, 
   msdb.dbo.backupset.database_name,  
   MAX(msdb.dbo.backupset.backup_finish_date) AS last_db_backup_date 
FROM   msdb.dbo.backupmediafamily  
   INNER JOIN msdb.dbo.backupset ON msdb.dbo.backupmediafamily.media_set_id = msdb.dbo.backupset.media_set_id  
WHERE  msdb..backupset.type = 'D' 
GROUP BY 
   msdb.dbo.backupset.database_name  
ORDER BY  
   msdb.dbo.backupset.database_name 

   ------------------------------------------------------------------------------------------- 
--Most Recent Database Backup for Each Database - Detailed 
------------------------------------------------------------------------------------------- 
SELECT  
   A.[Server],  
   A.last_db_backup_date,  
   B.backup_start_date,  
   B.expiration_date, 
   B.backup_size,  
   B.logical_device_name,  
   B.physical_device_name,   
   B.backupset_name, 
   B.description 
FROM 
   ( 
   SELECT   
       CONVERT(CHAR(100), SERVERPROPERTY('Servername')) AS Server, 
       msdb.dbo.backupset.database_name,  
       MAX(msdb.dbo.backupset.backup_finish_date) AS last_db_backup_date 
   FROM    msdb.dbo.backupmediafamily  
       INNER JOIN msdb.dbo.backupset ON msdb.dbo.backupmediafamily.media_set_id = msdb.dbo.backupset.media_set_id  
   WHERE   msdb..backupset.type = 'D' 
   GROUP BY 
       msdb.dbo.backupset.database_name  
   ) AS A 
    
   LEFT JOIN  

   ( 
   SELECT   
   CONVERT(CHAR(100), SERVERPROPERTY('Servername')) AS Server, 
   msdb.dbo.backupset.database_name,  
   msdb.dbo.backupset.backup_start_date,  
   msdb.dbo.backupset.backup_finish_date, 
   msdb.dbo.backupset.expiration_date, 
   msdb.dbo.backupset.backup_size,  
   msdb.dbo.backupmediafamily.logical_device_name,  
   msdb.dbo.backupmediafamily.physical_device_name,   
   msdb.dbo.backupset.name AS backupset_name, 
   msdb.dbo.backupset.description 
FROM   msdb.dbo.backupmediafamily  
   INNER JOIN msdb.dbo.backupset ON msdb.dbo.backupmediafamily.media_set_id = msdb.dbo.backupset.media_set_id  
WHERE  msdb..backupset.type = 'D' 
   ) AS B 
   ON A.[server] = B.[server] AND A.[database_name] = B.[database_name] AND A.[last_db_backup_date] = B.[backup_finish_date] 
ORDER BY  
   A.database_name 
   
------------------------------------------------------------------------------------------- 
--Databases Missing a Data (aka Full) Back-Up Within Past 24 Hours 
------------------------------------------------------------------------------------------- 
--Databases with data backup over 24 hours old 
SELECT 
   CONVERT(CHAR(100), SERVERPROPERTY('Servername')) AS Server, 
   msdb.dbo.backupset.database_name, 
   MAX(msdb.dbo.backupset.backup_finish_date) AS last_db_backup_date, 
   DATEDIFF(hh, MAX(msdb.dbo.backupset.backup_finish_date), GETDATE()) AS [Backup Age (Hours)] 
FROM    msdb.dbo.backupset 
WHERE     msdb.dbo.backupset.type = 'D'  
GROUP BY msdb.dbo.backupset.database_name 
HAVING      (MAX(msdb.dbo.backupset.backup_finish_date) < DATEADD(hh, - 24, GETDATE()))  

UNION  

--Databases without any backup history 
SELECT      
   CONVERT(CHAR(100), SERVERPROPERTY('Servername')) AS Server,  
   master.dbo.sysdatabases.NAME AS database_name,  
   NULL AS [Last Data Backup Date],  
   9999 AS [Backup Age (Hours)]  
FROM 
   master.dbo.sysdatabases LEFT JOIN msdb.dbo.backupset 
       ON master.dbo.sysdatabases.name  = msdb.dbo.backupset.database_name 
WHERE msdb.dbo.backupset.database_name IS NULL AND master.dbo.sysdatabases.name <> 'tempdb' 
ORDER BY  
   msdb.dbo.backupset.database_name    


   --https://www.mssqltips.com/sqlservertip/1601/script-to-retrieve-sql-server-database-backup-history-and-no-backups/
   
   
( _¯:_¯:_¯:_¯[_¯ _¯]_¯:_¯:_¯:_¯ ) (-- jobs with a daily schedule) ( _¯:_¯:_¯:_¯[_¯ _¯]_¯:_¯:_¯:_¯ )

select
 sysjobs.name job_name
,sysjobs.enabled job_enabled
,sysschedules.name schedule_name
,sysschedules.freq_recurrence_factor
,case
 when freq_type = 4 then 'Daily'
end frequency
,
'every ' + cast (freq_interval as varchar(3)) + ' day(s)'  Days
,
case
 when freq_subday_type = 2 then ' every ' + cast(freq_subday_interval as varchar(7)) 
 + ' seconds' + ' starting at '
 + stuff(stuff(RIGHT(replicate('0', 6) +  cast(active_start_time as varchar(6)), 6), 3, 0, ':'), 6, 0, ':')
 when freq_subday_type = 4 then ' every ' + cast(freq_subday_interval as varchar(7)) 
 + ' minutes' + ' starting at '
 + stuff(stuff(RIGHT(replicate('0', 6) +  cast(active_start_time as varchar(6)), 6), 3, 0, ':'), 6, 0, ':')
 when freq_subday_type = 8 then ' every ' + cast(freq_subday_interval as varchar(7)) 
 + ' hours'   + ' starting at '
 + stuff(stuff(RIGHT(replicate('0', 6) +  cast(active_start_time as varchar(6)), 6), 3, 0, ':'), 6, 0, ':')
 else ' starting at ' 
 +stuff(stuff(RIGHT(replicate('0', 6) +  cast(active_start_time as varchar(6)), 6), 3, 0, ':'), 6, 0, ':')
end time
from msdb.dbo.sysjobs
inner join msdb.dbo.sysjobschedules on sysjobs.job_id = sysjobschedules.job_id
inner join msdb.dbo.sysschedules on sysjobschedules.schedule_id = sysschedules.schedule_id
where freq_type = 4

union

-- jobs with a weekly schedule
select
 sysjobs.name job_name
,sysjobs.enabled job_enabled
,sysschedules.name schedule_name
,sysschedules.freq_recurrence_factor
,case
 when freq_type = 8 then 'Weekly'
end frequency
,
replace
(
 CASE WHEN freq_interval&1 = 1 THEN 'Sunday, ' ELSE '' END
+CASE WHEN freq_interval&2 = 2 THEN 'Monday, ' ELSE '' END
+CASE WHEN freq_interval&4 = 4 THEN 'Tuesday, ' ELSE '' END
+CASE WHEN freq_interval&8 = 8 THEN 'Wednesday, ' ELSE '' END
+CASE WHEN freq_interval&16 = 16 THEN 'Thursday, ' ELSE '' END
+CASE WHEN freq_interval&32 = 32 THEN 'Friday, ' ELSE '' END
+CASE WHEN freq_interval&64 = 64 THEN 'Saturday, ' ELSE '' END
,', '
,''
) Days
,
case
 when freq_subday_type = 2 then ' every ' + cast(freq_subday_interval as varchar(7)) 
 + ' seconds' + ' starting at '
 + stuff(stuff(RIGHT(replicate('0', 6) +  cast(active_start_time as varchar(6)), 6), 3, 0, ':'), 6, 0, ':') 
 when freq_subday_type = 4 then ' every ' + cast(freq_subday_interval as varchar(7)) 
 + ' minutes' + ' starting at '
 + stuff(stuff(RIGHT(replicate('0', 6) +  cast(active_start_time as varchar(6)), 6), 3, 0, ':'), 6, 0, ':')
 when freq_subday_type = 8 then ' every ' + cast(freq_subday_interval as varchar(7)) 
 + ' hours'   + ' starting at '
 + stuff(stuff(RIGHT(replicate('0', 6) +  cast(active_start_time as varchar(6)), 6), 3, 0, ':'), 6, 0, ':')
 else ' starting at ' 
 + stuff(stuff(RIGHT(replicate('0', 6) +  cast(active_start_time as varchar(6)), 6), 3, 0, ':'), 6, 0, ':')
end time
from msdb.dbo.sysjobs
inner join msdb.dbo.sysjobschedules on sysjobs.job_id = sysjobschedules.job_id
inner join msdb.dbo.sysschedules on sysjobschedules.schedule_id = sysschedules.schedule_id
where freq_type = 8
order by job_enabled desc


( _¯:_¯:_¯:_¯[_¯ _¯]_¯:_¯:_¯:_¯ ) (-FRA Uso de Flash Recovery Area Usage ) ( _¯:_¯:_¯:_¯[_¯ _¯]_¯:_¯:_¯:_¯ )


-- Use (MB) of FRA
set lines 100
col name format a60

select 
   name,
  floor(space_limit / 1024 / 1024) "Size MB",
  ceil(space_used / 1024 / 1024) "Used MB"
from v$recovery_file_dest;

-- FRA Occupants
SELECT * FROM V$FLASH_RECOVERY_AREA_USAGE;

-- Location and size of the FRA
show parameter db_recovery_file_dest

-- Size, usage, Reclaimable space used 
SELECT 
  ROUND((A.SPACE_LIMIT / 1024 / 1024 / 1024), 2) AS FLASH_IN_GB, 
  ROUND((A.SPACE_USED / 1024 / 1024 / 1024), 2) AS FLASH_USED_IN_GB, 
  ROUND((A.SPACE_RECLAIMABLE / 1024 / 1024 / 1024), 2) AS FLASH_RECLAIMABLE_GB,
  SUM(B.PERCENT_SPACE_USED)  AS PERCENT_OF_SPACE_USED
FROM 
  V$RECOVERY_FILE_DEST A,
  V$FLASH_RECOVERY_AREA_USAGE B
GROUP BY
  SPACE_LIMIT, 
  SPACE_USED , 
  SPACE_RECLAIMABLE ;

-- After that you can resize the FRA with:
-- ALTER SYSTEM SET db_recovery_file_dest_size=xxG;

-- Or change the FRA to a new location (new archives will be created to this new location):
-- ALTER SYSTEM SET DB_RECOVERY_FILE_DEST='/u....';



( _¯:_¯:_¯:_¯[_¯ _¯]_¯:_¯:_¯:_¯ ) (-- ) ( _¯:_¯:_¯:_¯[_¯ _¯]_¯:_¯:_¯:_¯ )


 CREATE TEMPORARY TABLESPACE temp2     TEMPFILE 'temp2.dbf'        SIZE 10G autoextend on;
 
 alter database DEFAULT TEMPORARY TABLESPACE temp2;
 DROP TABLESPACE temp INCLUDING CONTENTS AND DATAFILES;
 DROP TABLESPACE temp_ro INCLUDING CONTENTS AND DATAFILES;
  CREATE TEMPORARY TABLESPACE tempro     TEMPFILE 'temp_ro1.dbf'        SIZE 10G autoextend on;

  Query Sesiones
  SELECT sess.sid,
          sess.username,
          sqla.optimizer_mode,
          sqla.hash_value,
          sqla.address,
          sqla.cpu_time,
          sqla.elapsed_time,
          sqla.sql_text
     FROM v$sqlarea sqla, v$session sess
    WHERE sess.sql_hash_value = sqla.hash_value
      AND sess.sql_address = sqla.address order by 6 desc; 
      
  
( _¯:_¯:_¯:_¯[_¯ _¯]_¯:_¯:_¯:_¯ ) ( WORKING THREAD) ( _¯:_¯:_¯:_¯[_¯ _¯]_¯:_¯:_¯:_¯ )

exec msdb.dbo.sp_help_job

SELECT  s.subsystem_id, 
        s.subsystem, 
        m.[text] AS [description], 
        s.max_worker_threads
FROM msdb.dbo.syssubsystems s
INNER JOIN msdb.sys.messages m 
    ON  s.description_id = m.message_id 
        AND m.language_id = 1033 --English

		SELECT  s.session_id, r.command, r.status,  
   r.wait_type, r.scheduler_id, w.worker_address,  
   w.is_preemptive, w.state, t.task_state,  
   t.session_id, t.exec_context_id, t.request_id  
FROM sys.dm_exec_sessions AS s  
INNER JOIN sys.dm_exec_requests AS r  
   ON s.session_id = r.session_id  
INNER JOIN sys.dm_os_tasks AS t  
   ON r.task_address = t.task_address  
INNER JOIN sys.dm_os_workers AS w  
   ON t.worker_address = w.worker_address  
WHERE s.is_user_process = 0; 


UPDATE msdb.dbo.syssubsystems
SET max_worker_threads = 800
WHERE subsystem_id in (4,6,7,8,9,10,11)

UPDATE msdb.dbo.syssubsystems
SET max_worker_threads = 160
WHERE subsystem_id in (1)

UPDATE msdb.dbo.syssubsystems
SET max_worker_threads = 80
WHERE subsystem_id in (2,3)

--How to Calculate Max Worker Thread Usage
select scheduler_id,current_tasks_count,
current_workers_count,active_workers_count,work_queue_count    
from sys.dm_os_schedulers    
where status = 'Visible Online'

--Breakdown of which System Task is using MWT Threads
select is_preemptive,state,last_wait_type,count(*) as NumWorkers from sys.dm_os_workers    
Group by state,last_wait_type,is_preemptive    
order by count(*) desc;

--Use the following Query to find out which System Tasks have caused additional worker threads to be spawned:
SELECT  s.session_id,  r.command,  r.status,  r.wait_type,  r.scheduler_id,  w.worker_address,  
w.is_preemptive,  w.state,  t.task_state,  t.session_id,  t.exec_context_id,  t.request_id  
FROM sys.dm_exec_sessions AS s  
INNER JOIN sys.dm_exec_requests AS r ON s.session_id = r.session_id  
INNER JOIN sys.dm_os_tasks AS t      ON r.task_address = t.task_address  
INNER JOIN sys.dm_os_workers AS w    ON t.worker_address = w.worker_address  
WHERE s.is_user_process = 0;


( _¯:_¯:_¯:_¯[_¯ _¯]_¯:_¯:_¯:_¯ ) (  DURACION QUERY SQL SERVER      ) ( _¯:_¯:_¯:_¯[_¯ _¯]_¯:_¯:_¯:_¯ )
      
USE MASTER 
 
SELECT SPID,ER.percent_complete, 
/* This piece of code has been taken from article. Nice code to get time criteria's 
http://beyondrelational.com/blogs/geniiius/archive/2011/11/01/backup-restore-checkdb-shrinkfile-progress.aspx 
*/ 
    CAST(((DATEDIFF(s,start_time,GetDate()))/3600) as varchar) + ' hour(s), ' 
        + CAST((DATEDIFF(s,start_time,GetDate())%3600)/60 as varchar) + 'min, ' 
        + CAST((DATEDIFF(s,start_time,GetDate())%60) as varchar) + ' sec' as running_time, 
    CAST((estimated_completion_time/3600000) as varchar) + ' hour(s), ' 
        + CAST((estimated_completion_time %3600000)/60000 as varchar) + 'min, ' 
        + CAST((estimated_completion_time %60000)/1000 as varchar) + ' sec' as est_time_to_go, 
    DATEADD(second,estimated_completion_time/1000, getdate()) as est_completion_time, 
/* End of Article Code */     
ER.command,ER.blocking_session_id, SP.DBID,LASTWAITTYPE,  
DB_NAME(SP.DBID) AS DBNAME, 
SUBSTRING(est.text, (ER.statement_start_offset/2)+1,  
        ((CASE ER.statement_end_offset 
         WHEN -1 THEN DATALENGTH(est.text) 
         ELSE ER.statement_end_offset 
         END - ER.statement_start_offset)/2) + 1) AS QueryText, 
TEXT,CPU,HOSTNAME,LOGIN_TIME,LOGINAME, 
SP.status,PROGRAM_NAME,NT_DOMAIN, NT_USERNAME 
FROM SYSPROCESSES SP  
INNER JOIN sys.dm_exec_requests ER 
ON sp.spid = ER.session_id 
CROSS APPLY SYS.DM_EXEC_SQL_TEXT(er.sql_handle) EST 
ORDER BY CPU DESC  

--HOW TO TELL WHEN ROLLBACK FINISHES
--You will see the number of undo records and undo blocks
--(USED_UREC and USED_UBLK) decrease while the transaction is rolling
--back.  When they reach 0, the transaction disappears from v$transaction.

select a.sid, a.serial#, a.username, b.used_urec, b.used_ublk
from   v$session a,       v$transaction b
where  a.saddr = b.ses_addr;



-will list all the dirty pages from the memory. Dirty pages are the pages which contain the data which are yet not committed to the hard drive.

SELECT
database_name = d.name,
OBJECT_NAME =
CASE au.TYPE
WHEN 1 THEN o1.name
WHEN 2 THEN o2.name
WHEN 3 THEN o1.name
END,
OBJECT_ID =
CASE au.TYPE
WHEN 1 THEN p1.OBJECT_ID
WHEN 2 THEN p2.OBJECT_ID
WHEN 3 THEN p1.OBJECT_ID
END,
index_id =
CASE au.TYPE
WHEN 1 THEN p1.index_id
WHEN 2 THEN p2.index_id
WHEN 3 THEN p1.index_id
END,
bd.FILE_ID,
bd.page_id,
bd.page_type,
bd.page_level
FROM sys.dm_os_buffer_descriptors bd
INNER JOIN sys.databases d
ON bd.database_id = d.database_id
INNER JOIN sys.allocation_units au
ON bd.allocation_unit_id = au.allocation_unit_id
LEFT JOIN sys.partitions p1
ON au.container_id = p1.hobt_id
LEFT JOIN sys.partitions p2
ON au.container_id = p2.partition_id
LEFT JOIN sys.objects o1
ON p1.OBJECT_ID = o1.OBJECT_ID
LEFT JOIN sys.objects o2
ON p2.OBJECT_ID = o2.OBJECT_ID
WHERE is_modified = 1

--Todos los waits stats
SELECT *
FROM sys.dm_os_wait_stats
ORDER BY wait_time_ms DESC

-- Get the rows of dirtied pages
SELECT
database_name = d.name,
OBJECT_NAME =
CASE au.TYPE
WHEN 1 THEN o1.name
WHEN 2 THEN o2.name
WHEN 3 THEN o1.name
END,
OBJECT_ID =
CASE au.TYPE
WHEN 1 THEN p1.OBJECT_ID
WHEN 2 THEN p2.OBJECT_ID
WHEN 3 THEN p1.OBJECT_ID
END,
index_id =
CASE au.TYPE
WHEN 1 THEN p1.index_id
WHEN 2 THEN p2.index_id
WHEN 3 THEN p1.index_id
END,
bd.FILE_ID,
bd.page_id,
bd.page_type,
bd.page_level
FROM sys.dm_os_buffer_descriptors bd
INNER JOIN sys.databases d
ON bd.database_id = d.database_id
INNER JOIN sys.allocation_units au
ON bd.allocation_unit_id = au.allocation_unit_id
LEFT JOIN sys.partitions p1
ON au.container_id = p1.hobt_id
LEFT JOIN sys.partitions p2
ON au.container_id = p2.partition_id
LEFT JOIN sys.objects o1
ON p1.OBJECT_ID = o1.OBJECT_ID
LEFT JOIN sys.objects o2
ON p2.OBJECT_ID = o2.OBJECT_ID
WHERE is_modified = 1
AND d.name = 'DirtyPagesDB'
AND
(
o1.name = 't1'
OR o2.name = 't1'
);

--Report of queries that are waiting for memory allocation. The reason was that we were doubtful regarding whether the memory was sufficient for the application. The following query can be useful in similar case. Queries that do not have to wait on a memory grant will not appear in the resultset of following query.

SELECT TEXT, query_plan, requested_memory_kb,
granted_memory_kb,used_memory_kb, wait_order
FROM sys.dm_exec_query_memory_grants MG
CROSS APPLY sys.dm_exec_sql_text(sql_handle)
CROSS APPLY sys.dm_exec_query_plan(MG.plan_handle)


--Recovery model

https://www.sqlskills.com/blogs/paul/sqlskills-sql101-switching-recovery-models/


--2000
select name, databasepropertyex(name, 'Recovery') as RecoveryModel from master.dbo.sysdatabases order by name

--Mayor a 2k
SELECT name AS [Database Name],recovery_model_desc AS [Recovery Model] 
FROM sys.databases

ALTER DATABASE Staging SET RECOVERY SIMPLE WITH NO_WAIT


--SUSPECT
EXEC sp_resetstatus reportes;
ALTER DATABASE reportes SET EMERGENCY
DBCC checkdb(reportes)
ALTER DATABASE reportes SET SINGLE_USER WITH ROLLBACK IMMEDIATE
DBCC CheckDB (reportes, REPAIR_ALLOW_DATA_LOSS)
ALTER DATABASE reportes SET MULTI_USER


--How to find out why an ORA-4021 occurs?
--If possible and reproducible to execute a statement that generates a ORA-4021 error, you can find out more information as to the reason for the blocking situation by running the query below in the 5 minute wait period before the error appears (i.e. when it is waiting):

--NOTE: You need to run the script called "catblock.sql" first. This script can be found in:  $ORACLE_HOME/rdbms/admin/catblock.sql

LOCK TABLE?

select /*+ ordered */ w1.sid  waiting_session,
         h1.sid  holding_session,
         w.kgllktype lock_or_pin,
         w.kgllkhdl address,
         decode(h.kgllkmod,  0, 'None', 1, 'Null', 2, 'Share', 3, 'Exclusive',
            'Unknown') mode_held,
         decode(w.kgllkreq,  0, 'None', 1, 'Null', 2, 'Share', 3, 'Exclusive',
          'Unknown') mode_requested
   from dba_kgllock w, dba_kgllock h, v$session w1, v$session h1
  where
   (((h.kgllkmod != 0) and (h.kgllkmod != 1)
      and ((h.kgllkreq = 0) or (h.kgllkreq = 1)))
    and
      (((w.kgllkmod = 0) or (w.kgllkmod= 1))
      and ((w.kgllkreq != 0) and (w.kgllkreq != 1))))
   and  w.kgllktype      =  h.kgllktype
   and  w.kgllkhdl =  h.kgllkhdl
   and  w.kgllkuse     =   w1.saddr
   and  h.kgllkuse     =   h1.saddr
 /
 

sp_whoisactive


EXEC dbo.sp_BlitzFirst @ExpertMode = 1;
EXEC dbo.sp_BlitzFirst @SinceStartup = 1;
exec sp_BlitzIndex @GetAllDatabases = 1, @BringThePain = 1;
exec sp_BlitzIndex  @Mode=4;
exec sp_BlitzCache;
exec sp_BlitzCache @SortOrder = 'reads', @Top = 20;
exec sp_BlitzCache @ExpertMode = 1;
/* reads, CPU, duration, executions, memory grant, recent compilations */

statisticsparser.com



--REPLICATION
https://docs.microsoft.com/en-us/sql/relational-databases/replication/tutorial-preparing-the-server-for-replication?view=sql-server-ver15
https://docs.microsoft.com/en-us/sql/relational-databases/replication/tutorial-replicating-data-between-continuously-connected-servers?view=sql-server-ver15

https://docs.microsoft.com/en-us/sql/relational-databases/replication/troubleshoot-tran-repl-errors?view=sql-server-ver15


OVERDUE JOBS
Finding failed jobs
A failed job is an Oracle task that has not executed properly 15 or fewer times (if it fails to execute properly 16 times in a row, it is flagged as a broken job). 

Finding overdue jobs
An overdue job is a job that is more then two minutes overdue. An overdue job may be a broken job or a failed job, or it may simply be blocked from running at its appointed time. 



IO  en SQL SERVER
SELECT
  databases.name AS DatabaseName,
  master_files.name AS DatabaseFileName,
  master_files.type_desc AS FileType,
  master_files.physical_name,
  dm_io_virtual_file_stats.num_of_reads,
  dm_io_virtual_file_stats.num_of_bytes_read,
  dm_io_virtual_file_stats.num_of_writes,
  dm_io_virtual_file_stats.num_of_bytes_written,
  dm_io_virtual_file_stats.size_on_disk_bytes
FROM sys.master_files
INNER JOIN sys.dm_io_virtual_file_stats(NULL, NULL)
ON master_files.database_id = dm_io_virtual_file_stats.database_id
INNER JOIN sys.databases
ON databases.database_id = master_files.database_id
AND master_files.file_id = dm_io_virtual_file_stats.file_id;



--SP_WHO2 ORDENADO

declare @tempTable table (SPID INT,Status VARCHAR(255),
Login VARCHAR(255),HostName VARCHAR(255),
BlkBy VARCHAR(255),DBName VARCHAR(255),
Command VARCHAR(255),CPUTime INT,
DiskIO INT,LastBatch VARCHAR(255),
ProgramName VARCHAR(255),SPID2 INT,
REQUESTID INT);

INSERT INTO @tempTable
EXEC sp_who2

select *
from @tempTable
WHERE       DBName <> 'master'
order by status desc
----------

  Si manda error de conversion de int o varchar

declare @tempTable table (SPID VARCHAR(255), Status VARCHAR(255),Login VARCHAR(255),HostName VARCHAR(255),BlkBy VARCHAR(255),DBName VARCHAR(255),Command VARCHAR(255),CPUTime VARCHAR(255),DiskIO VARCHAR(255),LastBatch VARCHAR(255),ProgramName VARCHAR(255),SPID2 VARCHAR(255),REQUESTID VARCHAR(255));

INSERT INTO @tempTable
EXEC sp_who2

select *
from @tempTable
WHERE       DBName <> 'master'
order by status desc

---------------




CREATE TABLE #sp_who2 (SPID INT,Status VARCHAR(255),
      Login  VARCHAR(255),HostName  VARCHAR(255),
      BlkBy  VARCHAR(255),DBName  VARCHAR(255),
      Command VARCHAR(255),CPUTime INT,
      DiskIO INT,LastBatch VARCHAR(255),
      ProgramName VARCHAR(255),SPID2 INT,
      REQUESTID INT)
INSERT INTO #sp_who2 EXEC sp_who2
SELECT      *
FROM        #sp_who2
-- Add any filtering of the results here :
WHERE       DBName <> 'master'
-- Add any sorting of the results here :
ORDER BY    DBName ASC

DROP TABLE #sp_who2


---------------------

CANTIDAD DE VLF


DECLARE @query varchar(1000),
@dbname varchar(1000),
@count int

SET NOCOUNT ON

DECLARE csr CURSOR FAST_FORWARD READ_ONLY
FOR
SELECT name
FROM master.dbo.sysdatabases

CREATE TABLE ##loginfo
(
dbname varchar(100),
num_of_rows int)

OPEN csr

FETCH NEXT FROM csr INTO @dbname

WHILE (@@fetch_status <> -1)
BEGIN

CREATE TABLE #log_info
(
fileid tinyint,
file_size bigint,
start_offset bigint,
FSeqNo int,
[status] tinyint,
parity tinyint,
create_lsn numeric(25,0)
)

SET @query = 'DBCC loginfo (' + '''' + @dbname + ''') '

INSERT INTO #log_info
EXEC (@query)

SET @count = @@rowcount

DROP TABLE #log_info

INSERT ##loginfo
VALUES(@dbname, @count)

FETCH NEXT FROM csr INTO @dbname

END

CLOSE csr
DEALLOCATE csr

SELECT dbname,
num_of_rows
FROM ##loginfo
WHERE num_of_rows >= 50 --My rule of thumb is 50 VLFs. Your mileage may vary.
ORDER BY dbname

DROP TABLE ##loginfo

http://adventuresinsql.com/2009/12/a-busyaccidental-dbas-guide-to-managing-vlfs/

----------28 dic 2020 JCC
dbname	num_of_rows
distribution	1968
JCC_Panama	4046
tempdb	306
wfmdb	52

---------------
HISTORIAL de BACKUP DE LOG SQL
SELECT 
	bs.database_name AS DatabaseName
	,CASE bs.type
		WHEN 'D' THEN 'Full'
		WHEN 'I' THEN 'Differential'
		WHEN 'L' THEN 'Transaction Log'
	END AS BackupType
	,CAST(DATEDIFF
		(SECOND,bs.backup_start_date,bs.backup_finish_date) 
		AS VARCHAR(4)) + ' ' + 'Seconds' AS TotalTimeTaken
	,bs.backup_start_date AS BackupStartDate
	,CAST(bs.first_lsn AS VARCHAR(50)) AS FirstLSN
	,CAST(bs.last_lsn AS VARCHAR(50)) AS LastLSN
	,bmf.physical_device_name AS PhysicalDeviceName
	,CAST(CAST(bs.backup_size / 1000000 AS INT) AS VARCHAR(14)) 
		+ ' ' + 'MB' AS BackupSize
	,bs.server_name AS ServerName
	,bs.recovery_model AS RecoveryModel
FROM msdb.dbo.backupset AS bs
INNER JOIN msdb.dbo.backupmediafamily AS bmf
	ON bs.media_set_id = bmf.media_set_id
WHERE bs.database_name = 'JCC_Panama'
ORDER BY 
	backup_start_date DESC
	,backup_finish_date
	
-----------------VERIFICAR EL ESTATUS DEL LOG DE TRANSACCIONES CUANDO ESTE LLENO
Select name as base_datos,
log_reuse_wait, log_reuse_wait_desc,
case
log_reuse_wait
when 0 then 'Hay actualmente uno o
más archivos de registro virtual reutilizables.'

when 1 then 'No se ha producido
ningún punto de comprobación desde último truncamiento
o el encabezado del registro no se ha movido más allá de un archivo de registro
virtual (todos los modelos de recuperación). Éste es un motivo habitual para
retrasar el truncamiento.'

when 2 then 'Se necesita una copia
de seguridad del registro para hacer avanzar el encabezado del registro
(modelos de recuperación completos o registrados de forma masiva sólo). Cuando
se completa la copia de seguridad del registro, se avanza el encabezado del
registro y algún espacio del registro podría convertirse en reutilizable.'

when 3 then 'Existe una recuperación
o copia de seguridad de datos en curso (todos los modelos de recuperación).
La copia de seguridad
de datos funciona como una transacción activa y, cuando se ejecuta, la copia de
seguridad impide el truncamiento'

when 4 then 'Podría existir una
transacción de larga duración en el inicio de la copia de seguridad del
registro. En este caso, para liberar espacio se podría requerir otra copia de
seguridad del registro.
Se difiere una
transacción. Una transacción diferida es efectivamente una transacción activa
cuya reversión se bloquea debido a algún recurso no disponible.'

when 5 then 'Se realiza una pausa en
la creación de reflejo de la base de datos o, en el modo de alto rendimiento,
la base de datos reflejada está notablemente detrás de la base de datos de la
entidad de seguridad (sólo para el modelo de recuperación completa).'

when 6 then 'Durante las
replicaciones transaccionales, las transacciones relevante para las
publicaciones no se han entregado aún a la base de datos de distribución (sólo
para el modelo de recuperación completa).'

when 7 then 'Se está creando una
instantánea de base de datos (todos los modelos de recuperación). Éste es un
motivo habitual, por lo general breve, para retrasar el truncamiento del
registro.'

when 8 then 'Se está produciendo un
recorrido del registro (todos los modelos de recuperación). Éste es un motivo
habitual, por lo general breve, para retrasar el truncamiento del registro.'

when 9 then 'No se utiliza este
valor actualmente.'
end as columna,
recovery_model_desc as
modo_recuperacion_log, page_verify_option_desc as page_verify_bbdd,
user_access_desc as user_access,
state_desc as estado_bbdd from sys.databases

 ------------------------------


 HAcer Shrink de log files automatico
 
 select 'use ' + db_name(dbid) + char(13) + 'dbcc shrinkfile (' + quotename(sf.name,'''') + ', 0,truncateonly)' from sysaltfiles sf
inner join sys.databases sd on sf.dbid = sd.database_id
where state_desc = 'online'
and groupid = 0
and dbid=5


-----------

http://sql-articles.com/scripts/script-to-retrieve-security-information-sql-server-2000/

Script to Retrieve Security Information SQL Server 2000
..Usuarios y Login de SQL Server 2000

DECLARE @DBuser_sql VARCHAR(4000)
IF EXISTS (SELECT 1 FROM tempdb..sysobjects WHERE name = '##DBuser_table')
DROP TABLE ##DBuser_table
CREATE TABLE ##DBuser_table (DBName VARCHAR(200), UserName VARCHAR(250), LoginType VARCHAR(500), AssociatedRole VARCHAR(200))
SET @DBuser_sql='select ''?'' AS DBName, a.name, CASE WHEN a.isntgroup =1 AND a.isntuser=0 THEN ''Windows Group''
    WHEN a.isntgroup =0 AND a.isntuser=1 THEN ''Windows Login''
    WHEN a.issqlrole=1 THEN ''Database Role''
    ELSE ''SQL Login'' END AS ''Login Type'', USER_NAME(b.groupuid) AS ''AssociatedRole''
from ?.dbo.sysusers a LEFT OUTER JOIN ?.dbo.sysmembers b ON a.uid=b.memberuid 
where a.altuid<>1 
and a.uid not in (1,2) 
AND ''?'' NOT IN (''master'',''msdb'',''model'',''tempdb'')  AND(
   upper(a.name) like ''%AGG06590''
OR upper(a.name) like ''%EBB05808''
OR upper(a.name) like ''%DCC07564''
OR upper(a.name) like ''%dsalazar''
)ORDER BY Name'
INSERT INTO ##DBuser_table
EXEC sp_MSforeachdb @command1=@dbuser_sql
SELECT * FROM ##DBuser_table ORDER BY DBName


--------------

Cannot alter the user ‘dbo’. (Microsoft SQL Server, Error: 15150)


--Correr el query para saber cual no tiene owner
SELECT name, suser_sname(sid), convert(nvarchar(11), crdate),dbid, cmptlevel 
FROM master.dbo.sysdatabases     
WHERE suser_sname(sid) =  'CWP\emm91559'

--ejecutar esto para generar el script
SELECT 'USE ' + name + '; EXEC sp_changedbowner ''sa'';' 
FROM master.dbo.sysdatabases WHERE suser_sname(sid) =  'CWP\emm91559'

--cambiarle el owner
USE GxPortal; EXEC sp_changedbowner 'sa';

USE SGOStaging; EXEC sp_changedbowner 'sa';
USE FMOnline; EXEC sp_changedbowner 'sa';
USE coverage; EXEC sp_changedbowner 'sa';
USE AccreditBalanceDTH; EXEC sp_changedbowner 'sa';
USE PoliticalDivision; EXEC sp_changedbowner 'sa';
USE Llamadas; EXEC sp_changedbowner 'sa';
USE Canales; EXEC sp_changedbowner 'sa';
USE micro_distribution; EXEC sp_changedbowner 'sa';

---SQL SERVER – FIX: Msg 15170, Level 16, This login is the Owner of 1 Job(s). You Must Delete or Reassign these Jobs Before the Login can be Dropped

 SELECT name,* 
FROM msdb..sysjobs
WHERE owner_sid = SUSER_SID('EMM91559')




-------------
https://anargodjaev.wordpress.com/2014/01/26/shutdown-fails-with-ora-24324-ora-24323-ora-01090/
SHUTDOWN FAILS WITH ORA-24324, ORA-24323, ORA-01090
January 26, 2014 · by anargodjaev · in Oracle Introduction · Leave a comment
      1 Vote

ORA-24324: service handle not initialized 
ORA-24323: value not allowed 
ORA-01090: shutdown in progress - connection is not permitted
Cause: for this is that the Background processes are hanging/not stared correctly during the previous startup of this database. Hence the smeaphores and shared memory segements are not getting detached properly now during shutdown.
Solution
1. Verify that there are no background processes owned by "oracle" , if there are kill them 
$ ps -ef | grep ora_ | grep $ORACLE_SID
2. remove shared memory and semaphores: 
A) checking for shared memory and semaphores 
$ ipcs -mt (if there is anything owned by oracle remove it) 
$ ipcrm -m [ID] (to remove it)
B) checking and removing semaphores 
$ ipcs -sbt (if there is anything owned by oracle remove it) 
$ ipcrm -s [ID] (to remove it)
C) remove sga and lk file 


RAC SEQUENCE

https://orahow.com/oracle-rac-clusterware-startup-sequence/

RAC LOGS

Oracle RAC Clusterware Startup Sequence in detail
October 14, 2019 admin
This post describe about Oracle RAC Cluster startup sequence in detail and the step by step explanation which oracle follow to bring up the clusterware.

What is Oracle Clusterware – RAC ?
Oracle Real Application Clusters known as Oracle RAC uses Oracle Clusterware as the infrastructure that binds multiple nodes that then operate as a single server. In an Oracle RAC environment, Oracle Clusterware monitors all Oracle components such as instances and listeners. If a failure occurs, then Oracle Clusterware automatically attempts to restart the failed component and also redirects operations to a surviving component.

Must Read: How to Drop and Recreate Temp Tablespace in Oracle

Oracle Cluster Registry (OCR) :
OCR is a file which maintains cluster configuration information about any cluster database within the cluster. The OCR contains information such as information about the cluster node list and instance-to-node mapping information. OCR also contains information about Clusterware resource profiles for resources that you have customized. The OCR resides on shared storage that is accessible by all the nodes in your cluster. Oracle Clusterware can multiplex, or maintain multiple copies of, the OCR and Oracle recommends that you use this feature to ensure high availability.

Oracle Local Registry – OLR
Each node in a cluster also has a local copy of the OCR, called an Oracle Local Registry – OLR, which is created when Oracle Clusterware is installed. Multiple processes on each node have simultaneous read and write access to the OLR particular to the node on which they reside, whether Oracle Clusterware is fully functional. By default, OLR is located at Grid_home/cdata/$HOSTNAME.olr

Voting Disk
The voting disk manage node membership information. It is a shared disks that will be accessed by all the member of the nodes in the cluster. It is used as central reference for all the nodes and keeps the heartbeat information between the nodes. If any of the node is unable to ping the voting disk,cluster immediately recognize the communication failure and evicts the node from the cluster.

Brief explanation of the startup sequence.


Image Credit: Oracle
Once the Operating system starts and finish the boot scrap process it reads /etc/init.d file via the initialisation daemon called init or init.d. The init tab file is the one it triggers oracle high availability service daemon.

When a node of an Oracle Clusterware cluster starts, OHASD is started by platform-specific means like init.d in Linux. OHASD is the root for bringing up Oracle Clusterware. OHASD has access to the OLR (Oracle Local Registry) stored on the local file system. OLR provides needed data to complete OHASD initialization.
OHASD brings up GPNPD and CSSD ( Cluster synchronization Service Daemon ). CSSD has access to the GPNP Profile stored on the local file system. This profile contains the following vital bootstrap data:
a. ASM Diskgroup Discovery String
b. ASM SPFILE location (Diskgroup name)
c. Name of the ASM Diskgroup containing the Voting Files
The Voting Files locations on ASM Disks are accessed by CSSD with well-known pointers in the ASM Disk headers and CSSD is able to complete initialization and start or join an existing cluster.
OHASD starts an ASM instance and ASM can now operate with CSSD initialized and operating. The ASM instance uses special code to locate the contents of the ASM SPFILE, assuming it is stored in a Diskgroup.
With an ASM instance operating and its Diskgroups mounted, access to Clusterware’s OCR is available to CRSD.
OHASD starts CRSD with access to the OCR in an ASM Diskgroup.
Clusterware completes initialization and brings up other services under its control.
As Per Oracle doc below are the high level steps for clusterware initialization.

INIT spawns init.ohasd (with respawn) which in turn starts the OHASD process (Oracle High Availability Services Daemon). This daemon spawns 4 processes.

Level 1: OHASD Spawns:
• cssdagent – Agent responsible for spawning CSSD.
• orarootagent – Agent responsible for managing all root owned ohasd resources.
• oraagent – Agent responsible for managing all oracle owned ohasd resources.
• cssdmonitor – Monitors CSSD and node health (along wth the cssdagent).
Level 2: OHASD rootagent spawns:
• CRSD – Primary daemon responsible for managing cluster resources.
• CTSSD – Cluster Time Synchronization Services Daemon
• Diskmon
• ACFS (ASM Cluster File System) Drivers
Level 3: OHASD oraagent spawns:
• MDNSD – Used for DNS lookup
• GIPCD – Used for inter-process and inter-node communication
• GPNPD – Grid Plug & Play Profile Daemon
• EVMD – Event Monitor Daemon
• ASM – Resource for monitoring ASM instances

Level 4: CRSD spawns:
• orarootagent – Agent responsible for managing all root owned crsd resources.
• oraagent – Agent responsible for managing all oracle owned crsd resources.
Level 4: CRSD rootagent spawns:
• Network resource – To monitor the public network
• SCAN VIP(s) – Single Client Access Name Virtual IPs
• Node VIPs – One per node
• ACFS Registery – For mounting ASM Cluster File System
• GNS VIP (optional) – VIP for GNS
Level 5: CRSD oraagent spawns:
• ASM Resource – ASM Instance(s) resource
• Diskgroup – Used for managing/monitoring ASM diskgroups.
• DB Resource – Used for monitoring and managing the DB and instances
• SCAN Listener – Listener for single client access name, listening on SCAN VIP
• Listener – Node listener listening on the Node VIP
• Services – Used for monitoring and managing services
• ONS – Oracle Notification Service
• eONS – Enhanced Oracle Notification Service
• GSD – For 9i backward compatibility
• GNS (optional) – Grid Naming Service – Performs name resolution

The following command will display the status of all cluster resources:

$ ./crsctl status resource -t
Clusterware Important Log File Locations
Clusterware daemon logs are all under : grid_home/log/node_name. Structure under grid_home/log/node_name: alert_node_name.log. You can look here first for most clusterware issues:


 ./admin:
 ./agent:
 ./agent/crsd:
 ./agent/crsd/oraagent_oracle:
 ./agent/crsd/ora_oc4j_type_oracle:
 ./agent/crsd/orarootagent_root:
 ./agent/ohasd:
 ./agent/ohasd/oraagent_oracle:
 ./agent/ohasd/oracssdagent_root:
 ./agent/ohasd/oracssdmonitor_root:
 ./agent/ohasd/orarootagent_root:
 ./client:
 ./crsd:
 ./cssd:
 ./ctssd:
 ./diskmon:
 ./evmd:
 ./gipcd:
 ./gnsd:
 ./gpnpd:
 ./mdnsd:
 ./ohasd:
 ./racg:
 ./racg/racgeut:
 ./racg/racgevtf:
 ./racg/racgmain:
 ./srvm:
 ASM logs live under $ORACLE_BASE/diag/asm/+asm//trace
 
  --utlima fecha de acceso a sqlserver
 
 SELECT
last_user_seek = MAX(last_user_seek),
last_user_scan = MAX(last_user_scan),
last_user_lookup = MAX(last_user_lookup),
last_user_update = MAX(last_user_update)
FROM
sys.dm_db_index_usage_stats
WHERE
[database_id] = DB_ID()

---Cantidad de sesiones SQL Server  -- conexiones
declare @tempTable table (SPID INT,Status VARCHAR(255),
Login VARCHAR(255),HostName VARCHAR(255),
BlkBy VARCHAR(255),DBName VARCHAR(255),
Command VARCHAR(255),CPUTime INT,
DiskIO INT,LastBatch VARCHAR(255),
ProgramName VARCHAR(255),SPID2 INT,
REQUESTID INT);

INSERT INTO @tempTable
EXEC sp_who2

select HostName, DBName, count(8) Cantidad
from @tempTable
WHERE       DBName <> 'master'
group by HostName ,DBName
order by 3 desc
 
 --Cursor SQL Server matar sesiones
 
 
USE MASTER
GO
DECLARE @spid SMALLINT
DECLARE @KILL VARCHAR(16)
DECLARE kill_cursor CURSOR FOR
select spid
from master..sysprocesses
where status = 'sleeping'
AND dbid=5
OPEN kill_cursor
FETCH NEXT FROM kill_cursor INTO @spid
WHILE @@FETCH_STATUS = 0
      BEGIN
      SET @KILL= 'kill '+cast(@spid as varchar(5))
      print (@KILL)
FETCH NEXT FROM kill_cursor INTO @spid
END


--para buscar sesiones inactivas con transacciones abiertas
SELECT s.*   
FROM sys.dm_exec_sessions AS s  
WHERE EXISTS   
    (  
    SELECT *   
    FROM sys.dm_tran_session_transactions AS t  
    WHERE t.session_id = s.session_id  
    )  
    AND NOT EXISTS   
    (  
    SELECT *   
    FROM sys.dm_exec_requests AS r  
    WHERE r.session_id = s.session_id  
    );  

--Cursor SQL Server matar sesiones  de un SERVIDOR X
 
DECLARE @user_spid INT
DECLARE CurSPID CURSOR FAST_FORWARD
FOR
SELECT SPID
FROM master.dbo.sysprocesses (NOLOCK)
WHERE spid>50 -- avoid system threads
AND status='sleeping' -- only sleeping threads
--AND DATEDIFF(HOUR,last_batch,GETDATE())>=12 -- thread sleeping for 24 hours
and hostname = 'CMP-JFR-MPPGP1'
AND spid<>@@spid -- ignore current spid
/*  PARA MATAR LAS DE UN SERVIDOR X
SELECT spid
FROM master.dbo.sysprocesses (NOLOCK)
WHERE spid>50 -- avoid system threads
AND status='sleeping' -- only sleeping threads
and hostname = 'CMP-JFR-MPPGP1'  --NOMBRE DEL SERVER
AND spid<>@@spid -- ignore current spid */
OPEN CurSPID
FETCH NEXT FROM CurSPID INTO @user_spid
WHILE (@@FETCH_STATUS=0)
BEGIN
PRINT 'Killing '+CONVERT(VARCHAR,@user_spid)
EXEC('KILL '+@user_spid)
FETCH NEXT FROM CurSPID INTO @user_spid
END
CLOSE CurSPID
DEALLOCATE CurSPID
GO




    ------VALIDA CUANTOS COMANDS  HAY POR REPLICAR
    

USE distribution 
GO 
SELECT Getdate() AS CaptureTime, 
Object_name(t.object_id) AS TableName, 
st.row_count, 
s.NAME 
FROM sys.dm_db_partition_stats st WITH (nolock) 
INNER JOIN sys.tables t WITH (nolock) 
ON st.object_id = t.object_id 
INNER JOIN sys.schemas s WITH (nolock) 
ON t.schema_id = s.schema_id 
WHERE index_id < 2 
AND Object_name(t.object_id) 
IN ('MSsubscriptions', 
'MSdistribution_history', 
'MSrepl_commands', 
'MSrepl_transactions' 
) 
ORDER BY st.row_count DESC 

 2021-01-30 15:14:22.423	MSrepl_commands	42128359	dbo
2021-01-30 15:14:22.423	MSrepl_transactions	564433	dbo
2021-01-30 15:14:22.423	MSdistribution_history	4859	dbo
2021-01-30 15:14:22.423	MSsubscriptions	2112	dbo

-----------  ULTIMA INSTANCIA sobre JCC_PANAMA EN JCC-----
--1. detener agente logreader
--2. exec sp_repldone @xactid=NULL,@xact_seqno=NULL,@numtrans=0, @time=0,@reset=1
--3. sp_replflush
--4. start log reader

 --REPLICA TRX NO ENVIADAS
USE distribution 
GO
SELECT DISTINCT
    a.article, md.agent_name, ds.UndelivCmdsInDistDB, ds.DelivCmdsInDistDB
FROM dbo.MSdistribution_status ds
JOIN dbo.MSarticles a ON
     a.article_id = ds.article_id
JOIN dbo.MSreplication_monitordata md ON
     md.agent_id = ds.agent_id
WHERE UndelivCmdsInDistDB > 0
ORDER BY UndelivCmdsInDistDB DESC


-- kill sleeping sessions from sp_who2
DECLARE @user_spid INT
DECLARE CurSPID CURSOR FAST_FORWARD
FOR
SELECT SPID
FROM master.dbo.sysprocesses (NOLOCK)
WHERE spid>50 -- avoid system threads
AND status='sleeping' -- only sleeping threads
AND DATEDIFF(HOUR,last_batch,GETDATE())>=24 -- thread sleeping for 24 hours
AND spid<>@@spid -- ignore current spid
OPEN CurSPID
FETCH NEXT FROM CurSPID INTO @user_spid
WHILE (@@FETCH_STATUS=0)
BEGIN
PRINT 'Killing '+CONVERT(VARCHAR,@user_spid)
EXEC('KILL '+@user_spid)
FETCH NEXT FROM CurSPID INTO @user_spid
END
CLOSE CurSPID
DEALLOCATE CurSPID
GO

--Sleeping, dormant, running, pending, suspended.
https://blog.sqlauthority.com/2020/09/10/sleeping-vs-suspended-process-sql-in-sixty-seconds-122/

thread
CPU
DISK

Pending....no  thread & no CPU     ..waiting for both of them to be available
RUNNABLE.. it has thread but no CPU    .. waiting for CPU to be available.
RUNNING.. process has thread and CPU   ..es lo que todos queremos.
SUSPENDED... Waiting for  event (IO or lock ) not available
SLEEPING,  is not doing anything and waiting for further commands.
DORMANT.. SQL Server is reseting that process
SPINLOCK.. Busy waiting in CPU for its own turn. 



 Argument list too long
 Arg list too long

 find . -name "*.xml" -print0 | xargs -0 rm
 find . -name "*.aud" -print0 | xargs -0 rm
 
ENABLE SQL TRACING
--Database Level:
DBMS_MONITOR.DATABASE_TRACE_ENABLE;

--SESSION LEVEL
EXECUTE DBMS_MONITOR.SESSION_TRACE_ENABLE
DBMS_SESSION.SESSION_TRACE_ENABLE;
DBMS_SESSION.SET_SQL_TRACE;
ALTER SESSION SET SQL_TRACE = TRUE; 



###### LUN   BASIC
https://youtu.be/6s2zCp5IhGg



IO PROBLEMS
https://www.computerperformance.co.uk/healthcheck/disk-health/

for "Facturas_FormulasOtrosParametros" failed
Error 0xc02020e8: Data Flow Task 1: Opening a rowset for "Generales_Clasif_Ejec_GrupoProd" failed. Check that the object exists in the database.
 (SQL Server Import and Export Wizard)
<                           <

###RAC 
##RAC ORDER - Clusterware order
Oracle Cluster Registry (OCR) :
OCR is a file which maintains cluster configuration information about any cluster database within the cluster. 
The OCR contains information such as information about the cluster node list and instance-to-node mapping information. 
OCR also contains information about Clusterware resource profiles for resources that you have customized. 
The OCR resides on shared storage that is accessible by all the nodes in your cluster. 
Oracle Clusterware can multiplex, or maintain multiple copies of, the OCR and Oracle recommends that you use this feature to ensure high availability.

Oracle Local Registry – OLR
Each node in a cluster also has a local copy of the OCR, called an Oracle Local Registry – OLR, which is created when Oracle Clusterware is installed. 
Multiple processes on each node have simultaneous read and write access to the OLR particular to the node on which they reside, 
whether Oracle Clusterware is fully functional. By default, OLR is located at Grid_home/cdata/$HOSTNAME.olr

Voting Disk
The voting disk manage node membership information. It is a shared disks that will be accessed by all the member of the nodes in the cluster. 
It is used as central reference for all the nodes and keeps the heartbeat information between the nodes.
If any of the node is unable to ping the voting disk,cluster immediately recognize the communication failure and evicts the node from the cluster.


Once the Operating system starts and finish the boot scrap process it reads /etc/init.d file via the initialisation daemon called init or init.d. 
The init tab file is the one it triggers oracle high availability service daemon.

When a node of an Oracle Clusterware cluster starts, OHASD is started by platform-specific means like init.d in Linux. 
OHASD is the root for bringing up Oracle Clusterware. OHASD has access to the OLR (Oracle Local Registry) stored on the local file system. 
OLR provides needed data to complete OHASD initialization.
OHASD brings up GPNPD and CSSD ( Cluster synchronization Service Daemon ). CSSD has access to the GPNP Profile stored on the local file system. 
This profile contains the following vital bootstrap data:
a. ASM Diskgroup Discovery String
b. ASM SPFILE location (Diskgroup name)
c. Name of the ASM Diskgroup containing the Voting Files
The Voting Files locations on ASM Disks are accessed by CSSD with well-known pointers in the ASM Disk headers and CSSD is able to complete initialization 
and start or join an existing cluster.
OHASD starts an ASM instance and ASM can now operate with CSSD initialized and operating. The ASM instance uses special code to locate the contents of 
the ASM SPFILE, assuming it is stored in a Diskgroup.
With an ASM instance operating and its Diskgroups mounted, access to Clusterware’s OCR is available to CRSD.
OHASD starts CRSD with access to the OCR in an ASM Diskgroup.
Clusterware completes initialization and brings up other services under its control.
As Per Oracle doc below are the high level steps for clusterware initialization.

INIT spawns init.ohasd (with respawn) which in turn starts the OHASD process (Oracle High Availability Services Daemon). This daemon spawns 4 processes.

Level 1: OHASD Spawns:
• cssdagent – Agent responsible for spawning CSSD.
• orarootagent – Agent responsible for managing all root owned ohasd resources.
• oraagent – Agent responsible for managing all oracle owned ohasd resources.
• cssdmonitor – Monitors CSSD and node health (along wth the cssdagent).
Level 2: OHASD rootagent spawns:
• CRSD – Primary daemon responsible for managing cluster resources.
• CTSSD – Cluster Time Synchronization Services Daemon
• Diskmon
• ACFS (ASM Cluster File System) Drivers
Level 3: OHASD oraagent spawns:
• MDNSD – Used for DNS lookup
• GIPCD – Used for inter-process and inter-node communication
• GPNPD – Grid Plug & Play Profile Daemon
• EVMD – Event Monitor Daemon
• ASM – Resource for monitoring ASM instances

Level 4: CRSD spawns:
• orarootagent – Agent responsible for managing all root owned crsd resources.
• oraagent – Agent responsible for managing all oracle owned crsd resources.
Level 4: CRSD rootagent spawns:
• Network resource – To monitor the public network
• SCAN VIP(s) – Single Client Access Name Virtual IPs
• Node VIPs – One per node
• ACFS Registery – For mounting ASM Cluster File System
• GNS VIP (optional) – VIP for GNS
Level 5: CRSD oraagent spawns:
• ASM Resource – ASM Instance(s) resource
• Diskgroup – Used for managing/monitoring ASM diskgroups.
• DB Resource – Used for monitoring and managing the DB and instances
• SCAN Listener – Listener for single client access name, listening on SCAN VIP
• Listener – Node listener listening on the Node VIP
• Services – Used for monitoring and managing services
• ONS – Oracle Notification Service
• eONS – Enhanced Oracle Notification Service
• GSD – For 9i backward compatibility
• GNS (optional) – Grid Naming Service – Performs name resolution

The following command will display the status of all cluster resources:

$ ./crsctl status resource -t
Clusterware Important Log File Locations
Clusterware daemon logs are all under : grid_home/log/node_name. Structure under grid_home/log/node_name: alert_node_name.log. 
You can look here first for most clusterware issues:


 ./admin:
 ./agent:
 ./agent/crsd:
 ./agent/crsd/oraagent_oracle:
 ./agent/crsd/ora_oc4j_type_oracle:
 ./agent/crsd/orarootagent_root:
 ./agent/ohasd:
 ./agent/ohasd/oraagent_oracle:
 ./agent/ohasd/oracssdagent_root:
 ./agent/ohasd/oracssdmonitor_root:
 ./agent/ohasd/orarootagent_root:
 ./client:
 ./crsd:
 ./cssd:
 ./ctssd:
 ./diskmon:
 ./evmd:
 ./gipcd:
 ./gnsd:
 ./gpnpd:
 ./mdnsd:
 ./ohasd:
 ./racg:
 ./racg/racgeut:
 ./racg/racgevtf:
 ./racg/racgmain:
 ./srvm:
 ASM logs live under $ORACLE_BASE/diag/asm/+asm//trace 




#######Troubleshooting Clusterware startup problems with detailed debugging info RAC 
https://www.hhutzler.de/blog/troubleshooting-clusterware-startup-problems/
 
What to do first ?
Note 80 % of Clusterware  startup problems are related to:

Disk Space Problems
Network Connectivity Problem with following system Calls are failing 
 bind()  bind() specifies the address & port on the local side of the connection. Check for local IP changes including changes for Netmask, ...           
connect()  connect() specifies the address & port on the remote side of the connection. Check for remote IP changes including changes for Netmask, 
Firewall issues, ...
 gethostbyname()   Check your Nameserver connectivity and configuration
File Protection Problems
This translates to some  very important task before starting Clusterware Debugging :

Check your disk space  using:  #  df
Check whether your are running a firewall: # service iptables status ( <— this command is very important and you should disable  iptables asap if enabled )
Check whether avahi daemon is running : # service avahi-daemon status
Reboot your system to Cleanup special sockets file in:  /var/tmp/.oracle
Verify Network Connectivity  (  ping, nslookup ) and don’t forget to ask your Network Admin for any changes done in last couple of days
Check your ASM disks with kfed for a a valid ASM diskheader

 
Useful OS and CW commands, GREP commands  , OS logfile location  and Clusterware logfile location details
1 : Clusterware logfile structure
CW Alert.log    alert<hostname>.log ( most important one !! )  
OHASD        ohsad.log 
CSSD         ocssd.log   
EVMD         evmd.log 
CRSD         crsd.log

MDSND        mdnsd.log  
GIPCD        gipcd.log  
GPNPD        gpnpd.log  

Agent directories
agent/ohasd
agent/ohasd/oraagent_grid
agent/ohasd/oracssdagent_root
agent/ohasd/oracssdmonitor_root
agent/ohasd/orarootagent_root

2 :  OS System logs

    HPUX       /var/adm/syslog/syslog.log
    AIX        /bin/errpt–a
    Linux      /var/log/messages
    Windows    Refer .TXT log files under Application/System log using Windows Event Viewer
    Solaris    /var/adm/messages 

    Linux Sample
    # grep 'May 20' ./grac41/var/log/messages > SYSLOG
    --> Check SYSLOG for relvant errors

    An typical CW error could look like:  
    # cat  /var/log/messages
    May 13 13:48:27 grac41 OHASD[22203]: OHASD exiting; Directory /u01/app/11204/grid/log/grac41/ohasd not found

3 : Usefull Commands  for a quick check of clusterware status

It may be usefull to run all commands below just to get an idea what is working and what is not working  

3.1 : OS commands ( assume we have CW startup problems on grac41 ) 
# ping grac41 
# route -n 
# /bin/netstat -in
# /sbin/ifconfig -a
# /bin/ping -s <MTU> -c 2 -I source_IP nodename
# /bin/traceroute -s source_IP -r -F  nodename-priv <MTU-28>
# /usr/bin/nslookup  grac41

3.2 : Clusterware commands to debug startup problems
Check Clusterware status 
# crsctl check crs
# crsctl check css
# crsctl check evm
# crsctl stat res -t -init

If OHASD stack is completly up and running you can check your cluster resources with  
# crsctl stat res -t 

3.3 : Checking OLR  to debug startup problems
# ocrcheck -local
# ocrcheck -local -config

3.4 : Checking OCR/Votedisks  to debug startup problems
$ crsctl query css votedisk

Next 2 commands will only work when startup problems are fixed
$ ocrcheck
$ ocrcheck -config

3.5 : Checking GPnP  to debug startup problems 
# $GRID_HOME/bin/gpnptool get
For futher debugging 
# $GRID_HOME/bin/gpnptool lfind  
# $GRID_HOME/bin/gpnptool getpval -asm_spf -p=/u01/app/11204/grid/gpnp/profiles/peer/profile.xml
# $GRID_HOME/bin/gpnptool check -p=/u01/app/11204/grid/gpnp/profiles/peer/profile.xml
# $GRID_HOME/bin/gpnptool verify -p=/u01/app/11204/grid/gpnp/profiles/peer/profile.xml -w="/u01/app/11204/grid/gpnp/grac41/wallets/peer" -wu=peer

3.6 : Cluvfy commands to debug startup problems
Network problems:
$ cluvfy comp nodereach -n grac41 -vebose
Identify your interfaces used for public and private usage and check related networks
$ cluvfy comp nodecon -n grac41,grac42 -i eth1  -verbose    ( public Interface )
$ cluvfy comp nodecon -n grac41,grac42 -i eth2  -verbose    ( private Interface )
$ cluvfy comp nodecon  -n grac41 -verbose
Testing multicast communication for  multicast group "230.0.1.0" .
$ cluvfy  stage -post hwos -n grac42

Cluvfy commands to verify ASM DG and Voting disk location 
Note: Run cluvfy from a working Node ( grac42 ) to get more details 
[grid@grac42 ~]$ cluvfy comp vdisk -n grac41
  ERROR: PRVF-5157 : Could not verify ASM group "OCR" for Voting Disk location "/dev/asmdisk1_udev_sdh1" 
  --> From the error code we know ASM disk group + Voting Disk location 
$ cluvfy comp olr -verbose
$ cluvfy comp software -verbose 
$ cluvfy comp ocr -n grac42,grac41
$ cluvfy comp sys -n grac41 -p crs -verbose 

Comp healthcheck is quite helpfull to get an overview but as OHASD is not running most of the 
errors are related to the CW startup problem.
$ cluvfy comp healthcheck -collect cluster -html
$ firefox cvucheckreport_523201416347.html

4 :  Useful grep Commands

GPnP profile is not accessible - gpnpd needs to be fully up to serve profile
$ fn_egrep.sh "Cannot get GPnP profile|Error put-profile CALL" 
TraceFileName: ./grac41/agent/ohasd/orarootagent_root/orarootagent_root.log
2014-05-20 10:26:44.532: [ default][1199552256]Cannot get GPnP profile. Error CLSGPNP_NO_DAEMON (GPNPD daemon is not running). 
Cannot get GPnP profile
2014-04-21 15:27:06.838: [    GPNP][132114176]clsgpnp_profileCallUrlInt: [at clsgpnp.c:2243] Result: (13) CLSGPNP_NO_DAEMON. 
Error put-profile CALL to remote "tcp://grac41:56376" disco "mdns:service:gpnp._tcp.local.://grac41:56376/agent=gpnpd,cname=grac4,host=grac41,pid=4548/gpnpd h:grac41 c:grac4"

Network socket file doesn't have appropriate ownership or permission
# fn_egrep.sh "clsclisten: Permission denied"
 [ COMMCRS][3534915328]clsclisten: Permission denied for (ADDRESS=(PROTOCOL=ipc)(KEY=grac41DBG_MDNSD))

Problems with Private Interconnect
$ fn.sh "2014-06-03" | egrep 'but no network HB|TraceFileName'
Search String:  no network HB
TraceFileName: ./cssd/ocssd.log
2014-06-02 12:51:52.564: [    CSSD][2682775296]clssnmvDHBValidateNcopy: node 3, grac43, has a disk HB, but no network HB , ..
or
$ fn_egrep.sh "failed to resolve|gipcretFail|gipcretConnectionRefused" | egrep 'TraceFile|2014-05-20 11:0'
TraceFileName: ./grac41/crsd/crsd.log and  ./grac41/evmd/evmd.log may report
2014-05-20 11:04:02.563: [GIPCXCPT][154781440] gipchaInternalResolve: failed to resolve ret gipcretKeyNotFound (36), host 'grac41', port 'ffac-854b-c525-6f9c', hctx 0x2ed3940 [0000000000000010] { gipchaContext : host 'grac41', name 'd541-9a1e-7807-8f4a', luid 'f733b93a-00000000', numNode 0, numInf 1, usrFlags 0x0, flags 0x5 }, ret gipcretKeyNotFound (36)
2014-05-20 11:04:02.563: [GIPCHGEN][154781440] gipchaResolveF [gipcmodGipcResolve : gipcmodGipc.c : 806]: EXCEPTION[ ret gipcretKeyNotFound (36) ]  failed to resolve ctx 0x2ed3940 [0000000000000010] { gipchaContext : host 'grac41', name 'd541-9a1e-7807-8f4a', luid 'f733b93a-00000000', numNode 0, numInf 1, usrFlags 0x0, flags 0x5 }, host 'grac41', port 'ffac-854b-c525-6f9c', flags 0x0

Is there a valid CI network device ?
# fn_egrep.sh "NETDATA" | egrep 'TraceFile|2014-06-03'
TraceFileName: ./gipcd/gipcd.log
2014-06-03 07:48:45.401: [ CLSINET][3977414400] Returning NETDATA: 1 interfaces <-- ok
2014-06-03 07:52:51.589: [ CLSINET][1140848384] Returning NETDATA: 0 interfaces <-- problems !

Are Voting Disks acessible ?
$ fn_egrep.sh "Successful discovery"
TraceFileName: ./grac41/cssd/ocssd.log
2014-05-22 13:41:38.776: [    CSSD][1839290112]clssnmvDiskVerify: Successful discovery of 0 disks file=/backup/dumps/EXP_FREECALL_Jun2021.dmp log=/backup/dumps/EXP_FREECALL_Jun2021_2.log fromuser=unicorn touser=Housekeep constraints=n rows=y indexes=n ignore=y

Query to Check Failed Jobs in Oracle Database.

select JOB,LAST_DATE,THIS_DATE,NEXT_DATE,BROKEN,FAILURES,WHAT from dba_jobs where failures>0;

select count(*) from dba_jobs where FAILURES>0;


https://databaseorg.com/documentation/check-failed-jobs-in-oracle/




--LENTITUD 

Como comentabamos, el tema de lentitud viene dado por fragmentación en las tablas, esto genera saltos innecesarios en las agujas lectoras de la SAN.
Esta es la razon por la qe en las metricas de OS se nota que el trabajo es bastante alto (%b y %W) pero la cantidad de datos enviados a las controladoras es poco ( kw y kr menos de 20mb).


Para mantenimientos posteriores pueden usar este query para determinar las tablas con fragmentación excesiva, un indicador de lentitud es cuando se sobrepasa el 20% de fragmentación, 

SELECT table_name,
ROUND ( (blocks / 1024 * 8), 2) "size (mb)",
ROUND ( (num_rows * avg_row_len / 1024 / 1024), 2) "actual_data (mb)",
( ROUND ( (blocks / 1024 * 8), 2)
- ROUND ( (num_rows * avg_row_len / 1024 / 1024), 2))
"wasted_space (mb)"
FROM dba_tables
WHERE (ROUND ( (blocks / 1024 * 8), 2) >
ROUND ( (num_rows * avg_row_len / 1024 / 1024), 2))
and owner='SIEBEL'
ORDER BY 4 DESC;


Se divide el espacio desperdiciado (wasted) entre el tamaño(size) y esto se multiplica por 100%, para el caso la tabla siebel.s_Srv_req; con un tamaño de 4.1G tiene una fragmentación del 52%.
Con el siguiente query determinen los indices en base a tamaño para poder balancear la tarea de rebuild indices:

select segment_name,sum(bytes)/1024/1024 MB from dba_segments 
where segment_Name in (select index_name from dba_indexes where owner='SIEBEL' and status='UNUSABLE') group by 
segment_name order by MB;

Con el siguiente query determinen o generen las sentencias para reconstruir los indices, recuerden en base a los cores del CPU, no poner mas de 2 o 3 trabajos de rebuild al mismo tiempo si son pequeños los indices, o 1 rebuild si es grande.

Existen un aprox de 15-20 indices de tamaño grande que tardaran un aprox de 29 Minutos que fue la prueba que yo hice con uno de los 4 mas grande, los otros indices sonpequeños y debera hacerlo más rapido.

Para Ejemplo:
11:23:55 SQL> set timing on
11:23:57 SQL> alter index siebel.S_QUOTE_SOLN_U1 rebuild parallel 3;
Index altered.
Elapsed: 00:28:42.11


--CONTEO cantidad de registros de todas las tablas en un esquema
select
   table_name,
   to_number(
   extractvalue(
      xmltype(
         dbms_xmlgen.getxml('select count(*) c from icttstict'||table_name))
    ,'/ROWSET/ROW/C')) count
from 
   user_tables
order by 
   table_name;
   
   
   
--Exportar cierta cantidad de filas en un expdp - top rows   
cat rich.par
include=TABLE:"='DEMO'"
query="where col1 in (select col1 from (select col1,row_number() over (order by col1 asc) as x from demo) where x <=5)"



--tamaño tabla sql server 

SELECT t.NAME AS TableName, s.Name AS SchemaName, p.rows AS RowCounts,
SUM(a.total_pages) * 8 AS TotalSpaceKB, SUM(a.used_pages) * 8 AS UsedSpaceKB,
(SUM(a.total_pages) - SUM(a.used_pages)) * 8 AS NoutilizadoSpaceKB
FROM sys.tables t
INNER JOIN sys.indexes i ON t.OBJECT_ID = i.object_id
INNER JOIN sys.partitions p ON i.object_id = p.OBJECT_ID AND i.index_id = p.index_id
INNER JOIN sys.allocation_units a ON p.partition_id = a.container_id
LEFT OUTER JOIN sys.schemas s ON t.schema_id = s.schema_id
WHERE t.NAME NOT LIKE 'dt%' AND t.is_ms_shipped = 0 AND i.OBJECT_ID> 255
GROUP BY t.Name, s.Name, p.Rows
ORDER BY UsedSpaceKB DESC



--https://oracle-base.com/articles/linux/automating-database-startup-and-shutdown-on-linux

How to confirm Oracle automatic startup on Linux.
The dbstart utility reads the oratab file. Confirm it in the example below

[HuuPV@DevopsRoles ~]$ sudo su - oracle
[oracle@DevopsRoles ~]$ cat /etc/oratab

 DEVOPSROLES_SID:/opt/oracle/product/11.2.0/dbhome_1:Y 
 DEVOPSROLES_SID02:/opt/oracle/product/10.2.03/dbhome_2:N
We see there are two instances on this server. Oralce 10.2.03 is marked “N” will not re-start when Linux OS reboot. Oracle 11.2.0 is marked “Y” will re-start when Linux OS reboot.

Auto Start Oracle on Linux
1. In the /etc/oratab file with autostart column to “Y”

[oracle@DevopsRoles ~]$ cat /etc/oratab
DEVOPSROLES_SID:/opt/oracle/product/11.2.0/dbhome_1:Y
2. Create the file named “oracle” in /etc/init.d folder.

[root@DevopsRoles ~]# cd /etc/init.d
[root@DevopsRoles init.d]# vi oracle

#!/bin/sh
ORACLE_HOME=/opt/oracle/product/11.2.0/dbhome_1
ORACLE_OWNER=oracle
case "$1" in
'start') # Start the Oracle databases and listeners
su - $ORACLE_OWNER -c "$ORACLE_HOME/bin/dbstart $ORACLE_HOME"
;;
'stop') # Stop the Oracle databases and listeners
su - $ORACLE_OWNER -c "$ORACLE_HOME/bin/dbshut $ORACLE_HOME"
;;
esac
3. Create symbolic link

[root@DevopsRoles ~]# ln -s /etc/init.d/oracle /etc/rc0.d/K10oracle
[root@DevopsRoles ~]# ln -s /etc/init.d/oracle /etc/rc3.d/S99oracle
4. Change permissions

[root@DevopsRoles ~]# chmod 750 /etc/init.d/oracle
5. use chkconfig command to associate the dbora service

[root@DevopsRoles ~]# chkconfig --level 2345 oracle on
Test
restart oracle server. Then check the instance status

[oracle@DevopsRoles ~]$ ps -ef | grep smon | grep -v grep
Check the listener status

[oracle@DevopsRoles ~]$ lsnrctl status

---https://www.devopsroles.com/oracle-automatic-startup-on-linux/

Analyze de Particiones, subparticiones

select table_name, partition_name, last_analyzed
from ALL_TAB_PARTITIONS
WHERE table_owner = 'OCDM_SYS'
and TABLE_NAME='DWB_ACCT_PYMT' 
order by partition_name desc

SET LINES 333 PAGES 222
COL OWNER FOR A11
COL TABLE_NAME FOR A15
COL GLOBAL_STATS FOR A13
COL PARTITION_NAME FOR A15
COL TABLE_OWNER FOR A15
 
SELECT TABLE_OWNER,TABLE_NAME, PARTITION_NAME,NUM_ROWS,TO_CHAR(LAST_ANALYZED,'DD-MON-YYYY:HH24:MI:SS') LAST_ANALYZED,GLOBAL_STATS 
FROM DBA_TAB_PARTITIONS 
WHERE TABLE_OWNER='OCDM_SYS' 
AND TABLE_NAME='DWB_ACCT_PYMT' 
ORDER BY TABLE_OWNER,TABLE_NAME,PARTITION_NAME,LAST_ANALYZED;
 

SET LINES 333 PAGES 222
COL OWNER FOR A11
COL TABLE_NAME FOR A23
COL GLOBAL_STATS FOR A13
COL PARTITION_NAME FOR A15
COL SUBPARTITION_NAME FOR A19
COL TABLE_OWNER FOR A15
 
SELECT TABLE_OWNER,TABLE_NAME, PARTITION_NAME,SUBPARTITION_NAME,NUM_ROWS,TO_CHAR(LAST_ANALYZED,'DD-MON-YYYY:HH24:MI:SS') LAST_ANALYZED,GLOBAL_STATS FROM DBA_TAB_SUBPARTITIONS 
WHERE TABLE_OWNER='OCDM_SYS'
AND TABLE_NAME='DWB_ACCT_PYMT'
AND ROWNUM<11 
ORDER BY TABLE_OWNER,TABLE_NAME,PARTITION_NAME,SUBPARTITION_NAME,LAST_ANALYZED;


--crear wallet


 APX1
Primero crear el wallet 
orapki wallet create -wallet /u01/app/oracle/admin/apx1/wallet -pwd WalletPasswd123 -auto_login

Luego agregar los certificados al wallet previamente creado
orapki wallet add -wallet /u01/app/oracle/admin/apx1/wallet -trusted_cert -cert "CertificadoRoot.cer" -pwd WalletPasswd123
orapki wallet add -wallet /u01/app/oracle/admin/apx1/wallet -trusted_cert -cert "SecureCertificateAuthority.cer" -pwd WalletPasswd123
orapki wallet add -wallet /u01/app/oracle/admin/apx1/wallet -trusted_cert -cert "Class2CertificationAuthority.cer" -pwd WalletPasswd123



###### EN CSAT
###### REQUISITO!!!: SE DEBE TRANSFERIR POR FTP LOS CERTIFICADOS REQUERIDOS POR EL WALLET(ESTO LO MANDA DESARROLLO)
###### Primero crear el wallet en una ruta del servidor de BD que ellos usarán.(cwp-jfr-soc-csat en este caso)
orapki wallet create -wallet /u01/app/oracle/wallet -pwd WalletPasswd123 -auto_login

## EJEMPLO DE LA SALIDA
oracle@cwp-jfr-soc-csat:/u01/app/oracle$ orapki wallet create -wallet /u01/app/oracle/wallet -pwd WalletPasswd123 -auto_login
Oracle PKI Tool : Version 11.2.0.4.0 - Production
Copyright (c) 2004, 2013, Oracle and/or its affiliates. All rights reserved.

oracle@cwp-jfr-soc-csat:/u01/app/oracle$


###### Luego entrar al wallet mediante cd /u01/app/oracle/wallet y agregar los certificados al wallet previamente creado

orapki wallet add -wallet /u01/app/oracle/wallet -trusted_cert -cert "AutoridadCertificadora_1.cer" -pwd WalletPasswd123
orapki wallet add -wallet /u01/app/oracle/wallet -trusted_cert -cert "RootCertificateAuthority_2.cer" -pwd WalletPasswd123
orapki wallet add -wallet /u01/app/oracle/wallet -trusted_cert -cert "SecureCertificateAuthority_3.cer" -pwd WalletPasswd123


## EJEMPLO DE LA SALIDA
oracle@cwp-jfr-soc-csat:/u01/app/oracle/wallet$ orapki wallet add -wallet /u01/app/oracle/wallet -trusted_cert -cert "AutoridadCertificadora_1.cer" -pwd WalletPasswd123
Oracle PKI Tool : Version 11.2.0.4.0 - Production
Copyright (c) 2004, 2013, Oracle and/or its affiliates. All rights reserved.

oracle@cwp-jfr-soc-csat:/u01/app/oracle/wallet$ orapki wallet add -wallet /u01/app/oracle/wallet -trusted_cert -cert "RootCertificateAuthority_2.cer" -pwd WalletPasswd123
Oracle PKI Tool : Version 11.2.0.4.0 - Production
Copyright (c) 2004, 2013, Oracle and/or its affiliates. All rights reserved.

oracle@cwp-jfr-soc-csat:/u01/app/oracle/wallet$ orapki wallet add -wallet /u01/app/oracle/wallet -trusted_cert -cert "SecureCertificateAuthority_3.cer" -pwd WalletPasswd123
Oracle PKI Tool : Version 11.2.0.4.0 - Production
Copyright (c) 2004, 2013, Oracle and/or its affiliates. All rights reserved.

oracle@cwp-jfr-soc-csat:/u01/app/oracle/wallet$



oracle@cwp-jfr-lporc32:/u01/app/oracle/admin/apx1/wallet$ orapki wallet create -wallet /u01/app/oracle/admin/apx1/wallet/ -pwd WalletPasswd123 -auto_login
Oracle PKI Tool : Version 12.2.0.1.0
Copyright (c) 2004, 2016, Oracle and/or its affiliates. All rights reserved.

Operation is successfully completed.
oracle@cwp-jfr-lporc32:/u01/app/oracle/admin/apx1/wallet$  orapki wallet add -wallet /u01/app/oracle/admin/apx1/wallet -trusted_cert -cert "CertificadoRoot.cer" -pwd WalletPasswd123
Oracle PKI Tool : Version 12.2.0.1.0
Copyright (c) 2004, 2016, Oracle and/or its affiliates. All rights reserved.

Operation is successfully completed.


orapki wallet create -wallet /u01/app/oracle/admin/apx1/wallet/ -pwd WalletPasswd123 -auto_login
orapki wallet add -wallet /u01/app/oracle/admin/apx1/wallet -trusted_cert -cert "CertificadoRoot.cer" -pwd WalletPasswd123
orapki wallet add -wallet /u01/app/oracle/admin/apx1/wallet -trusted_cert -cert "SecureCertificateAuthority.cer" -pwd WalletPasswd123
orapki wallet add -wallet /u01/app/oracle/admin/apx1/wallet -trusted_cert -cert "Class2CertificationAuthority.cer" -pwd WalletPasswd123



Credenciales de Equipos:
Información de la Base de Datos:
Servidor: CWP-JFR-SOC-CSAT(P 172.18.236.39)
Puerto:1521
SID: ORCL
 
Información del webtier:
Servidor: cwp-jfr-soc-csat-web(192.168.99.45)
 
 
Username/password
ssa/sun01ssa
root/sun01ssa
oracle/dba2k15
 
Para reiniciar los servicios del webtier:
/u01/app/oracle/producto/Middleware/Oracle_WT1/instances/ohs1/bin/opmnctl stopall
 
/u01/app/oracle/producto/Middleware/Oracle_WT1/instances/ohs1/bin/opmnctl startall
 
oracle@cwp-jfr-soc-csat-web:$  /u01/app/oracle/producto/Middleware/Oracle_WT1/instances/ohs1/bin/opmnctl status
 


--Generar SQL Server drop statement
SELECT * 
FROM sys.foreign_keys
WHERE referenced_object_id = object_id('Student')


SELECT 
'ALTER TABLE ' +  OBJECT_SCHEMA_NAME(parent_object_id) +
'.[' + OBJECT_NAME(parent_object_id) + 
'] DROP CONSTRAINT ' + name
FROM sys.foreign_keys
WHERE referenced_object_id = object_id('Student')


-----------

Para hacer de su conocimiento un procedimiento especial que hay que realizar con los usuarios de SO que no sean root, en el ambiente de EXADATA. Estos usuarios estaban inaccesibles y hay que realizar un paso adicional cuando se cambie el usuario por sistema operativo.

Estas son las instrucciones:

Si se quiere cambiar la contraseña, se utiliza el comando por sistema operativo con root, que normalmente se utiliza siempre:
Ejemplo:
[root@rac01-adm01vm01 ~]$ passwd oracle

Luego de que se le setea el password escogido, este es el comando para desbloquear:

pam_tally2 -u oracle --reset

Las contraseñas actuales para los servidores rac01-adm01vm01.cwpanama.com & rac01-adm02vm01.cwpanama.com, del usuario Oracle y OMA son:

oracle/dba2k21
oma/welcome1  se cambia a   dMGEn5En!


pam_tally2 -u oma --reset

------------


Consola Ordenes perdió conexión de red  dll regsrv regedit...
[7/14 10:45 AM] Daniel Guerrero (Guest)
    
net stop policyagent
regsvr32 polstore.dll
net start policyagent



#SERVICIOS AUTO_START en never
[grid@CWP-JFR-ICT2PRD ~]$ crsctl modify resource ora.FRA.dg -attr "AUTO_START=always" -init
[grid@CWP-JFR-ICT2PRD ~]$ crsctl modify resource ora.GRID.dg -attr "AUTO_START=always" -init
[grid@CWP-JFR-ICT2PRD ~]$ crsctl modify resource ora.LISTENER.lsnr -attr "AUTO_START=always" -init
[grid@CWP-JFR-ICT2PRD ~]$ crsctl modify resource ora.ictdb.db -attr "AUTO_START=always" -init
[grid@CWP-JFR-ICT2PRD ~]$ crsctl status res -attr "AUTO_START" -p

Validar tambien el servicio oracleasm en enable
[root@CWP-JFR-ICT2PRD ~]# systemctl status oracleasm.service
? oracleasm.service - Load oracleasm Modules
   Loaded: loaded (/usr/lib/systemd/system/oracleasm.service; enabled; vendor preset: disabled)
   Active: inactive (dead)
[root@CWP-JFR-ICT2PRD ~]# su - oracle
[oracle@CWP-JFR-ICT2PRD ~]$ systemctl status oracleasm.service
? oracleasm.service - Load oracleasm Modules
   Loaded: loaded (/usr/lib/systemd/system/oracleasm.service; enabled; vendor preset: disabled)
   Active: inactive (dead)
[oracle@CWP-JFR-ICT2PRD ~]$



##DURATION - BACKUP DE RMAN-.- TIEMPO DURACION RMAN

col STATUS format a9
col hrs format 999.99
select SESSION_KEY, INPUT_TYPE, STATUS,
to_char(START_TIME,'mm/dd/yy hh24:mi') start_time,
to_char(END_TIME,'mm/dd/yy hh24:mi') end_time,
elapsed_seconds/3600 hrs from V$RMAN_BACKUP_JOB_DETAILS
order by session_key;



PA21JL01W602
alquiler lavadora: 6689 9856

##Tamaño tabla SQL 2000  - no te da el tamaño sino la cantidad de registros...
select o.name, rows 
from sysindexes i join sysobjects o on o.id=i.id
where indid < 2 and type='U'
order by 2 desc


###GET DLL para un usuario

SELECT dbms_metadata.get_ddl('USER','COLLECTOR_ETL') FROM dual

UNION ALL

SELECT DBMS_METADATA.GET_GRANTED_DDL('ROLE_GRANT','COLLECTOR_ETL') from dual

UNION ALL

select DBMS_METADATA.GET_GRANTED_DDL('SYSTEM_GRANT','COLLECTOR_ETL') from dual

UNION ALL

SELECT DBMS_METADATA.GET_GRANTED_DDL('OBJECT_GRANT','COLLECTOR_ETL') from dual

/




####ESPACIO EN DISCO DESDE SQL SERVER

para 2008 o mas viejas 
exec master.dbo.xp_fixeddrives

##POSTERIOR A 2008

select distinct
convert(varchar(512), b.volume_mount_point) as [volume_mount_point]
, convert(varchar(512), b.logical_volume_name) as [logical_volume_name]
, convert(decimal(18,1), round(((convert(float, b.available_bytes) / convert(float, b.total_bytes)) * 100),1)) as [percent_free]
, convert(bigint, round(((b.available_bytes / 1024.0)/1024.0),0)) as [free_mb]
, convert(bigint, round(((b.total_bytes / 1024.0)/1024.0),0)) as [total_mb]
, convert(bigint, round((((b.total_bytes - b.available_bytes) / 1024.0)/1024.0),0)) as [used_mb]
from sys.master_files as [a]
CROSS APPLY sys.dm_os_volume_stats(a.database_id, a.[file_id]) as [b]
 
-----------------------------------------




#PURGADO DE AHF -TFA


$ tfactl managelogs -purge -older 30d -dryrun

tfactl set manageLogsAutoPurge=ON
tfactl set manageLogsAutoPurgePolicyAge=30d
tfactl set manageLogsAutoPurgeInterval=60


Successfully set manageLogsAutoPurge=ON
.-------------------------------------------------------.
|                    rac01-adm01vm01                    |
+-----------------------------------------------+-------+
| Configuration Parameter                       | Value |
+-----------------------------------------------+-------+
| Managelogs Auto Purge ( manageLogsAutoPurge ) | ON    |
'-----------------------------------------------+-------'

[root@rac01-adm01vm01 .exachk_122920_02036_discovery]# tfactl set manageLogsAutoPurgePolicyAge=30d
Successfully set manageLogsAutoPurgePolicyAge=30d
.----------------------------------------------------------------------------------------------------------------.
|                                                 rac01-adm01vm01                                                |
+--------------------------------------------------------------------------------------------------------+-------+
| Configuration Parameter                                                                                | Value |
+--------------------------------------------------------------------------------------------------------+-------+
| Logs older than the time period will be auto purged(days[d]|hours[h]) ( manageLogsAutoPurgePolicyAge ) | 30d   |
'--------------------------------------------------------------------------------------------------------+-------'

[root@rac01-adm01vm01 .exachk_122920_02036_discovery]# tfactl set manageLogsAutoPurgeInterval=60
Successfully set manageLogsAutoPurgeInterval=60
.----------------------------------------------------------------------------------------------------------.
|                                              rac01-adm01vm01                                             |
+--------------------------------------------------------------------------------------------------+-------+
| Configuration Parameter                                                                          | Value |
+--------------------------------------------------------------------------------------------------+-------+
| Time interval between consecutive Managelogs Auto Purge(minutes) ( manageLogsAutoPurgeInterval ) | 60    |
'--------------------------------------------------------------------------------------------------+-------'

[root@rac01-adm01vm01 .exachk_122920_02036_discovery]# tfactl managelogs -purge -older 30d -dryrun


Output from host : rac01-adm01vm01
------------------------------
2021-10-15 16:35:55: INFO Estimating files older than 30 days

2021-10-15 16:35:55: INFO Space is calculated in bytes [without round off]

2021-10-15 16:35:55: INFO Performing Dry Run of Purge for Grid Infrastructure ADR Destinations

2021-10-15 16:35:56: WARNING Diagnostic Destination "/u01/app/grid_base/diag/crs/rac01-adm01vm01/crs" will NOT be Purged as the current user does not match that of the ADR Metadata for the ADR Home.
2021-10-15 16:35:56: INFO Diagnostic Destination "/u01/app/grid_base/diag/asm/+asm/+ASM1" will Be Purged
2021-10-15 16:35:56: INFO Diagnostic Destination "/u01/app/grid_base/diag/tnslsnr/rac01-adm01vm01/listener" will Be Purged
2021-10-15 16:35:56: INFO Diagnostic Destination "/u01/app/grid_base/diag/tnslsnr/rac01-adm01vm01/listener_scan3" will Be Purged
2021-10-15 16:35:56: INFO Diagnostic Destination "/u01/app/grid_base/diag/tnslsnr/rac01-adm01vm01/listener_scan2" will Be Purged
2021-10-15 16:35:56: INFO Diagnostic Destination "/u01/app/grid_base/diag/tnslsnr/rac01-adm01vm01/mgmtlsnr" will Be Purged
2021-10-15 16:35:56: INFO Diagnostic Destination "/u01/app/grid_base/diag/tnslsnr/rac01-adm01vm01/listener_scan1" will Be Purged
2021-10-15 16:35:56: INFO Diagnostic Destination "/u01/app/grid_base/diag/rdbms/_mgmtdb/-MGMTDB" will Be Purged

2021-10-15 16:35:56: MESSAGE Diagnostic Destinations for GI Home Purged: - 0 files deleted , 0 bytes space recovered

2021-10-15 16:35:56: MESSAGE Calculating Filesystem Before/After Sizes...

    ==== Grid Infrastructure ADR Filesystem(s) Size Summary ====

.------------------------------------------------------------------.
|      File System Variation for ADR Path: /u01/app/grid_base      |
+--------+------+----------+----------+---------+----------+-------+
| State  | Name | Size     | Used     | Free    | Capacity | Mount |
+--------+------+----------+----------+---------+----------+-------+
| Before |      | 20642428 | 11532496 | 8061356 |      59% | /u01  |
| After  |      | 20642428 | 11532496 | 8061356 |      59% | /u01  |
'--------+------+----------+----------+---------+----------+-------'

2021-10-15 16:35:56: INFO Diagnostic Destination "/u01/app/oracle_base/diag/rdbms/cwbdb/cwbdb" will Be Purged
2021-10-15 16:35:56: INFO Diagnostic Destination "/u01/app/oracle_base/diag/rdbms/cwbdb/cwbdb1" will Be Purged

2021-10-15 16:35:56: INFO Diagnostic Destination "/u01/app/oracle_base/diag/rdbms/ocdmdb/ocdmdb" will Be Purged

2021-10-15 16:35:56: INFO Diagnostic Destination "/u01/app/oracle_base/diag/rdbms/ocdm/OCDM" will Be Purged
2021-10-15 16:35:56: INFO Diagnostic Destination "/u01/app/oracle_base/diag/rdbms/ocdm/OCMD" will Be Purged


2021-10-15 16:35:56: MESSAGE Diagnostic Destinations for Database Home(s) Purged: - 0 files deleted , 0 bytes space recovered

2021-10-15 16:35:56: MESSAGE Calculating Filesystem Before/After Sizes...

    ==== Database Home(s) ADR Filesystem(s) Size Summary ====

.------------------------------------------------------------------.
|     File System Variation for ADR Path: /u01/app/oracle_base     |
+--------+------+----------+----------+---------+----------+-------+
| State  | Name | Size     | Used     | Free    | Capacity | Mount |
+--------+------+----------+----------+---------+----------+-------+
| Before |      | 20642428 | 11532496 | 8061356 |      59% | /u01  |
| After  |      | 20642428 | 11532496 | 8061356 |      59% | /u01  |
'--------+------+----------+----------+---------+----------+-------'



--- hacer grant de todas las tablas de un usuario a otro...se pasan dos parametros el Usuario dueño   y el grantee (destinatario)
 
CREATE PROCEDURE grant_select(
    username VARCHAR2, 
    grantee VARCHAR2)
AS   
BEGIN
    FOR r IN (
        SELECT owner, table_name 
        FROM all_tables 
        WHERE owner = username
    )
    LOOP
        EXECUTE IMMEDIATE 
            'GRANT SELECT ON '||r.owner||'.'||r.table_name||' to ' || grantee;
    END LOOP;
END; 


--###LUEGO SE EJECUTA de ESTA MANERA:   EXEC grant_select('OT','DW');


####################3
Can't initialize OCI. Error -1


So the key lesson or conclusion to take away from this blog is as follows: TOAD
can connect to Oracle databases and it works 99.99% of the time. If you have a
problem and get some Oracle connection error message, odds are that you have one
of the following problems: a bad SQL*net install, are pointing to the wrong
Oracle Home, have a Windows PATH environment ordering problem, or some other
user setup and configuration problem related to your Windows and/or Oracle home.
https://forums.toadworld.com/t/cant-initialize-oci-error-1/9288/7

--Corregido quitando el ORACLE_HOME DE MI VARIABLE DE AMBIENTE 

he error is encountered when we try to connect to a database. any database actually.
The error may be encountered one day, without any reason.
OCI error may be just for some users.. Even if all the users are using a single toad binary through the Windows Terminal Server, this error may be seen only by some users..


The solution is to delete the directory named AppData\Roaming\Quest Software\Toad for Oracle for the problematic users.. Note that : if you delete this directory your license info, your password and your connection information will be deleted too.
An alternative may be to delete the directory of the problematic user and copy the same directory from another user.. Like copying C:\Users\erman\AppData\Roaming\Quest Software\ to C:\Users\ali\AppData\Roaming\Quest Software
https://ermanarslan.blogspot.com/2014/11/toad-for-oracle-oci-cant-initialize.html


systeminfo | find "boot"


--resetear el sa en SQL Server
https://www.arysontechnologies.com/blog/how-to-reset-sa-password-sql-server/


Microsoft Windows [Version 10.0.17763.1158]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Windows\system32>net stop msssqlserver
The service name is invalid.

More help is available by typing NET HELPMSG 2185.


C:\Windows\system32>net stop mssqlserver
The following services are dependent on the SQL Server (MSSQLSERVER) service.
Stopping the SQL Server (MSSQLSERVER) service will also stop these services.

   SQL Server Agent (MSSQLSERVER)

Do you want to continue this operation? (Y/N) [N]: y
The SQL Server Agent (MSSQLSERVER) service is stopping.
The SQL Server Agent (MSSQLSERVER) service was stopped successfully.

The SQL Server (MSSQLSERVER) service is stopping.....
The SQL Server (MSSQLSERVER) service was stopped successfully.


C:\Windows\system32>net start mssqlserver /m"sqlcmd"
The SQL Server (MSSQLSERVER) service is starting..
The SQL Server (MSSQLSERVER) service was started successfully.


C:\Windows\system32>sqlcmd
Sqlcmd: Error: Microsoft ODBC Driver 13 for SQL Server : Login failed for user 'CWP\AQQ08381'. Reason: Server is in single user mode. Only one administrator can connect at this time..

C:\Windows\system32>sqlcmd
Sqlcmd: Error: Microsoft ODBC Driver 13 for SQL Server : Named Pipes Provider: Could not open a connection to SQL Server [2]. .
Sqlcmd: Error: Microsoft ODBC Driver 13 for SQL Server : Login timeout expired.
Sqlcmd: Error: Microsoft ODBC Driver 13 for SQL Server : A network-related or instance-specific error has occurred while establishing a connection to SQL Server. Server is not found or not accessible. Check if instance name is correct and if SQL Server is configured to allow remote connections. For more information see SQL Server Books Online..

C:\Windows\system32>net start mssqlserver /m"SQLCMD"
The SQL Server (MSSQLSERVER) service is starting..
The SQL Server (MSSQLSERVER) service was started successfully.


C:\Windows\system32>sqlcmd
1> create login sa2 with password='dba2k00!'
2> go
1> sp_addsrvrolemember sa2,'sysadmin'
2> go
1> exit

C:\Windows\system32>net stop mssqlserver
The SQL Server (MSSQLSERVER) service is stopping...
The SQL Server (MSSQLSERVER) service was stopped successfully.


C:\Windows\system32>


--tamaños unidades disco , fixed drive, unidad c

select distinct
convert(varchar(512), b.volume_mount_point) as [volume_mount_point]
, convert(varchar(512), b.logical_volume_name) as [logical_volume_name]
, convert(decimal(18,1), round(((convert(float, b.available_bytes) / convert(float, b.total_bytes)) * 100),1)) as [percent_free]
, convert(bigint, round(((b.available_bytes / 1024.0)/1024.0),0)) as [free_mb]
, convert(bigint, round(((b.total_bytes / 1024.0)/1024.0),0)) as [total_mb]
, convert(bigint, round((((b.total_bytes - b.available_bytes) / 1024.0)/1024.0),0)) as [used_mb]
from sys.master_files as [a]
CROSS APPLY sys.dm_os_volume_stats(a.database_id, a.[file_id]) as [b]


exec master.dbo.xp_fixeddrives

 


--ORACLE REDO Quienes generan tanto archive
select executions, rows_processed, sql_text
   from v$sql
   where rows_processed > 10
   and upper(sql_text) not like 'SELECT%'
   and parsing_user_id != 0               -- to ignore SYS
   and command_type != 47                 -- to ignore PL/SQL
   order by rows_processed desc;
   

--Estadisticas SQL Server

--ejecutar esto para generar el script de generación de estadisticas.
SELECT 'UPDATE STATISTICS [dbo].[TBL_Daños] ' +  s.name AS statistics_name  
FROM sys.stats AS s  
INNER JOIN sys.stats_columns AS sc   
    ON s.object_id = sc.object_id AND s.stats_id = sc.stats_id  
INNER JOIN sys.columns AS c   
    ON sc.object_id = c.object_id AND c.column_id = sc.column_id  
WHERE s.object_id = OBJECT_ID('TBL_Daños');  --solo poner el nombre de la tabla


--Query para buscar las estadísticas de una tabla
SELECT s.name AS statistics_name  
      ,c.name AS column_name  
      ,sc.stats_column_id  
FROM sys.stats AS s  
INNER JOIN sys.stats_columns AS sc   
    ON s.object_id = sc.object_id AND s.stats_id = sc.stats_id  
INNER JOIN sys.columns AS c   
    ON sc.object_id = c.object_id AND c.column_id = sc.column_id  
WHERE s.object_id = OBJECT_ID('TBL_Daños');  



 Recepción e información de pacientes Regional de David: 777-8432 y 777-8433 horario entre 11 a 2 pm
 
 Conteo cantidad de tablas en una bD
 SELECT COUNT(*) FROM information_schema.tables
 
 
 
 col program for a10
col username for a10
select to_char(sysdate,'hh24:mi'), username, program , a.sid, a.serial#, b.name, c.value
from v$session a, v$statname b, v$sesstat c
where b.STATISTIC# =c.STATISTIC#
and c.sid=a.sid and b.name like 'redo%'
order by value;

--sesiones usando una tabla
SELECT a.object,
a.type,
a.sid,
b.username,
b.osuser,
b.program
FROM v$access a,
v$session b
WHERE a.sid = b.sid
AND a.object = 'DWD_SBCRBR_BASE_DTL_HIST_CWP ' 
ORDER BY a.object




--SCRIPT SACAR TODOS LOS INDICES - idx
declare @SchemaName varchar(100)declare @TableName varchar(256)
declare @IndexName varchar(256)
declare @ColumnName varchar(100)
declare @is_unique varchar(100)
declare @IndexTypeDesc varchar(100)
declare @FileGroupName varchar(100)
declare @is_disabled varchar(100)
declare @IndexOptions varchar(max)
declare @IndexColumnId int
declare @IsDescendingKey int 
declare @IsIncludedColumn int
declare @TSQLScripCreationIndex varchar(max)
declare @TSQLScripDisableIndex varchar(max)

declare CursorIndex cursor for
 select schema_name(t.schema_id) [schema_name], t.name, ix.name,
 case when ix.is_unique = 1 then 'UNIQUE ' else '' END 
 , ix.type_desc,
 case when ix.is_padded=1 then 'PAD_INDEX = ON, ' else 'PAD_INDEX = OFF, ' end
 + case when ix.allow_page_locks=1 then 'ALLOW_PAGE_LOCKS = ON, ' else 'ALLOW_PAGE_LOCKS = OFF, ' end
 + case when ix.allow_row_locks=1 then  'ALLOW_ROW_LOCKS = ON, ' else 'ALLOW_ROW_LOCKS = OFF, ' end
 + case when INDEXPROPERTY(t.object_id, ix.name, 'IsStatistics') = 1 then 'STATISTICS_NORECOMPUTE = ON, ' else 'STATISTICS_NORECOMPUTE = OFF, ' end
 + case when ix.ignore_dup_key=1 then 'IGNORE_DUP_KEY = ON, ' else 'IGNORE_DUP_KEY = OFF, ' end
 + 'SORT_IN_TEMPDB = OFF, FILLFACTOR =' + CAST(ix.fill_factor AS VARCHAR(3)) AS IndexOptions
 , ix.is_disabled , FILEGROUP_NAME(ix.data_space_id) FileGroupName
 from sys.tables t 
 inner join sys.indexes ix on t.object_id=ix.object_id
 where ix.type>0 and ix.is_primary_key=0 and ix.is_unique_constraint=0 --and schema_name(tb.schema_id)= @SchemaName and tb.name=@TableName
 and t.is_ms_shipped=0 and t.name<>'sysdiagrams'
 order by schema_name(t.schema_id), t.name, ix.name

open CursorIndex
fetch next from CursorIndex into  @SchemaName, @TableName, @IndexName, @is_unique, @IndexTypeDesc, @IndexOptions,@is_disabled, @FileGroupName

while (@@fetch_status=0)
begin
 declare @IndexColumns varchar(max)
 declare @IncludedColumns varchar(max)
 
 set @IndexColumns=''
 set @IncludedColumns=''
 
 declare CursorIndexColumn cursor for 
  select col.name, ixc.is_descending_key, ixc.is_included_column
  from sys.tables tb 
  inner join sys.indexes ix on tb.object_id=ix.object_id
  inner join sys.index_columns ixc on ix.object_id=ixc.object_id and ix.index_id= ixc.index_id
  inner join sys.columns col on ixc.object_id =col.object_id  and ixc.column_id=col.column_id
  where ix.type>0 and (ix.is_primary_key=0 or ix.is_unique_constraint=0)
  and schema_name(tb.schema_id)=@SchemaName and tb.name=@TableName and ix.name=@IndexName
  order by ixc.index_column_id
 
 open CursorIndexColumn 
 fetch next from CursorIndexColumn into  @ColumnName, @IsDescendingKey, @IsIncludedColumn
 
 while (@@fetch_status=0)
 begin
  if @IsIncludedColumn=0 
   set @IndexColumns=@IndexColumns + @ColumnName  + case when @IsDescendingKey=1  then ' DESC, ' else  ' ASC, ' end
  else 
   set @IncludedColumns=@IncludedColumns  + @ColumnName  +', ' 

  fetch next from CursorIndexColumn into @ColumnName, @IsDescendingKey, @IsIncludedColumn
 end

 close CursorIndexColumn
 deallocate CursorIndexColumn

 set @IndexColumns = substring(@IndexColumns, 1, len(@IndexColumns)-1)
 set @IncludedColumns = case when len(@IncludedColumns) >0 then substring(@IncludedColumns, 1, len(@IncludedColumns)-1) else '' end
 --  print @IndexColumns
 --  print @IncludedColumns

 set @TSQLScripCreationIndex =''
 set @TSQLScripDisableIndex =''
 set @TSQLScripCreationIndex='CREATE '+ @is_unique  +@IndexTypeDesc + ' INDEX ' +QUOTENAME(@IndexName)+' ON ' + QUOTENAME(@SchemaName) +'.'+ QUOTENAME(@TableName)+ '('+@IndexColumns+') '+ 
  case when len(@IncludedColumns)>0 then CHAR(13) +'INCLUDE (' + @IncludedColumns+ ')' else '' end + CHAR(13)+'WITH (' + @IndexOptions+ ') ON ' + QUOTENAME(@FileGroupName) + ';'  

 if @is_disabled=1 
  set  @TSQLScripDisableIndex=  CHAR(13) +'ALTER INDEX ' +QUOTENAME(@IndexName) + ' ON ' + QUOTENAME(@SchemaName) +'.'+ QUOTENAME(@TableName) + ' DISABLE;' + CHAR(13) 

 print @TSQLScripCreationIndex
 print @TSQLScripDisableIndex

 fetch next from CursorIndex into  @SchemaName, @TableName, @IndexName, @is_unique, @IndexTypeDesc, @IndexOptions,@is_disabled, @FileGroupName

end
close CursorIndex
deallocate CursorIndex



--Tablas en un filegroup

SELECT o.[name] AS TableName, i.[name] AS IndexName, fg.[name] AS FileGroupName
FROM sys.indexes i
INNER JOIN sys.filegroups fg ON i.data_space_id = fg.data_space_id
INNER JOIN sys.all_objects o ON i.[object_id] = o.[object_id]
WHERE i.data_space_id = fg.data_space_id AND o.type = 'U'
 and fg.name = 'BIG_TABLES'
 
 --este tambien
      SELECT distinct o.[name], o.[type], f.[name] FROM sys.indexes i
     INNER JOIN sys.filegroups f
     ON i.data_space_id = f.data_space_id
     INNER JOIN sys.all_objects o
     ON i.[object_id] = o.[object_id] 
     AND o.type = 'U' -- User Created Tables
	 and f.name = 'BIG_TABLES'
     GO
     
     
   https://www.mssqltips.com/sqlservertip/5832/move-sql-server-tables-to-different-filegroups/  
CST_BILL_TOTALS_ACCOUNT_N
CST_BILL_N
CST_PAYMENT_DETAIL_N
CST_QUERY_N
CST_QUERY_HISTORY_N
CST_QUERY_CALL_N
CST_QUERY_NOTES_N
CST_ADDRESS_N
CST_CUSTOMER_PRODUCT_N    


select owner,segment_name,segment_type,tablespace_name,sum(bytes/1024/1024)from dba_segments where segment_type='TEMPORARY'
 group by owner,segment_name,segment_type,tablespace_name,bytes;
 
 
 
 
 
 How to Move Temp File Location in Oracle
 https://logic.edchen.org/how-to-move-temp-file-location-in-oracle/
 
 
 
 How to Move Redo Log Location in Oracle
 https://logic.edchen.org/how-to-move-redo-log-location-in-oracle/
 
 
 
 --TROUBLESHOOT NETWORK LINUX  https://www.redhat.com/sysadmin/beginners-guide-network-troubleshooting-linux
 https://docs.microsoft.com/en-us/troubleshoot/azure/virtual-machines/troubleshoot-performance-bottlenecks-linux
 https://youtu.be/J73f6va-C_s
 
  ip -s link show
 mtr server
 vmstat
 mpstat
 pidstat
  
  
  
  'fm99G999D00'
  
 --WINDOWS VERSION desde SSMS CMS    -- Basic Server Info to obtain SQL Version and OS Version
  --https://gaijin.at/en/infos/windows-version-numbers
  --http://www.cookingsql.com/2016/01/sql-version/
  

SELECT
SERVERPROPERTY('ServerName')   'SQLServerName',
COALESCE(SERVERPROPERTY('InstanceName'),'DEFAULT') 'InstanceName',
SERVERPROPERTY('ProductVersion') 'ProductVersion',
SERVERPROPERTY('ProductLevel')   'ProductLevel',
SERVERPROPERTY('Edition')     'Edition',
CASE 
WHEN RIGHT(SUBSTRING(@@VERSION, CHARINDEX('Windows', @@VERSION), 34), 5)= 10.0 then 'Windows 2016'
WHEN RIGHT(SUBSTRING(@@VERSION, CHARINDEX('Windows NT', @@VERSION), 14), 3)= 6.3 then 'Windows 2012 R2'
WHEN RIGHT(SUBSTRING(@@VERSION, CHARINDEX('Windows NT', @@VERSION), 14), 3)= 6.2 then 'Windows 2012'
WHEN RIGHT(SUBSTRING(@@VERSION, CHARINDEX('Windows NT', @@VERSION), 14), 3)= 6.1 then 'Windows 2008R2'
WHEN RIGHT(SUBSTRING(@@VERSION, CHARINDEX('Windows NT', @@VERSION), 14), 3)= 6.0 then 'Windows 2008'
WHEN RIGHT(SUBSTRING(@@VERSION, CHARINDEX('Windows NT', @@VERSION), 14), 3)= 5.2 then 'Windows 2003'
WHEN RIGHT(SUBSTRING(@@VERSION, CHARINDEX('Windows NT', @@VERSION), 14), 3)= 5.1 then 'Windows XP'
WHEN RIGHT(SUBSTRING(@@VERSION, CHARINDEX('Windows NT', @@VERSION), 14), 3)= 5.0 then 'Windows 2000'
ELSE RIGHT(SUBSTRING(@@VERSION, CHARINDEX('Windows NT', @@VERSION), 14), 3)
END  'Windows Version'



REVISION DE PIPES EN TODOS LOS ARCHIVOS
for i in $(ls *.dat); do cat $i | head -10; done


--SOLARIS CPU MEMORIA
psrinfo -pv
prtdiag -v | grep Memory

--Finding CPU information on T-series hardware with LDOMs
If you have LDOMs installed on the T-series hardware tyhat you have, above commands may not give you the correct values. Use the “ldm list-devices -a” command to list core, virtual CPUs (VCPUs) and resource assignments.

# ldm list-devices -a


--QUERIES VARIOS
https://oracle-base.com/dba/scripts
https://dbakevlar.com/scripts/
